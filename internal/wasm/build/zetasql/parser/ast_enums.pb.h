// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zetasql/parser/ast_enums.proto

#ifndef PROTOBUF_INCLUDED_zetasql_2fparser_2fast_5fenums_2eproto
#define PROTOBUF_INCLUDED_zetasql_2fparser_2fast_5fenums_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_zetasql_2fparser_2fast_5fenums_2eproto 

namespace protobuf_zetasql_2fparser_2fast_5fenums_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[31];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_zetasql_2fparser_2fast_5fenums_2eproto
namespace zetasql {
class ASTAnySomeAllOpEnums;
class ASTAnySomeAllOpEnumsDefaultTypeInternal;
extern ASTAnySomeAllOpEnumsDefaultTypeInternal _ASTAnySomeAllOpEnums_default_instance_;
class ASTAuxLoadDataStatementEnums;
class ASTAuxLoadDataStatementEnumsDefaultTypeInternal;
extern ASTAuxLoadDataStatementEnumsDefaultTypeInternal _ASTAuxLoadDataStatementEnums_default_instance_;
class ASTBinaryExpressionEnums;
class ASTBinaryExpressionEnumsDefaultTypeInternal;
extern ASTBinaryExpressionEnumsDefaultTypeInternal _ASTBinaryExpressionEnums_default_instance_;
class ASTBreakContinueStatementEnums;
class ASTBreakContinueStatementEnumsDefaultTypeInternal;
extern ASTBreakContinueStatementEnumsDefaultTypeInternal _ASTBreakContinueStatementEnums_default_instance_;
class ASTColumnPositionEnums;
class ASTColumnPositionEnumsDefaultTypeInternal;
extern ASTColumnPositionEnumsDefaultTypeInternal _ASTColumnPositionEnums_default_instance_;
class ASTCreateFunctionStmtBaseEnums;
class ASTCreateFunctionStmtBaseEnumsDefaultTypeInternal;
extern ASTCreateFunctionStmtBaseEnumsDefaultTypeInternal _ASTCreateFunctionStmtBaseEnums_default_instance_;
class ASTCreateStatementEnums;
class ASTCreateStatementEnumsDefaultTypeInternal;
extern ASTCreateStatementEnumsDefaultTypeInternal _ASTCreateStatementEnums_default_instance_;
class ASTDropStatementEnums;
class ASTDropStatementEnumsDefaultTypeInternal;
extern ASTDropStatementEnumsDefaultTypeInternal _ASTDropStatementEnums_default_instance_;
class ASTExpressionSubqueryEnums;
class ASTExpressionSubqueryEnumsDefaultTypeInternal;
extern ASTExpressionSubqueryEnumsDefaultTypeInternal _ASTExpressionSubqueryEnums_default_instance_;
class ASTFilterFieldsArgEnums;
class ASTFilterFieldsArgEnumsDefaultTypeInternal;
extern ASTFilterFieldsArgEnumsDefaultTypeInternal _ASTFilterFieldsArgEnums_default_instance_;
class ASTForeignKeyActionsEnums;
class ASTForeignKeyActionsEnumsDefaultTypeInternal;
extern ASTForeignKeyActionsEnumsDefaultTypeInternal _ASTForeignKeyActionsEnums_default_instance_;
class ASTForeignKeyReferenceEnums;
class ASTForeignKeyReferenceEnumsDefaultTypeInternal;
extern ASTForeignKeyReferenceEnumsDefaultTypeInternal _ASTForeignKeyReferenceEnums_default_instance_;
class ASTFunctionCallEnums;
class ASTFunctionCallEnumsDefaultTypeInternal;
extern ASTFunctionCallEnumsDefaultTypeInternal _ASTFunctionCallEnums_default_instance_;
class ASTFunctionParameterEnums;
class ASTFunctionParameterEnumsDefaultTypeInternal;
extern ASTFunctionParameterEnumsDefaultTypeInternal _ASTFunctionParameterEnums_default_instance_;
class ASTGeneratedColumnInfoEnums;
class ASTGeneratedColumnInfoEnumsDefaultTypeInternal;
extern ASTGeneratedColumnInfoEnumsDefaultTypeInternal _ASTGeneratedColumnInfoEnums_default_instance_;
class ASTHavingModifierEnums;
class ASTHavingModifierEnumsDefaultTypeInternal;
extern ASTHavingModifierEnumsDefaultTypeInternal _ASTHavingModifierEnums_default_instance_;
class ASTImportStatementEnums;
class ASTImportStatementEnumsDefaultTypeInternal;
extern ASTImportStatementEnumsDefaultTypeInternal _ASTImportStatementEnums_default_instance_;
class ASTInsertStatementEnums;
class ASTInsertStatementEnumsDefaultTypeInternal;
extern ASTInsertStatementEnumsDefaultTypeInternal _ASTInsertStatementEnums_default_instance_;
class ASTJoinEnums;
class ASTJoinEnumsDefaultTypeInternal;
extern ASTJoinEnumsDefaultTypeInternal _ASTJoinEnums_default_instance_;
class ASTMergeActionEnums;
class ASTMergeActionEnumsDefaultTypeInternal;
extern ASTMergeActionEnumsDefaultTypeInternal _ASTMergeActionEnums_default_instance_;
class ASTMergeWhenClauseEnums;
class ASTMergeWhenClauseEnumsDefaultTypeInternal;
extern ASTMergeWhenClauseEnumsDefaultTypeInternal _ASTMergeWhenClauseEnums_default_instance_;
class ASTOrderingExpressionEnums;
class ASTOrderingExpressionEnumsDefaultTypeInternal;
extern ASTOrderingExpressionEnumsDefaultTypeInternal _ASTOrderingExpressionEnums_default_instance_;
class ASTSampleSizeEnums;
class ASTSampleSizeEnumsDefaultTypeInternal;
extern ASTSampleSizeEnumsDefaultTypeInternal _ASTSampleSizeEnums_default_instance_;
class ASTSelectAsEnums;
class ASTSelectAsEnumsDefaultTypeInternal;
extern ASTSelectAsEnumsDefaultTypeInternal _ASTSelectAsEnums_default_instance_;
class ASTSetOperationEnums;
class ASTSetOperationEnumsDefaultTypeInternal;
extern ASTSetOperationEnumsDefaultTypeInternal _ASTSetOperationEnums_default_instance_;
class ASTTemplatedParameterTypeEnums;
class ASTTemplatedParameterTypeEnumsDefaultTypeInternal;
extern ASTTemplatedParameterTypeEnumsDefaultTypeInternal _ASTTemplatedParameterTypeEnums_default_instance_;
class ASTTransactionReadWriteModeEnums;
class ASTTransactionReadWriteModeEnumsDefaultTypeInternal;
extern ASTTransactionReadWriteModeEnumsDefaultTypeInternal _ASTTransactionReadWriteModeEnums_default_instance_;
class ASTUnaryExpressionEnums;
class ASTUnaryExpressionEnumsDefaultTypeInternal;
extern ASTUnaryExpressionEnumsDefaultTypeInternal _ASTUnaryExpressionEnums_default_instance_;
class ASTUnpivotClauseEnums;
class ASTUnpivotClauseEnumsDefaultTypeInternal;
extern ASTUnpivotClauseEnumsDefaultTypeInternal _ASTUnpivotClauseEnums_default_instance_;
class ASTWindowFrameEnums;
class ASTWindowFrameEnumsDefaultTypeInternal;
extern ASTWindowFrameEnumsDefaultTypeInternal _ASTWindowFrameEnums_default_instance_;
class ASTWindowFrameExprEnums;
class ASTWindowFrameExprEnumsDefaultTypeInternal;
extern ASTWindowFrameExprEnumsDefaultTypeInternal _ASTWindowFrameExprEnums_default_instance_;
}  // namespace zetasql
namespace google {
namespace protobuf {
template<> ::zetasql::ASTAnySomeAllOpEnums* Arena::CreateMaybeMessage<::zetasql::ASTAnySomeAllOpEnums>(Arena*);
template<> ::zetasql::ASTAuxLoadDataStatementEnums* Arena::CreateMaybeMessage<::zetasql::ASTAuxLoadDataStatementEnums>(Arena*);
template<> ::zetasql::ASTBinaryExpressionEnums* Arena::CreateMaybeMessage<::zetasql::ASTBinaryExpressionEnums>(Arena*);
template<> ::zetasql::ASTBreakContinueStatementEnums* Arena::CreateMaybeMessage<::zetasql::ASTBreakContinueStatementEnums>(Arena*);
template<> ::zetasql::ASTColumnPositionEnums* Arena::CreateMaybeMessage<::zetasql::ASTColumnPositionEnums>(Arena*);
template<> ::zetasql::ASTCreateFunctionStmtBaseEnums* Arena::CreateMaybeMessage<::zetasql::ASTCreateFunctionStmtBaseEnums>(Arena*);
template<> ::zetasql::ASTCreateStatementEnums* Arena::CreateMaybeMessage<::zetasql::ASTCreateStatementEnums>(Arena*);
template<> ::zetasql::ASTDropStatementEnums* Arena::CreateMaybeMessage<::zetasql::ASTDropStatementEnums>(Arena*);
template<> ::zetasql::ASTExpressionSubqueryEnums* Arena::CreateMaybeMessage<::zetasql::ASTExpressionSubqueryEnums>(Arena*);
template<> ::zetasql::ASTFilterFieldsArgEnums* Arena::CreateMaybeMessage<::zetasql::ASTFilterFieldsArgEnums>(Arena*);
template<> ::zetasql::ASTForeignKeyActionsEnums* Arena::CreateMaybeMessage<::zetasql::ASTForeignKeyActionsEnums>(Arena*);
template<> ::zetasql::ASTForeignKeyReferenceEnums* Arena::CreateMaybeMessage<::zetasql::ASTForeignKeyReferenceEnums>(Arena*);
template<> ::zetasql::ASTFunctionCallEnums* Arena::CreateMaybeMessage<::zetasql::ASTFunctionCallEnums>(Arena*);
template<> ::zetasql::ASTFunctionParameterEnums* Arena::CreateMaybeMessage<::zetasql::ASTFunctionParameterEnums>(Arena*);
template<> ::zetasql::ASTGeneratedColumnInfoEnums* Arena::CreateMaybeMessage<::zetasql::ASTGeneratedColumnInfoEnums>(Arena*);
template<> ::zetasql::ASTHavingModifierEnums* Arena::CreateMaybeMessage<::zetasql::ASTHavingModifierEnums>(Arena*);
template<> ::zetasql::ASTImportStatementEnums* Arena::CreateMaybeMessage<::zetasql::ASTImportStatementEnums>(Arena*);
template<> ::zetasql::ASTInsertStatementEnums* Arena::CreateMaybeMessage<::zetasql::ASTInsertStatementEnums>(Arena*);
template<> ::zetasql::ASTJoinEnums* Arena::CreateMaybeMessage<::zetasql::ASTJoinEnums>(Arena*);
template<> ::zetasql::ASTMergeActionEnums* Arena::CreateMaybeMessage<::zetasql::ASTMergeActionEnums>(Arena*);
template<> ::zetasql::ASTMergeWhenClauseEnums* Arena::CreateMaybeMessage<::zetasql::ASTMergeWhenClauseEnums>(Arena*);
template<> ::zetasql::ASTOrderingExpressionEnums* Arena::CreateMaybeMessage<::zetasql::ASTOrderingExpressionEnums>(Arena*);
template<> ::zetasql::ASTSampleSizeEnums* Arena::CreateMaybeMessage<::zetasql::ASTSampleSizeEnums>(Arena*);
template<> ::zetasql::ASTSelectAsEnums* Arena::CreateMaybeMessage<::zetasql::ASTSelectAsEnums>(Arena*);
template<> ::zetasql::ASTSetOperationEnums* Arena::CreateMaybeMessage<::zetasql::ASTSetOperationEnums>(Arena*);
template<> ::zetasql::ASTTemplatedParameterTypeEnums* Arena::CreateMaybeMessage<::zetasql::ASTTemplatedParameterTypeEnums>(Arena*);
template<> ::zetasql::ASTTransactionReadWriteModeEnums* Arena::CreateMaybeMessage<::zetasql::ASTTransactionReadWriteModeEnums>(Arena*);
template<> ::zetasql::ASTUnaryExpressionEnums* Arena::CreateMaybeMessage<::zetasql::ASTUnaryExpressionEnums>(Arena*);
template<> ::zetasql::ASTUnpivotClauseEnums* Arena::CreateMaybeMessage<::zetasql::ASTUnpivotClauseEnums>(Arena*);
template<> ::zetasql::ASTWindowFrameEnums* Arena::CreateMaybeMessage<::zetasql::ASTWindowFrameEnums>(Arena*);
template<> ::zetasql::ASTWindowFrameExprEnums* Arena::CreateMaybeMessage<::zetasql::ASTWindowFrameExprEnums>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace zetasql {

enum ASTBinaryExpressionEnums_Op {
  ASTBinaryExpressionEnums_Op_NOT_SET = 0,
  ASTBinaryExpressionEnums_Op_LIKE = 1,
  ASTBinaryExpressionEnums_Op_IS = 2,
  ASTBinaryExpressionEnums_Op_EQ = 3,
  ASTBinaryExpressionEnums_Op_NE = 4,
  ASTBinaryExpressionEnums_Op_NE2 = 5,
  ASTBinaryExpressionEnums_Op_GT = 6,
  ASTBinaryExpressionEnums_Op_LT = 7,
  ASTBinaryExpressionEnums_Op_GE = 8,
  ASTBinaryExpressionEnums_Op_LE = 9,
  ASTBinaryExpressionEnums_Op_BITWISE_OR = 10,
  ASTBinaryExpressionEnums_Op_BITWISE_XOR = 11,
  ASTBinaryExpressionEnums_Op_BITWISE_AND = 12,
  ASTBinaryExpressionEnums_Op_PLUS = 13,
  ASTBinaryExpressionEnums_Op_MINUS = 14,
  ASTBinaryExpressionEnums_Op_MULTIPLY = 15,
  ASTBinaryExpressionEnums_Op_DIVIDE = 16,
  ASTBinaryExpressionEnums_Op_CONCAT_OP = 17,
  ASTBinaryExpressionEnums_Op_DISTINCT = 18
};
bool ASTBinaryExpressionEnums_Op_IsValid(int value);
const ASTBinaryExpressionEnums_Op ASTBinaryExpressionEnums_Op_Op_MIN = ASTBinaryExpressionEnums_Op_NOT_SET;
const ASTBinaryExpressionEnums_Op ASTBinaryExpressionEnums_Op_Op_MAX = ASTBinaryExpressionEnums_Op_DISTINCT;
const int ASTBinaryExpressionEnums_Op_Op_ARRAYSIZE = ASTBinaryExpressionEnums_Op_Op_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTBinaryExpressionEnums_Op_descriptor();
inline const ::std::string& ASTBinaryExpressionEnums_Op_Name(ASTBinaryExpressionEnums_Op value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTBinaryExpressionEnums_Op_descriptor(), value);
}
inline bool ASTBinaryExpressionEnums_Op_Parse(
    const ::std::string& name, ASTBinaryExpressionEnums_Op* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTBinaryExpressionEnums_Op>(
    ASTBinaryExpressionEnums_Op_descriptor(), name, value);
}
enum ASTOrderingExpressionEnums_OrderingSpec {
  ASTOrderingExpressionEnums_OrderingSpec_NOT_SET = 0,
  ASTOrderingExpressionEnums_OrderingSpec_ASC = 1,
  ASTOrderingExpressionEnums_OrderingSpec_DESC = 2,
  ASTOrderingExpressionEnums_OrderingSpec_UNSPECIFIED = 3
};
bool ASTOrderingExpressionEnums_OrderingSpec_IsValid(int value);
const ASTOrderingExpressionEnums_OrderingSpec ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_MIN = ASTOrderingExpressionEnums_OrderingSpec_NOT_SET;
const ASTOrderingExpressionEnums_OrderingSpec ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_MAX = ASTOrderingExpressionEnums_OrderingSpec_UNSPECIFIED;
const int ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_ARRAYSIZE = ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTOrderingExpressionEnums_OrderingSpec_descriptor();
inline const ::std::string& ASTOrderingExpressionEnums_OrderingSpec_Name(ASTOrderingExpressionEnums_OrderingSpec value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTOrderingExpressionEnums_OrderingSpec_descriptor(), value);
}
inline bool ASTOrderingExpressionEnums_OrderingSpec_Parse(
    const ::std::string& name, ASTOrderingExpressionEnums_OrderingSpec* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTOrderingExpressionEnums_OrderingSpec>(
    ASTOrderingExpressionEnums_OrderingSpec_descriptor(), name, value);
}
enum ASTJoinEnums_JoinType {
  ASTJoinEnums_JoinType_DEFAULT_JOIN_TYPE = 0,
  ASTJoinEnums_JoinType_COMMA = 1,
  ASTJoinEnums_JoinType_CROSS = 2,
  ASTJoinEnums_JoinType_FULL = 3,
  ASTJoinEnums_JoinType_INNER = 4,
  ASTJoinEnums_JoinType_LEFT = 5,
  ASTJoinEnums_JoinType_RIGHT = 6
};
bool ASTJoinEnums_JoinType_IsValid(int value);
const ASTJoinEnums_JoinType ASTJoinEnums_JoinType_JoinType_MIN = ASTJoinEnums_JoinType_DEFAULT_JOIN_TYPE;
const ASTJoinEnums_JoinType ASTJoinEnums_JoinType_JoinType_MAX = ASTJoinEnums_JoinType_RIGHT;
const int ASTJoinEnums_JoinType_JoinType_ARRAYSIZE = ASTJoinEnums_JoinType_JoinType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTJoinEnums_JoinType_descriptor();
inline const ::std::string& ASTJoinEnums_JoinType_Name(ASTJoinEnums_JoinType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTJoinEnums_JoinType_descriptor(), value);
}
inline bool ASTJoinEnums_JoinType_Parse(
    const ::std::string& name, ASTJoinEnums_JoinType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTJoinEnums_JoinType>(
    ASTJoinEnums_JoinType_descriptor(), name, value);
}
enum ASTJoinEnums_JoinHint {
  ASTJoinEnums_JoinHint_NO_JOIN_HINT = 0,
  ASTJoinEnums_JoinHint_HASH = 1,
  ASTJoinEnums_JoinHint_LOOKUP = 2
};
bool ASTJoinEnums_JoinHint_IsValid(int value);
const ASTJoinEnums_JoinHint ASTJoinEnums_JoinHint_JoinHint_MIN = ASTJoinEnums_JoinHint_NO_JOIN_HINT;
const ASTJoinEnums_JoinHint ASTJoinEnums_JoinHint_JoinHint_MAX = ASTJoinEnums_JoinHint_LOOKUP;
const int ASTJoinEnums_JoinHint_JoinHint_ARRAYSIZE = ASTJoinEnums_JoinHint_JoinHint_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTJoinEnums_JoinHint_descriptor();
inline const ::std::string& ASTJoinEnums_JoinHint_Name(ASTJoinEnums_JoinHint value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTJoinEnums_JoinHint_descriptor(), value);
}
inline bool ASTJoinEnums_JoinHint_Parse(
    const ::std::string& name, ASTJoinEnums_JoinHint* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTJoinEnums_JoinHint>(
    ASTJoinEnums_JoinHint_descriptor(), name, value);
}
enum ASTSelectAsEnums_AsMode {
  ASTSelectAsEnums_AsMode_NOT_SET = 0,
  ASTSelectAsEnums_AsMode_STRUCT = 1,
  ASTSelectAsEnums_AsMode_VALUE = 2,
  ASTSelectAsEnums_AsMode_TYPE_NAME = 3
};
bool ASTSelectAsEnums_AsMode_IsValid(int value);
const ASTSelectAsEnums_AsMode ASTSelectAsEnums_AsMode_AsMode_MIN = ASTSelectAsEnums_AsMode_NOT_SET;
const ASTSelectAsEnums_AsMode ASTSelectAsEnums_AsMode_AsMode_MAX = ASTSelectAsEnums_AsMode_TYPE_NAME;
const int ASTSelectAsEnums_AsMode_AsMode_ARRAYSIZE = ASTSelectAsEnums_AsMode_AsMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTSelectAsEnums_AsMode_descriptor();
inline const ::std::string& ASTSelectAsEnums_AsMode_Name(ASTSelectAsEnums_AsMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTSelectAsEnums_AsMode_descriptor(), value);
}
inline bool ASTSelectAsEnums_AsMode_Parse(
    const ::std::string& name, ASTSelectAsEnums_AsMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTSelectAsEnums_AsMode>(
    ASTSelectAsEnums_AsMode_descriptor(), name, value);
}
enum ASTFunctionCallEnums_NullHandlingModifier {
  ASTFunctionCallEnums_NullHandlingModifier_DEFAULT_NULL_HANDLING = 0,
  ASTFunctionCallEnums_NullHandlingModifier_IGNORE_NULLS = 1,
  ASTFunctionCallEnums_NullHandlingModifier_RESPECT_NULLS = 2
};
bool ASTFunctionCallEnums_NullHandlingModifier_IsValid(int value);
const ASTFunctionCallEnums_NullHandlingModifier ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_MIN = ASTFunctionCallEnums_NullHandlingModifier_DEFAULT_NULL_HANDLING;
const ASTFunctionCallEnums_NullHandlingModifier ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_MAX = ASTFunctionCallEnums_NullHandlingModifier_RESPECT_NULLS;
const int ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_ARRAYSIZE = ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTFunctionCallEnums_NullHandlingModifier_descriptor();
inline const ::std::string& ASTFunctionCallEnums_NullHandlingModifier_Name(ASTFunctionCallEnums_NullHandlingModifier value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTFunctionCallEnums_NullHandlingModifier_descriptor(), value);
}
inline bool ASTFunctionCallEnums_NullHandlingModifier_Parse(
    const ::std::string& name, ASTFunctionCallEnums_NullHandlingModifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTFunctionCallEnums_NullHandlingModifier>(
    ASTFunctionCallEnums_NullHandlingModifier_descriptor(), name, value);
}
enum ASTExpressionSubqueryEnums_Modifier {
  ASTExpressionSubqueryEnums_Modifier_NONE = 0,
  ASTExpressionSubqueryEnums_Modifier_ARRAY = 1,
  ASTExpressionSubqueryEnums_Modifier_EXISTS = 2
};
bool ASTExpressionSubqueryEnums_Modifier_IsValid(int value);
const ASTExpressionSubqueryEnums_Modifier ASTExpressionSubqueryEnums_Modifier_Modifier_MIN = ASTExpressionSubqueryEnums_Modifier_NONE;
const ASTExpressionSubqueryEnums_Modifier ASTExpressionSubqueryEnums_Modifier_Modifier_MAX = ASTExpressionSubqueryEnums_Modifier_EXISTS;
const int ASTExpressionSubqueryEnums_Modifier_Modifier_ARRAYSIZE = ASTExpressionSubqueryEnums_Modifier_Modifier_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTExpressionSubqueryEnums_Modifier_descriptor();
inline const ::std::string& ASTExpressionSubqueryEnums_Modifier_Name(ASTExpressionSubqueryEnums_Modifier value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTExpressionSubqueryEnums_Modifier_descriptor(), value);
}
inline bool ASTExpressionSubqueryEnums_Modifier_Parse(
    const ::std::string& name, ASTExpressionSubqueryEnums_Modifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTExpressionSubqueryEnums_Modifier>(
    ASTExpressionSubqueryEnums_Modifier_descriptor(), name, value);
}
enum ASTHavingModifierEnums_ModifierKind {
  ASTHavingModifierEnums_ModifierKind_NOT_SET = 0,
  ASTHavingModifierEnums_ModifierKind_MIN = 1,
  ASTHavingModifierEnums_ModifierKind_MAX = 2
};
bool ASTHavingModifierEnums_ModifierKind_IsValid(int value);
const ASTHavingModifierEnums_ModifierKind ASTHavingModifierEnums_ModifierKind_ModifierKind_MIN = ASTHavingModifierEnums_ModifierKind_NOT_SET;
const ASTHavingModifierEnums_ModifierKind ASTHavingModifierEnums_ModifierKind_ModifierKind_MAX = ASTHavingModifierEnums_ModifierKind_MAX;
const int ASTHavingModifierEnums_ModifierKind_ModifierKind_ARRAYSIZE = ASTHavingModifierEnums_ModifierKind_ModifierKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTHavingModifierEnums_ModifierKind_descriptor();
inline const ::std::string& ASTHavingModifierEnums_ModifierKind_Name(ASTHavingModifierEnums_ModifierKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTHavingModifierEnums_ModifierKind_descriptor(), value);
}
inline bool ASTHavingModifierEnums_ModifierKind_Parse(
    const ::std::string& name, ASTHavingModifierEnums_ModifierKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTHavingModifierEnums_ModifierKind>(
    ASTHavingModifierEnums_ModifierKind_descriptor(), name, value);
}
enum ASTSetOperationEnums_OperationType {
  ASTSetOperationEnums_OperationType_NOT_SET = 0,
  ASTSetOperationEnums_OperationType_UNION = 1,
  ASTSetOperationEnums_OperationType_EXCEPT = 2,
  ASTSetOperationEnums_OperationType_INTERSECT = 4
};
bool ASTSetOperationEnums_OperationType_IsValid(int value);
const ASTSetOperationEnums_OperationType ASTSetOperationEnums_OperationType_OperationType_MIN = ASTSetOperationEnums_OperationType_NOT_SET;
const ASTSetOperationEnums_OperationType ASTSetOperationEnums_OperationType_OperationType_MAX = ASTSetOperationEnums_OperationType_INTERSECT;
const int ASTSetOperationEnums_OperationType_OperationType_ARRAYSIZE = ASTSetOperationEnums_OperationType_OperationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTSetOperationEnums_OperationType_descriptor();
inline const ::std::string& ASTSetOperationEnums_OperationType_Name(ASTSetOperationEnums_OperationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTSetOperationEnums_OperationType_descriptor(), value);
}
inline bool ASTSetOperationEnums_OperationType_Parse(
    const ::std::string& name, ASTSetOperationEnums_OperationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTSetOperationEnums_OperationType>(
    ASTSetOperationEnums_OperationType_descriptor(), name, value);
}
enum ASTUnaryExpressionEnums_Op {
  ASTUnaryExpressionEnums_Op_NOT_SET = 0,
  ASTUnaryExpressionEnums_Op_NOT = 1,
  ASTUnaryExpressionEnums_Op_BITWISE_NOT = 2,
  ASTUnaryExpressionEnums_Op_MINUS = 3,
  ASTUnaryExpressionEnums_Op_PLUS = 4,
  ASTUnaryExpressionEnums_Op_IS_UNKNOWN = 5,
  ASTUnaryExpressionEnums_Op_IS_NOT_UNKNOWN = 6
};
bool ASTUnaryExpressionEnums_Op_IsValid(int value);
const ASTUnaryExpressionEnums_Op ASTUnaryExpressionEnums_Op_Op_MIN = ASTUnaryExpressionEnums_Op_NOT_SET;
const ASTUnaryExpressionEnums_Op ASTUnaryExpressionEnums_Op_Op_MAX = ASTUnaryExpressionEnums_Op_IS_NOT_UNKNOWN;
const int ASTUnaryExpressionEnums_Op_Op_ARRAYSIZE = ASTUnaryExpressionEnums_Op_Op_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTUnaryExpressionEnums_Op_descriptor();
inline const ::std::string& ASTUnaryExpressionEnums_Op_Name(ASTUnaryExpressionEnums_Op value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTUnaryExpressionEnums_Op_descriptor(), value);
}
inline bool ASTUnaryExpressionEnums_Op_Parse(
    const ::std::string& name, ASTUnaryExpressionEnums_Op* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTUnaryExpressionEnums_Op>(
    ASTUnaryExpressionEnums_Op_descriptor(), name, value);
}
enum ASTWindowFrameEnums_FrameUnit {
  ASTWindowFrameEnums_FrameUnit_ROWS = 1,
  ASTWindowFrameEnums_FrameUnit_RANGE = 2
};
bool ASTWindowFrameEnums_FrameUnit_IsValid(int value);
const ASTWindowFrameEnums_FrameUnit ASTWindowFrameEnums_FrameUnit_FrameUnit_MIN = ASTWindowFrameEnums_FrameUnit_ROWS;
const ASTWindowFrameEnums_FrameUnit ASTWindowFrameEnums_FrameUnit_FrameUnit_MAX = ASTWindowFrameEnums_FrameUnit_RANGE;
const int ASTWindowFrameEnums_FrameUnit_FrameUnit_ARRAYSIZE = ASTWindowFrameEnums_FrameUnit_FrameUnit_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTWindowFrameEnums_FrameUnit_descriptor();
inline const ::std::string& ASTWindowFrameEnums_FrameUnit_Name(ASTWindowFrameEnums_FrameUnit value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTWindowFrameEnums_FrameUnit_descriptor(), value);
}
inline bool ASTWindowFrameEnums_FrameUnit_Parse(
    const ::std::string& name, ASTWindowFrameEnums_FrameUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTWindowFrameEnums_FrameUnit>(
    ASTWindowFrameEnums_FrameUnit_descriptor(), name, value);
}
enum ASTWindowFrameExprEnums_BoundaryType {
  ASTWindowFrameExprEnums_BoundaryType_UNBOUNDED_PRECEDING = 1,
  ASTWindowFrameExprEnums_BoundaryType_OFFSET_PRECEDING = 2,
  ASTWindowFrameExprEnums_BoundaryType_CURRENT_ROW = 3,
  ASTWindowFrameExprEnums_BoundaryType_OFFSET_FOLLOWING = 4,
  ASTWindowFrameExprEnums_BoundaryType_UNBOUNDED_FOLLOWING = 5
};
bool ASTWindowFrameExprEnums_BoundaryType_IsValid(int value);
const ASTWindowFrameExprEnums_BoundaryType ASTWindowFrameExprEnums_BoundaryType_BoundaryType_MIN = ASTWindowFrameExprEnums_BoundaryType_UNBOUNDED_PRECEDING;
const ASTWindowFrameExprEnums_BoundaryType ASTWindowFrameExprEnums_BoundaryType_BoundaryType_MAX = ASTWindowFrameExprEnums_BoundaryType_UNBOUNDED_FOLLOWING;
const int ASTWindowFrameExprEnums_BoundaryType_BoundaryType_ARRAYSIZE = ASTWindowFrameExprEnums_BoundaryType_BoundaryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTWindowFrameExprEnums_BoundaryType_descriptor();
inline const ::std::string& ASTWindowFrameExprEnums_BoundaryType_Name(ASTWindowFrameExprEnums_BoundaryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTWindowFrameExprEnums_BoundaryType_descriptor(), value);
}
inline bool ASTWindowFrameExprEnums_BoundaryType_Parse(
    const ::std::string& name, ASTWindowFrameExprEnums_BoundaryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTWindowFrameExprEnums_BoundaryType>(
    ASTWindowFrameExprEnums_BoundaryType_descriptor(), name, value);
}
enum ASTAnySomeAllOpEnums_Op {
  ASTAnySomeAllOpEnums_Op_kUninitialized = 1,
  ASTAnySomeAllOpEnums_Op_kAny = 2,
  ASTAnySomeAllOpEnums_Op_kSome = 3,
  ASTAnySomeAllOpEnums_Op_kAll = 4
};
bool ASTAnySomeAllOpEnums_Op_IsValid(int value);
const ASTAnySomeAllOpEnums_Op ASTAnySomeAllOpEnums_Op_Op_MIN = ASTAnySomeAllOpEnums_Op_kUninitialized;
const ASTAnySomeAllOpEnums_Op ASTAnySomeAllOpEnums_Op_Op_MAX = ASTAnySomeAllOpEnums_Op_kAll;
const int ASTAnySomeAllOpEnums_Op_Op_ARRAYSIZE = ASTAnySomeAllOpEnums_Op_Op_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTAnySomeAllOpEnums_Op_descriptor();
inline const ::std::string& ASTAnySomeAllOpEnums_Op_Name(ASTAnySomeAllOpEnums_Op value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTAnySomeAllOpEnums_Op_descriptor(), value);
}
inline bool ASTAnySomeAllOpEnums_Op_Parse(
    const ::std::string& name, ASTAnySomeAllOpEnums_Op* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTAnySomeAllOpEnums_Op>(
    ASTAnySomeAllOpEnums_Op_descriptor(), name, value);
}
enum ASTTransactionReadWriteModeEnums_Mode {
  ASTTransactionReadWriteModeEnums_Mode_INVALID = 0,
  ASTTransactionReadWriteModeEnums_Mode_READ_ONLY = 1,
  ASTTransactionReadWriteModeEnums_Mode_READ_WRITE = 2
};
bool ASTTransactionReadWriteModeEnums_Mode_IsValid(int value);
const ASTTransactionReadWriteModeEnums_Mode ASTTransactionReadWriteModeEnums_Mode_Mode_MIN = ASTTransactionReadWriteModeEnums_Mode_INVALID;
const ASTTransactionReadWriteModeEnums_Mode ASTTransactionReadWriteModeEnums_Mode_Mode_MAX = ASTTransactionReadWriteModeEnums_Mode_READ_WRITE;
const int ASTTransactionReadWriteModeEnums_Mode_Mode_ARRAYSIZE = ASTTransactionReadWriteModeEnums_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTTransactionReadWriteModeEnums_Mode_descriptor();
inline const ::std::string& ASTTransactionReadWriteModeEnums_Mode_Name(ASTTransactionReadWriteModeEnums_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTTransactionReadWriteModeEnums_Mode_descriptor(), value);
}
inline bool ASTTransactionReadWriteModeEnums_Mode_Parse(
    const ::std::string& name, ASTTransactionReadWriteModeEnums_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTTransactionReadWriteModeEnums_Mode>(
    ASTTransactionReadWriteModeEnums_Mode_descriptor(), name, value);
}
enum ASTImportStatementEnums_ImportKind {
  ASTImportStatementEnums_ImportKind_MODULE = 1,
  ASTImportStatementEnums_ImportKind_PROTO = 2
};
bool ASTImportStatementEnums_ImportKind_IsValid(int value);
const ASTImportStatementEnums_ImportKind ASTImportStatementEnums_ImportKind_ImportKind_MIN = ASTImportStatementEnums_ImportKind_MODULE;
const ASTImportStatementEnums_ImportKind ASTImportStatementEnums_ImportKind_ImportKind_MAX = ASTImportStatementEnums_ImportKind_PROTO;
const int ASTImportStatementEnums_ImportKind_ImportKind_ARRAYSIZE = ASTImportStatementEnums_ImportKind_ImportKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTImportStatementEnums_ImportKind_descriptor();
inline const ::std::string& ASTImportStatementEnums_ImportKind_Name(ASTImportStatementEnums_ImportKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTImportStatementEnums_ImportKind_descriptor(), value);
}
inline bool ASTImportStatementEnums_ImportKind_Parse(
    const ::std::string& name, ASTImportStatementEnums_ImportKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTImportStatementEnums_ImportKind>(
    ASTImportStatementEnums_ImportKind_descriptor(), name, value);
}
enum ASTUnpivotClauseEnums_NullFilter {
  ASTUnpivotClauseEnums_NullFilter_kUnspecified = 1,
  ASTUnpivotClauseEnums_NullFilter_kInclude = 2,
  ASTUnpivotClauseEnums_NullFilter_kExclude = 3
};
bool ASTUnpivotClauseEnums_NullFilter_IsValid(int value);
const ASTUnpivotClauseEnums_NullFilter ASTUnpivotClauseEnums_NullFilter_NullFilter_MIN = ASTUnpivotClauseEnums_NullFilter_kUnspecified;
const ASTUnpivotClauseEnums_NullFilter ASTUnpivotClauseEnums_NullFilter_NullFilter_MAX = ASTUnpivotClauseEnums_NullFilter_kExclude;
const int ASTUnpivotClauseEnums_NullFilter_NullFilter_ARRAYSIZE = ASTUnpivotClauseEnums_NullFilter_NullFilter_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTUnpivotClauseEnums_NullFilter_descriptor();
inline const ::std::string& ASTUnpivotClauseEnums_NullFilter_Name(ASTUnpivotClauseEnums_NullFilter value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTUnpivotClauseEnums_NullFilter_descriptor(), value);
}
inline bool ASTUnpivotClauseEnums_NullFilter_Parse(
    const ::std::string& name, ASTUnpivotClauseEnums_NullFilter* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTUnpivotClauseEnums_NullFilter>(
    ASTUnpivotClauseEnums_NullFilter_descriptor(), name, value);
}
enum ASTCreateStatementEnums_Scope {
  ASTCreateStatementEnums_Scope_DEFAULT_SCOPE = 0,
  ASTCreateStatementEnums_Scope_PRIVATE = 1,
  ASTCreateStatementEnums_Scope_PUBLIC = 2,
  ASTCreateStatementEnums_Scope_TEMPORARY = 3
};
bool ASTCreateStatementEnums_Scope_IsValid(int value);
const ASTCreateStatementEnums_Scope ASTCreateStatementEnums_Scope_Scope_MIN = ASTCreateStatementEnums_Scope_DEFAULT_SCOPE;
const ASTCreateStatementEnums_Scope ASTCreateStatementEnums_Scope_Scope_MAX = ASTCreateStatementEnums_Scope_TEMPORARY;
const int ASTCreateStatementEnums_Scope_Scope_ARRAYSIZE = ASTCreateStatementEnums_Scope_Scope_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTCreateStatementEnums_Scope_descriptor();
inline const ::std::string& ASTCreateStatementEnums_Scope_Name(ASTCreateStatementEnums_Scope value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTCreateStatementEnums_Scope_descriptor(), value);
}
inline bool ASTCreateStatementEnums_Scope_Parse(
    const ::std::string& name, ASTCreateStatementEnums_Scope* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTCreateStatementEnums_Scope>(
    ASTCreateStatementEnums_Scope_descriptor(), name, value);
}
enum ASTCreateStatementEnums_SqlSecurity {
  ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_UNSPECIFIED = 0,
  ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_DEFINER = 1,
  ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_INVOKER = 2
};
bool ASTCreateStatementEnums_SqlSecurity_IsValid(int value);
const ASTCreateStatementEnums_SqlSecurity ASTCreateStatementEnums_SqlSecurity_SqlSecurity_MIN = ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_UNSPECIFIED;
const ASTCreateStatementEnums_SqlSecurity ASTCreateStatementEnums_SqlSecurity_SqlSecurity_MAX = ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_INVOKER;
const int ASTCreateStatementEnums_SqlSecurity_SqlSecurity_ARRAYSIZE = ASTCreateStatementEnums_SqlSecurity_SqlSecurity_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTCreateStatementEnums_SqlSecurity_descriptor();
inline const ::std::string& ASTCreateStatementEnums_SqlSecurity_Name(ASTCreateStatementEnums_SqlSecurity value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTCreateStatementEnums_SqlSecurity_descriptor(), value);
}
inline bool ASTCreateStatementEnums_SqlSecurity_Parse(
    const ::std::string& name, ASTCreateStatementEnums_SqlSecurity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTCreateStatementEnums_SqlSecurity>(
    ASTCreateStatementEnums_SqlSecurity_descriptor(), name, value);
}
enum ASTFunctionParameterEnums_ProcedureParameterMode {
  ASTFunctionParameterEnums_ProcedureParameterMode_NOT_SET = 0,
  ASTFunctionParameterEnums_ProcedureParameterMode_IN = 1,
  ASTFunctionParameterEnums_ProcedureParameterMode_OUT = 2,
  ASTFunctionParameterEnums_ProcedureParameterMode_INOUT = 3
};
bool ASTFunctionParameterEnums_ProcedureParameterMode_IsValid(int value);
const ASTFunctionParameterEnums_ProcedureParameterMode ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_MIN = ASTFunctionParameterEnums_ProcedureParameterMode_NOT_SET;
const ASTFunctionParameterEnums_ProcedureParameterMode ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_MAX = ASTFunctionParameterEnums_ProcedureParameterMode_INOUT;
const int ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_ARRAYSIZE = ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTFunctionParameterEnums_ProcedureParameterMode_descriptor();
inline const ::std::string& ASTFunctionParameterEnums_ProcedureParameterMode_Name(ASTFunctionParameterEnums_ProcedureParameterMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTFunctionParameterEnums_ProcedureParameterMode_descriptor(), value);
}
inline bool ASTFunctionParameterEnums_ProcedureParameterMode_Parse(
    const ::std::string& name, ASTFunctionParameterEnums_ProcedureParameterMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTFunctionParameterEnums_ProcedureParameterMode>(
    ASTFunctionParameterEnums_ProcedureParameterMode_descriptor(), name, value);
}
enum ASTTemplatedParameterTypeEnums_TemplatedTypeKind {
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_UNINITIALIZED = 1,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_TYPE = 2,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_PROTO = 3,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_ENUM = 4,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_STRUCT = 5,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_ARRAY = 6,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_TABLE = 7
};
bool ASTTemplatedParameterTypeEnums_TemplatedTypeKind_IsValid(int value);
const ASTTemplatedParameterTypeEnums_TemplatedTypeKind ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_MIN = ASTTemplatedParameterTypeEnums_TemplatedTypeKind_UNINITIALIZED;
const ASTTemplatedParameterTypeEnums_TemplatedTypeKind ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_MAX = ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_TABLE;
const int ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_ARRAYSIZE = ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTTemplatedParameterTypeEnums_TemplatedTypeKind_descriptor();
inline const ::std::string& ASTTemplatedParameterTypeEnums_TemplatedTypeKind_Name(ASTTemplatedParameterTypeEnums_TemplatedTypeKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_descriptor(), value);
}
inline bool ASTTemplatedParameterTypeEnums_TemplatedTypeKind_Parse(
    const ::std::string& name, ASTTemplatedParameterTypeEnums_TemplatedTypeKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTTemplatedParameterTypeEnums_TemplatedTypeKind>(
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_descriptor(), name, value);
}
enum ASTGeneratedColumnInfoEnums_StoredMode {
  ASTGeneratedColumnInfoEnums_StoredMode_NON_STORED = 0,
  ASTGeneratedColumnInfoEnums_StoredMode_STORED = 1,
  ASTGeneratedColumnInfoEnums_StoredMode_STORED_VOLATILE = 2
};
bool ASTGeneratedColumnInfoEnums_StoredMode_IsValid(int value);
const ASTGeneratedColumnInfoEnums_StoredMode ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_MIN = ASTGeneratedColumnInfoEnums_StoredMode_NON_STORED;
const ASTGeneratedColumnInfoEnums_StoredMode ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_MAX = ASTGeneratedColumnInfoEnums_StoredMode_STORED_VOLATILE;
const int ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_ARRAYSIZE = ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTGeneratedColumnInfoEnums_StoredMode_descriptor();
inline const ::std::string& ASTGeneratedColumnInfoEnums_StoredMode_Name(ASTGeneratedColumnInfoEnums_StoredMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTGeneratedColumnInfoEnums_StoredMode_descriptor(), value);
}
inline bool ASTGeneratedColumnInfoEnums_StoredMode_Parse(
    const ::std::string& name, ASTGeneratedColumnInfoEnums_StoredMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTGeneratedColumnInfoEnums_StoredMode>(
    ASTGeneratedColumnInfoEnums_StoredMode_descriptor(), name, value);
}
enum ASTColumnPositionEnums_RelativePositionType {
  ASTColumnPositionEnums_RelativePositionType_PRECEDING = 1,
  ASTColumnPositionEnums_RelativePositionType_FOLLOWING = 2
};
bool ASTColumnPositionEnums_RelativePositionType_IsValid(int value);
const ASTColumnPositionEnums_RelativePositionType ASTColumnPositionEnums_RelativePositionType_RelativePositionType_MIN = ASTColumnPositionEnums_RelativePositionType_PRECEDING;
const ASTColumnPositionEnums_RelativePositionType ASTColumnPositionEnums_RelativePositionType_RelativePositionType_MAX = ASTColumnPositionEnums_RelativePositionType_FOLLOWING;
const int ASTColumnPositionEnums_RelativePositionType_RelativePositionType_ARRAYSIZE = ASTColumnPositionEnums_RelativePositionType_RelativePositionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTColumnPositionEnums_RelativePositionType_descriptor();
inline const ::std::string& ASTColumnPositionEnums_RelativePositionType_Name(ASTColumnPositionEnums_RelativePositionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTColumnPositionEnums_RelativePositionType_descriptor(), value);
}
inline bool ASTColumnPositionEnums_RelativePositionType_Parse(
    const ::std::string& name, ASTColumnPositionEnums_RelativePositionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTColumnPositionEnums_RelativePositionType>(
    ASTColumnPositionEnums_RelativePositionType_descriptor(), name, value);
}
enum ASTInsertStatementEnums_InsertMode {
  ASTInsertStatementEnums_InsertMode_DEFAULT_MODE = 0,
  ASTInsertStatementEnums_InsertMode_REPLACE = 1,
  ASTInsertStatementEnums_InsertMode_UPDATE = 2,
  ASTInsertStatementEnums_InsertMode_IGNORE = 3
};
bool ASTInsertStatementEnums_InsertMode_IsValid(int value);
const ASTInsertStatementEnums_InsertMode ASTInsertStatementEnums_InsertMode_InsertMode_MIN = ASTInsertStatementEnums_InsertMode_DEFAULT_MODE;
const ASTInsertStatementEnums_InsertMode ASTInsertStatementEnums_InsertMode_InsertMode_MAX = ASTInsertStatementEnums_InsertMode_IGNORE;
const int ASTInsertStatementEnums_InsertMode_InsertMode_ARRAYSIZE = ASTInsertStatementEnums_InsertMode_InsertMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTInsertStatementEnums_InsertMode_descriptor();
inline const ::std::string& ASTInsertStatementEnums_InsertMode_Name(ASTInsertStatementEnums_InsertMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTInsertStatementEnums_InsertMode_descriptor(), value);
}
inline bool ASTInsertStatementEnums_InsertMode_Parse(
    const ::std::string& name, ASTInsertStatementEnums_InsertMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTInsertStatementEnums_InsertMode>(
    ASTInsertStatementEnums_InsertMode_descriptor(), name, value);
}
enum ASTInsertStatementEnums_ParseProgress {
  ASTInsertStatementEnums_ParseProgress_kInitial = 1,
  ASTInsertStatementEnums_ParseProgress_kSeenOrIgnoreReplaceUpdate = 2,
  ASTInsertStatementEnums_ParseProgress_kSeenTargetPath = 3,
  ASTInsertStatementEnums_ParseProgress_kSeenColumnList = 4,
  ASTInsertStatementEnums_ParseProgress_kSeenValuesList = 5
};
bool ASTInsertStatementEnums_ParseProgress_IsValid(int value);
const ASTInsertStatementEnums_ParseProgress ASTInsertStatementEnums_ParseProgress_ParseProgress_MIN = ASTInsertStatementEnums_ParseProgress_kInitial;
const ASTInsertStatementEnums_ParseProgress ASTInsertStatementEnums_ParseProgress_ParseProgress_MAX = ASTInsertStatementEnums_ParseProgress_kSeenValuesList;
const int ASTInsertStatementEnums_ParseProgress_ParseProgress_ARRAYSIZE = ASTInsertStatementEnums_ParseProgress_ParseProgress_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTInsertStatementEnums_ParseProgress_descriptor();
inline const ::std::string& ASTInsertStatementEnums_ParseProgress_Name(ASTInsertStatementEnums_ParseProgress value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTInsertStatementEnums_ParseProgress_descriptor(), value);
}
inline bool ASTInsertStatementEnums_ParseProgress_Parse(
    const ::std::string& name, ASTInsertStatementEnums_ParseProgress* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTInsertStatementEnums_ParseProgress>(
    ASTInsertStatementEnums_ParseProgress_descriptor(), name, value);
}
enum ASTMergeActionEnums_ActionType {
  ASTMergeActionEnums_ActionType_NOT_SET = 0,
  ASTMergeActionEnums_ActionType_INSERT = 1,
  ASTMergeActionEnums_ActionType_UPDATE = 2,
  ASTMergeActionEnums_ActionType_DELETE = 3
};
bool ASTMergeActionEnums_ActionType_IsValid(int value);
const ASTMergeActionEnums_ActionType ASTMergeActionEnums_ActionType_ActionType_MIN = ASTMergeActionEnums_ActionType_NOT_SET;
const ASTMergeActionEnums_ActionType ASTMergeActionEnums_ActionType_ActionType_MAX = ASTMergeActionEnums_ActionType_DELETE;
const int ASTMergeActionEnums_ActionType_ActionType_ARRAYSIZE = ASTMergeActionEnums_ActionType_ActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTMergeActionEnums_ActionType_descriptor();
inline const ::std::string& ASTMergeActionEnums_ActionType_Name(ASTMergeActionEnums_ActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTMergeActionEnums_ActionType_descriptor(), value);
}
inline bool ASTMergeActionEnums_ActionType_Parse(
    const ::std::string& name, ASTMergeActionEnums_ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTMergeActionEnums_ActionType>(
    ASTMergeActionEnums_ActionType_descriptor(), name, value);
}
enum ASTMergeWhenClauseEnums_MatchType {
  ASTMergeWhenClauseEnums_MatchType_NOT_SET = 0,
  ASTMergeWhenClauseEnums_MatchType_MATCHED = 1,
  ASTMergeWhenClauseEnums_MatchType_NOT_MATCHED_BY_SOURCE = 2,
  ASTMergeWhenClauseEnums_MatchType_NOT_MATCHED_BY_TARGET = 3
};
bool ASTMergeWhenClauseEnums_MatchType_IsValid(int value);
const ASTMergeWhenClauseEnums_MatchType ASTMergeWhenClauseEnums_MatchType_MatchType_MIN = ASTMergeWhenClauseEnums_MatchType_NOT_SET;
const ASTMergeWhenClauseEnums_MatchType ASTMergeWhenClauseEnums_MatchType_MatchType_MAX = ASTMergeWhenClauseEnums_MatchType_NOT_MATCHED_BY_TARGET;
const int ASTMergeWhenClauseEnums_MatchType_MatchType_ARRAYSIZE = ASTMergeWhenClauseEnums_MatchType_MatchType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTMergeWhenClauseEnums_MatchType_descriptor();
inline const ::std::string& ASTMergeWhenClauseEnums_MatchType_Name(ASTMergeWhenClauseEnums_MatchType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTMergeWhenClauseEnums_MatchType_descriptor(), value);
}
inline bool ASTMergeWhenClauseEnums_MatchType_Parse(
    const ::std::string& name, ASTMergeWhenClauseEnums_MatchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTMergeWhenClauseEnums_MatchType>(
    ASTMergeWhenClauseEnums_MatchType_descriptor(), name, value);
}
enum ASTFilterFieldsArgEnums_FilterType {
  ASTFilterFieldsArgEnums_FilterType_NOT_SET = 0,
  ASTFilterFieldsArgEnums_FilterType_INCLUDE = 1,
  ASTFilterFieldsArgEnums_FilterType_EXCLUDE = 2
};
bool ASTFilterFieldsArgEnums_FilterType_IsValid(int value);
const ASTFilterFieldsArgEnums_FilterType ASTFilterFieldsArgEnums_FilterType_FilterType_MIN = ASTFilterFieldsArgEnums_FilterType_NOT_SET;
const ASTFilterFieldsArgEnums_FilterType ASTFilterFieldsArgEnums_FilterType_FilterType_MAX = ASTFilterFieldsArgEnums_FilterType_EXCLUDE;
const int ASTFilterFieldsArgEnums_FilterType_FilterType_ARRAYSIZE = ASTFilterFieldsArgEnums_FilterType_FilterType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTFilterFieldsArgEnums_FilterType_descriptor();
inline const ::std::string& ASTFilterFieldsArgEnums_FilterType_Name(ASTFilterFieldsArgEnums_FilterType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTFilterFieldsArgEnums_FilterType_descriptor(), value);
}
inline bool ASTFilterFieldsArgEnums_FilterType_Parse(
    const ::std::string& name, ASTFilterFieldsArgEnums_FilterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTFilterFieldsArgEnums_FilterType>(
    ASTFilterFieldsArgEnums_FilterType_descriptor(), name, value);
}
enum ASTSampleSizeEnums_Unit {
  ASTSampleSizeEnums_Unit_NOT_SET = 0,
  ASTSampleSizeEnums_Unit_ROWS = 1,
  ASTSampleSizeEnums_Unit_PERCENT = 2
};
bool ASTSampleSizeEnums_Unit_IsValid(int value);
const ASTSampleSizeEnums_Unit ASTSampleSizeEnums_Unit_Unit_MIN = ASTSampleSizeEnums_Unit_NOT_SET;
const ASTSampleSizeEnums_Unit ASTSampleSizeEnums_Unit_Unit_MAX = ASTSampleSizeEnums_Unit_PERCENT;
const int ASTSampleSizeEnums_Unit_Unit_ARRAYSIZE = ASTSampleSizeEnums_Unit_Unit_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTSampleSizeEnums_Unit_descriptor();
inline const ::std::string& ASTSampleSizeEnums_Unit_Name(ASTSampleSizeEnums_Unit value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTSampleSizeEnums_Unit_descriptor(), value);
}
inline bool ASTSampleSizeEnums_Unit_Parse(
    const ::std::string& name, ASTSampleSizeEnums_Unit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTSampleSizeEnums_Unit>(
    ASTSampleSizeEnums_Unit_descriptor(), name, value);
}
enum ASTForeignKeyActionsEnums_Action {
  ASTForeignKeyActionsEnums_Action_NO_ACTION = 0,
  ASTForeignKeyActionsEnums_Action_RESTRICT = 1,
  ASTForeignKeyActionsEnums_Action_CASCADE = 2,
  ASTForeignKeyActionsEnums_Action_SET_NULL = 3
};
bool ASTForeignKeyActionsEnums_Action_IsValid(int value);
const ASTForeignKeyActionsEnums_Action ASTForeignKeyActionsEnums_Action_Action_MIN = ASTForeignKeyActionsEnums_Action_NO_ACTION;
const ASTForeignKeyActionsEnums_Action ASTForeignKeyActionsEnums_Action_Action_MAX = ASTForeignKeyActionsEnums_Action_SET_NULL;
const int ASTForeignKeyActionsEnums_Action_Action_ARRAYSIZE = ASTForeignKeyActionsEnums_Action_Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTForeignKeyActionsEnums_Action_descriptor();
inline const ::std::string& ASTForeignKeyActionsEnums_Action_Name(ASTForeignKeyActionsEnums_Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTForeignKeyActionsEnums_Action_descriptor(), value);
}
inline bool ASTForeignKeyActionsEnums_Action_Parse(
    const ::std::string& name, ASTForeignKeyActionsEnums_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTForeignKeyActionsEnums_Action>(
    ASTForeignKeyActionsEnums_Action_descriptor(), name, value);
}
enum ASTForeignKeyReferenceEnums_Match {
  ASTForeignKeyReferenceEnums_Match_SIMPLE = 1,
  ASTForeignKeyReferenceEnums_Match_FULL = 2,
  ASTForeignKeyReferenceEnums_Match_NOT_DISTINCT = 3
};
bool ASTForeignKeyReferenceEnums_Match_IsValid(int value);
const ASTForeignKeyReferenceEnums_Match ASTForeignKeyReferenceEnums_Match_Match_MIN = ASTForeignKeyReferenceEnums_Match_SIMPLE;
const ASTForeignKeyReferenceEnums_Match ASTForeignKeyReferenceEnums_Match_Match_MAX = ASTForeignKeyReferenceEnums_Match_NOT_DISTINCT;
const int ASTForeignKeyReferenceEnums_Match_Match_ARRAYSIZE = ASTForeignKeyReferenceEnums_Match_Match_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTForeignKeyReferenceEnums_Match_descriptor();
inline const ::std::string& ASTForeignKeyReferenceEnums_Match_Name(ASTForeignKeyReferenceEnums_Match value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTForeignKeyReferenceEnums_Match_descriptor(), value);
}
inline bool ASTForeignKeyReferenceEnums_Match_Parse(
    const ::std::string& name, ASTForeignKeyReferenceEnums_Match* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTForeignKeyReferenceEnums_Match>(
    ASTForeignKeyReferenceEnums_Match_descriptor(), name, value);
}
enum ASTBreakContinueStatementEnums_BreakContinueKeyword {
  ASTBreakContinueStatementEnums_BreakContinueKeyword_BREAK = 1,
  ASTBreakContinueStatementEnums_BreakContinueKeyword_LEAVE = 2,
  ASTBreakContinueStatementEnums_BreakContinueKeyword_CONTINUE = 3,
  ASTBreakContinueStatementEnums_BreakContinueKeyword_ITERATE = 4
};
bool ASTBreakContinueStatementEnums_BreakContinueKeyword_IsValid(int value);
const ASTBreakContinueStatementEnums_BreakContinueKeyword ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_MIN = ASTBreakContinueStatementEnums_BreakContinueKeyword_BREAK;
const ASTBreakContinueStatementEnums_BreakContinueKeyword ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_MAX = ASTBreakContinueStatementEnums_BreakContinueKeyword_ITERATE;
const int ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_ARRAYSIZE = ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTBreakContinueStatementEnums_BreakContinueKeyword_descriptor();
inline const ::std::string& ASTBreakContinueStatementEnums_BreakContinueKeyword_Name(ASTBreakContinueStatementEnums_BreakContinueKeyword value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTBreakContinueStatementEnums_BreakContinueKeyword_descriptor(), value);
}
inline bool ASTBreakContinueStatementEnums_BreakContinueKeyword_Parse(
    const ::std::string& name, ASTBreakContinueStatementEnums_BreakContinueKeyword* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTBreakContinueStatementEnums_BreakContinueKeyword>(
    ASTBreakContinueStatementEnums_BreakContinueKeyword_descriptor(), name, value);
}
enum ASTDropStatementEnums_DropMode {
  ASTDropStatementEnums_DropMode_DROP_MODE_UNSPECIFIED = 0,
  ASTDropStatementEnums_DropMode_RESTRICT = 1,
  ASTDropStatementEnums_DropMode_CASCADE = 2
};
bool ASTDropStatementEnums_DropMode_IsValid(int value);
const ASTDropStatementEnums_DropMode ASTDropStatementEnums_DropMode_DropMode_MIN = ASTDropStatementEnums_DropMode_DROP_MODE_UNSPECIFIED;
const ASTDropStatementEnums_DropMode ASTDropStatementEnums_DropMode_DropMode_MAX = ASTDropStatementEnums_DropMode_CASCADE;
const int ASTDropStatementEnums_DropMode_DropMode_ARRAYSIZE = ASTDropStatementEnums_DropMode_DropMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTDropStatementEnums_DropMode_descriptor();
inline const ::std::string& ASTDropStatementEnums_DropMode_Name(ASTDropStatementEnums_DropMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTDropStatementEnums_DropMode_descriptor(), value);
}
inline bool ASTDropStatementEnums_DropMode_Parse(
    const ::std::string& name, ASTDropStatementEnums_DropMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTDropStatementEnums_DropMode>(
    ASTDropStatementEnums_DropMode_descriptor(), name, value);
}
enum ASTCreateFunctionStmtBaseEnums_DeterminismLevel {
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DETERMINISM_UNSPECIFIED = 0,
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DETERMINISTIC = 1,
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_NOT_DETERMINISTIC = 2,
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_IMMUTABLE = 3,
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_STABLE = 4,
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_VOLATILE = 5
};
bool ASTCreateFunctionStmtBaseEnums_DeterminismLevel_IsValid(int value);
const ASTCreateFunctionStmtBaseEnums_DeterminismLevel ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_MIN = ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DETERMINISM_UNSPECIFIED;
const ASTCreateFunctionStmtBaseEnums_DeterminismLevel ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_MAX = ASTCreateFunctionStmtBaseEnums_DeterminismLevel_VOLATILE;
const int ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_ARRAYSIZE = ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTCreateFunctionStmtBaseEnums_DeterminismLevel_descriptor();
inline const ::std::string& ASTCreateFunctionStmtBaseEnums_DeterminismLevel_Name(ASTCreateFunctionStmtBaseEnums_DeterminismLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_descriptor(), value);
}
inline bool ASTCreateFunctionStmtBaseEnums_DeterminismLevel_Parse(
    const ::std::string& name, ASTCreateFunctionStmtBaseEnums_DeterminismLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTCreateFunctionStmtBaseEnums_DeterminismLevel>(
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_descriptor(), name, value);
}
enum ASTAuxLoadDataStatementEnums_InsertionMode {
  ASTAuxLoadDataStatementEnums_InsertionMode_NOT_SET = 0,
  ASTAuxLoadDataStatementEnums_InsertionMode_APPEND = 1,
  ASTAuxLoadDataStatementEnums_InsertionMode_OVERWRITE = 2
};
bool ASTAuxLoadDataStatementEnums_InsertionMode_IsValid(int value);
const ASTAuxLoadDataStatementEnums_InsertionMode ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_MIN = ASTAuxLoadDataStatementEnums_InsertionMode_NOT_SET;
const ASTAuxLoadDataStatementEnums_InsertionMode ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_MAX = ASTAuxLoadDataStatementEnums_InsertionMode_OVERWRITE;
const int ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_ARRAYSIZE = ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTAuxLoadDataStatementEnums_InsertionMode_descriptor();
inline const ::std::string& ASTAuxLoadDataStatementEnums_InsertionMode_Name(ASTAuxLoadDataStatementEnums_InsertionMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTAuxLoadDataStatementEnums_InsertionMode_descriptor(), value);
}
inline bool ASTAuxLoadDataStatementEnums_InsertionMode_Parse(
    const ::std::string& name, ASTAuxLoadDataStatementEnums_InsertionMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTAuxLoadDataStatementEnums_InsertionMode>(
    ASTAuxLoadDataStatementEnums_InsertionMode_descriptor(), name, value);
}
enum SchemaObjectKind {
  __SchemaObjectKind__switch_must_have_a_default__ = -1,
  kInvalidSchemaObjectKind = 1,
  kAggregateFunction = 2,
  kConstant = 3,
  kDatabase = 4,
  kExternalTable = 5,
  kFunction = 6,
  kIndex = 7,
  kMaterializedView = 8,
  kModel = 9,
  kProcedure = 10,
  kSchema = 11,
  kTable = 12,
  kTableFunction = 13,
  kView = 14,
  kSnapshotTable = 15
};
bool SchemaObjectKind_IsValid(int value);
const SchemaObjectKind SchemaObjectKind_MIN = __SchemaObjectKind__switch_must_have_a_default__;
const SchemaObjectKind SchemaObjectKind_MAX = kSnapshotTable;
const int SchemaObjectKind_ARRAYSIZE = SchemaObjectKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* SchemaObjectKind_descriptor();
inline const ::std::string& SchemaObjectKind_Name(SchemaObjectKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    SchemaObjectKind_descriptor(), value);
}
inline bool SchemaObjectKind_Parse(
    const ::std::string& name, SchemaObjectKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SchemaObjectKind>(
    SchemaObjectKind_descriptor(), name, value);
}
// ===================================================================

class ASTBinaryExpressionEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTBinaryExpressionEnums) */ {
 public:
  ASTBinaryExpressionEnums();
  virtual ~ASTBinaryExpressionEnums();

  ASTBinaryExpressionEnums(const ASTBinaryExpressionEnums& from);

  inline ASTBinaryExpressionEnums& operator=(const ASTBinaryExpressionEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTBinaryExpressionEnums(ASTBinaryExpressionEnums&& from) noexcept
    : ASTBinaryExpressionEnums() {
    *this = ::std::move(from);
  }

  inline ASTBinaryExpressionEnums& operator=(ASTBinaryExpressionEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTBinaryExpressionEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTBinaryExpressionEnums* internal_default_instance() {
    return reinterpret_cast<const ASTBinaryExpressionEnums*>(
               &_ASTBinaryExpressionEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ASTBinaryExpressionEnums* other);
  friend void swap(ASTBinaryExpressionEnums& a, ASTBinaryExpressionEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTBinaryExpressionEnums* New() const final {
    return CreateMaybeMessage<ASTBinaryExpressionEnums>(NULL);
  }

  ASTBinaryExpressionEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTBinaryExpressionEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTBinaryExpressionEnums& from);
  void MergeFrom(const ASTBinaryExpressionEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTBinaryExpressionEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTBinaryExpressionEnums_Op Op;
  static const Op NOT_SET =
    ASTBinaryExpressionEnums_Op_NOT_SET;
  static const Op LIKE =
    ASTBinaryExpressionEnums_Op_LIKE;
  static const Op IS =
    ASTBinaryExpressionEnums_Op_IS;
  static const Op EQ =
    ASTBinaryExpressionEnums_Op_EQ;
  static const Op NE =
    ASTBinaryExpressionEnums_Op_NE;
  static const Op NE2 =
    ASTBinaryExpressionEnums_Op_NE2;
  static const Op GT =
    ASTBinaryExpressionEnums_Op_GT;
  static const Op LT =
    ASTBinaryExpressionEnums_Op_LT;
  static const Op GE =
    ASTBinaryExpressionEnums_Op_GE;
  static const Op LE =
    ASTBinaryExpressionEnums_Op_LE;
  static const Op BITWISE_OR =
    ASTBinaryExpressionEnums_Op_BITWISE_OR;
  static const Op BITWISE_XOR =
    ASTBinaryExpressionEnums_Op_BITWISE_XOR;
  static const Op BITWISE_AND =
    ASTBinaryExpressionEnums_Op_BITWISE_AND;
  static const Op PLUS =
    ASTBinaryExpressionEnums_Op_PLUS;
  static const Op MINUS =
    ASTBinaryExpressionEnums_Op_MINUS;
  static const Op MULTIPLY =
    ASTBinaryExpressionEnums_Op_MULTIPLY;
  static const Op DIVIDE =
    ASTBinaryExpressionEnums_Op_DIVIDE;
  static const Op CONCAT_OP =
    ASTBinaryExpressionEnums_Op_CONCAT_OP;
  static const Op DISTINCT =
    ASTBinaryExpressionEnums_Op_DISTINCT;
  static inline bool Op_IsValid(int value) {
    return ASTBinaryExpressionEnums_Op_IsValid(value);
  }
  static const Op Op_MIN =
    ASTBinaryExpressionEnums_Op_Op_MIN;
  static const Op Op_MAX =
    ASTBinaryExpressionEnums_Op_Op_MAX;
  static const int Op_ARRAYSIZE =
    ASTBinaryExpressionEnums_Op_Op_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Op_descriptor() {
    return ASTBinaryExpressionEnums_Op_descriptor();
  }
  static inline const ::std::string& Op_Name(Op value) {
    return ASTBinaryExpressionEnums_Op_Name(value);
  }
  static inline bool Op_Parse(const ::std::string& name,
      Op* value) {
    return ASTBinaryExpressionEnums_Op_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTBinaryExpressionEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTOrderingExpressionEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTOrderingExpressionEnums) */ {
 public:
  ASTOrderingExpressionEnums();
  virtual ~ASTOrderingExpressionEnums();

  ASTOrderingExpressionEnums(const ASTOrderingExpressionEnums& from);

  inline ASTOrderingExpressionEnums& operator=(const ASTOrderingExpressionEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTOrderingExpressionEnums(ASTOrderingExpressionEnums&& from) noexcept
    : ASTOrderingExpressionEnums() {
    *this = ::std::move(from);
  }

  inline ASTOrderingExpressionEnums& operator=(ASTOrderingExpressionEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTOrderingExpressionEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTOrderingExpressionEnums* internal_default_instance() {
    return reinterpret_cast<const ASTOrderingExpressionEnums*>(
               &_ASTOrderingExpressionEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ASTOrderingExpressionEnums* other);
  friend void swap(ASTOrderingExpressionEnums& a, ASTOrderingExpressionEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTOrderingExpressionEnums* New() const final {
    return CreateMaybeMessage<ASTOrderingExpressionEnums>(NULL);
  }

  ASTOrderingExpressionEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTOrderingExpressionEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTOrderingExpressionEnums& from);
  void MergeFrom(const ASTOrderingExpressionEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTOrderingExpressionEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTOrderingExpressionEnums_OrderingSpec OrderingSpec;
  static const OrderingSpec NOT_SET =
    ASTOrderingExpressionEnums_OrderingSpec_NOT_SET;
  static const OrderingSpec ASC =
    ASTOrderingExpressionEnums_OrderingSpec_ASC;
  static const OrderingSpec DESC =
    ASTOrderingExpressionEnums_OrderingSpec_DESC;
  static const OrderingSpec UNSPECIFIED =
    ASTOrderingExpressionEnums_OrderingSpec_UNSPECIFIED;
  static inline bool OrderingSpec_IsValid(int value) {
    return ASTOrderingExpressionEnums_OrderingSpec_IsValid(value);
  }
  static const OrderingSpec OrderingSpec_MIN =
    ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_MIN;
  static const OrderingSpec OrderingSpec_MAX =
    ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_MAX;
  static const int OrderingSpec_ARRAYSIZE =
    ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OrderingSpec_descriptor() {
    return ASTOrderingExpressionEnums_OrderingSpec_descriptor();
  }
  static inline const ::std::string& OrderingSpec_Name(OrderingSpec value) {
    return ASTOrderingExpressionEnums_OrderingSpec_Name(value);
  }
  static inline bool OrderingSpec_Parse(const ::std::string& name,
      OrderingSpec* value) {
    return ASTOrderingExpressionEnums_OrderingSpec_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTOrderingExpressionEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTJoinEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTJoinEnums) */ {
 public:
  ASTJoinEnums();
  virtual ~ASTJoinEnums();

  ASTJoinEnums(const ASTJoinEnums& from);

  inline ASTJoinEnums& operator=(const ASTJoinEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTJoinEnums(ASTJoinEnums&& from) noexcept
    : ASTJoinEnums() {
    *this = ::std::move(from);
  }

  inline ASTJoinEnums& operator=(ASTJoinEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTJoinEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTJoinEnums* internal_default_instance() {
    return reinterpret_cast<const ASTJoinEnums*>(
               &_ASTJoinEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ASTJoinEnums* other);
  friend void swap(ASTJoinEnums& a, ASTJoinEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTJoinEnums* New() const final {
    return CreateMaybeMessage<ASTJoinEnums>(NULL);
  }

  ASTJoinEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTJoinEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTJoinEnums& from);
  void MergeFrom(const ASTJoinEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTJoinEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTJoinEnums_JoinType JoinType;
  static const JoinType DEFAULT_JOIN_TYPE =
    ASTJoinEnums_JoinType_DEFAULT_JOIN_TYPE;
  static const JoinType COMMA =
    ASTJoinEnums_JoinType_COMMA;
  static const JoinType CROSS =
    ASTJoinEnums_JoinType_CROSS;
  static const JoinType FULL =
    ASTJoinEnums_JoinType_FULL;
  static const JoinType INNER =
    ASTJoinEnums_JoinType_INNER;
  static const JoinType LEFT =
    ASTJoinEnums_JoinType_LEFT;
  static const JoinType RIGHT =
    ASTJoinEnums_JoinType_RIGHT;
  static inline bool JoinType_IsValid(int value) {
    return ASTJoinEnums_JoinType_IsValid(value);
  }
  static const JoinType JoinType_MIN =
    ASTJoinEnums_JoinType_JoinType_MIN;
  static const JoinType JoinType_MAX =
    ASTJoinEnums_JoinType_JoinType_MAX;
  static const int JoinType_ARRAYSIZE =
    ASTJoinEnums_JoinType_JoinType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  JoinType_descriptor() {
    return ASTJoinEnums_JoinType_descriptor();
  }
  static inline const ::std::string& JoinType_Name(JoinType value) {
    return ASTJoinEnums_JoinType_Name(value);
  }
  static inline bool JoinType_Parse(const ::std::string& name,
      JoinType* value) {
    return ASTJoinEnums_JoinType_Parse(name, value);
  }

  typedef ASTJoinEnums_JoinHint JoinHint;
  static const JoinHint NO_JOIN_HINT =
    ASTJoinEnums_JoinHint_NO_JOIN_HINT;
  static const JoinHint HASH =
    ASTJoinEnums_JoinHint_HASH;
  static const JoinHint LOOKUP =
    ASTJoinEnums_JoinHint_LOOKUP;
  static inline bool JoinHint_IsValid(int value) {
    return ASTJoinEnums_JoinHint_IsValid(value);
  }
  static const JoinHint JoinHint_MIN =
    ASTJoinEnums_JoinHint_JoinHint_MIN;
  static const JoinHint JoinHint_MAX =
    ASTJoinEnums_JoinHint_JoinHint_MAX;
  static const int JoinHint_ARRAYSIZE =
    ASTJoinEnums_JoinHint_JoinHint_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  JoinHint_descriptor() {
    return ASTJoinEnums_JoinHint_descriptor();
  }
  static inline const ::std::string& JoinHint_Name(JoinHint value) {
    return ASTJoinEnums_JoinHint_Name(value);
  }
  static inline bool JoinHint_Parse(const ::std::string& name,
      JoinHint* value) {
    return ASTJoinEnums_JoinHint_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTJoinEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTSelectAsEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTSelectAsEnums) */ {
 public:
  ASTSelectAsEnums();
  virtual ~ASTSelectAsEnums();

  ASTSelectAsEnums(const ASTSelectAsEnums& from);

  inline ASTSelectAsEnums& operator=(const ASTSelectAsEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTSelectAsEnums(ASTSelectAsEnums&& from) noexcept
    : ASTSelectAsEnums() {
    *this = ::std::move(from);
  }

  inline ASTSelectAsEnums& operator=(ASTSelectAsEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTSelectAsEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTSelectAsEnums* internal_default_instance() {
    return reinterpret_cast<const ASTSelectAsEnums*>(
               &_ASTSelectAsEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ASTSelectAsEnums* other);
  friend void swap(ASTSelectAsEnums& a, ASTSelectAsEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTSelectAsEnums* New() const final {
    return CreateMaybeMessage<ASTSelectAsEnums>(NULL);
  }

  ASTSelectAsEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTSelectAsEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTSelectAsEnums& from);
  void MergeFrom(const ASTSelectAsEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTSelectAsEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTSelectAsEnums_AsMode AsMode;
  static const AsMode NOT_SET =
    ASTSelectAsEnums_AsMode_NOT_SET;
  static const AsMode STRUCT =
    ASTSelectAsEnums_AsMode_STRUCT;
  static const AsMode VALUE =
    ASTSelectAsEnums_AsMode_VALUE;
  static const AsMode TYPE_NAME =
    ASTSelectAsEnums_AsMode_TYPE_NAME;
  static inline bool AsMode_IsValid(int value) {
    return ASTSelectAsEnums_AsMode_IsValid(value);
  }
  static const AsMode AsMode_MIN =
    ASTSelectAsEnums_AsMode_AsMode_MIN;
  static const AsMode AsMode_MAX =
    ASTSelectAsEnums_AsMode_AsMode_MAX;
  static const int AsMode_ARRAYSIZE =
    ASTSelectAsEnums_AsMode_AsMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AsMode_descriptor() {
    return ASTSelectAsEnums_AsMode_descriptor();
  }
  static inline const ::std::string& AsMode_Name(AsMode value) {
    return ASTSelectAsEnums_AsMode_Name(value);
  }
  static inline bool AsMode_Parse(const ::std::string& name,
      AsMode* value) {
    return ASTSelectAsEnums_AsMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTSelectAsEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTFunctionCallEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTFunctionCallEnums) */ {
 public:
  ASTFunctionCallEnums();
  virtual ~ASTFunctionCallEnums();

  ASTFunctionCallEnums(const ASTFunctionCallEnums& from);

  inline ASTFunctionCallEnums& operator=(const ASTFunctionCallEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTFunctionCallEnums(ASTFunctionCallEnums&& from) noexcept
    : ASTFunctionCallEnums() {
    *this = ::std::move(from);
  }

  inline ASTFunctionCallEnums& operator=(ASTFunctionCallEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTFunctionCallEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTFunctionCallEnums* internal_default_instance() {
    return reinterpret_cast<const ASTFunctionCallEnums*>(
               &_ASTFunctionCallEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ASTFunctionCallEnums* other);
  friend void swap(ASTFunctionCallEnums& a, ASTFunctionCallEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTFunctionCallEnums* New() const final {
    return CreateMaybeMessage<ASTFunctionCallEnums>(NULL);
  }

  ASTFunctionCallEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTFunctionCallEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTFunctionCallEnums& from);
  void MergeFrom(const ASTFunctionCallEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTFunctionCallEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTFunctionCallEnums_NullHandlingModifier NullHandlingModifier;
  static const NullHandlingModifier DEFAULT_NULL_HANDLING =
    ASTFunctionCallEnums_NullHandlingModifier_DEFAULT_NULL_HANDLING;
  static const NullHandlingModifier IGNORE_NULLS =
    ASTFunctionCallEnums_NullHandlingModifier_IGNORE_NULLS;
  static const NullHandlingModifier RESPECT_NULLS =
    ASTFunctionCallEnums_NullHandlingModifier_RESPECT_NULLS;
  static inline bool NullHandlingModifier_IsValid(int value) {
    return ASTFunctionCallEnums_NullHandlingModifier_IsValid(value);
  }
  static const NullHandlingModifier NullHandlingModifier_MIN =
    ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_MIN;
  static const NullHandlingModifier NullHandlingModifier_MAX =
    ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_MAX;
  static const int NullHandlingModifier_ARRAYSIZE =
    ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NullHandlingModifier_descriptor() {
    return ASTFunctionCallEnums_NullHandlingModifier_descriptor();
  }
  static inline const ::std::string& NullHandlingModifier_Name(NullHandlingModifier value) {
    return ASTFunctionCallEnums_NullHandlingModifier_Name(value);
  }
  static inline bool NullHandlingModifier_Parse(const ::std::string& name,
      NullHandlingModifier* value) {
    return ASTFunctionCallEnums_NullHandlingModifier_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTFunctionCallEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTExpressionSubqueryEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTExpressionSubqueryEnums) */ {
 public:
  ASTExpressionSubqueryEnums();
  virtual ~ASTExpressionSubqueryEnums();

  ASTExpressionSubqueryEnums(const ASTExpressionSubqueryEnums& from);

  inline ASTExpressionSubqueryEnums& operator=(const ASTExpressionSubqueryEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTExpressionSubqueryEnums(ASTExpressionSubqueryEnums&& from) noexcept
    : ASTExpressionSubqueryEnums() {
    *this = ::std::move(from);
  }

  inline ASTExpressionSubqueryEnums& operator=(ASTExpressionSubqueryEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTExpressionSubqueryEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTExpressionSubqueryEnums* internal_default_instance() {
    return reinterpret_cast<const ASTExpressionSubqueryEnums*>(
               &_ASTExpressionSubqueryEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ASTExpressionSubqueryEnums* other);
  friend void swap(ASTExpressionSubqueryEnums& a, ASTExpressionSubqueryEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTExpressionSubqueryEnums* New() const final {
    return CreateMaybeMessage<ASTExpressionSubqueryEnums>(NULL);
  }

  ASTExpressionSubqueryEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTExpressionSubqueryEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTExpressionSubqueryEnums& from);
  void MergeFrom(const ASTExpressionSubqueryEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTExpressionSubqueryEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTExpressionSubqueryEnums_Modifier Modifier;
  static const Modifier NONE =
    ASTExpressionSubqueryEnums_Modifier_NONE;
  static const Modifier ARRAY =
    ASTExpressionSubqueryEnums_Modifier_ARRAY;
  static const Modifier EXISTS =
    ASTExpressionSubqueryEnums_Modifier_EXISTS;
  static inline bool Modifier_IsValid(int value) {
    return ASTExpressionSubqueryEnums_Modifier_IsValid(value);
  }
  static const Modifier Modifier_MIN =
    ASTExpressionSubqueryEnums_Modifier_Modifier_MIN;
  static const Modifier Modifier_MAX =
    ASTExpressionSubqueryEnums_Modifier_Modifier_MAX;
  static const int Modifier_ARRAYSIZE =
    ASTExpressionSubqueryEnums_Modifier_Modifier_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Modifier_descriptor() {
    return ASTExpressionSubqueryEnums_Modifier_descriptor();
  }
  static inline const ::std::string& Modifier_Name(Modifier value) {
    return ASTExpressionSubqueryEnums_Modifier_Name(value);
  }
  static inline bool Modifier_Parse(const ::std::string& name,
      Modifier* value) {
    return ASTExpressionSubqueryEnums_Modifier_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTExpressionSubqueryEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTHavingModifierEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTHavingModifierEnums) */ {
 public:
  ASTHavingModifierEnums();
  virtual ~ASTHavingModifierEnums();

  ASTHavingModifierEnums(const ASTHavingModifierEnums& from);

  inline ASTHavingModifierEnums& operator=(const ASTHavingModifierEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTHavingModifierEnums(ASTHavingModifierEnums&& from) noexcept
    : ASTHavingModifierEnums() {
    *this = ::std::move(from);
  }

  inline ASTHavingModifierEnums& operator=(ASTHavingModifierEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTHavingModifierEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTHavingModifierEnums* internal_default_instance() {
    return reinterpret_cast<const ASTHavingModifierEnums*>(
               &_ASTHavingModifierEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ASTHavingModifierEnums* other);
  friend void swap(ASTHavingModifierEnums& a, ASTHavingModifierEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTHavingModifierEnums* New() const final {
    return CreateMaybeMessage<ASTHavingModifierEnums>(NULL);
  }

  ASTHavingModifierEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTHavingModifierEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTHavingModifierEnums& from);
  void MergeFrom(const ASTHavingModifierEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTHavingModifierEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTHavingModifierEnums_ModifierKind ModifierKind;
  static const ModifierKind NOT_SET =
    ASTHavingModifierEnums_ModifierKind_NOT_SET;
  static const ModifierKind MIN =
    ASTHavingModifierEnums_ModifierKind_MIN;
  static const ModifierKind MAX =
    ASTHavingModifierEnums_ModifierKind_MAX;
  static inline bool ModifierKind_IsValid(int value) {
    return ASTHavingModifierEnums_ModifierKind_IsValid(value);
  }
  static const ModifierKind ModifierKind_MIN =
    ASTHavingModifierEnums_ModifierKind_ModifierKind_MIN;
  static const ModifierKind ModifierKind_MAX =
    ASTHavingModifierEnums_ModifierKind_ModifierKind_MAX;
  static const int ModifierKind_ARRAYSIZE =
    ASTHavingModifierEnums_ModifierKind_ModifierKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ModifierKind_descriptor() {
    return ASTHavingModifierEnums_ModifierKind_descriptor();
  }
  static inline const ::std::string& ModifierKind_Name(ModifierKind value) {
    return ASTHavingModifierEnums_ModifierKind_Name(value);
  }
  static inline bool ModifierKind_Parse(const ::std::string& name,
      ModifierKind* value) {
    return ASTHavingModifierEnums_ModifierKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTHavingModifierEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTSetOperationEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTSetOperationEnums) */ {
 public:
  ASTSetOperationEnums();
  virtual ~ASTSetOperationEnums();

  ASTSetOperationEnums(const ASTSetOperationEnums& from);

  inline ASTSetOperationEnums& operator=(const ASTSetOperationEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTSetOperationEnums(ASTSetOperationEnums&& from) noexcept
    : ASTSetOperationEnums() {
    *this = ::std::move(from);
  }

  inline ASTSetOperationEnums& operator=(ASTSetOperationEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTSetOperationEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTSetOperationEnums* internal_default_instance() {
    return reinterpret_cast<const ASTSetOperationEnums*>(
               &_ASTSetOperationEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ASTSetOperationEnums* other);
  friend void swap(ASTSetOperationEnums& a, ASTSetOperationEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTSetOperationEnums* New() const final {
    return CreateMaybeMessage<ASTSetOperationEnums>(NULL);
  }

  ASTSetOperationEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTSetOperationEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTSetOperationEnums& from);
  void MergeFrom(const ASTSetOperationEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTSetOperationEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTSetOperationEnums_OperationType OperationType;
  static const OperationType NOT_SET =
    ASTSetOperationEnums_OperationType_NOT_SET;
  static const OperationType UNION =
    ASTSetOperationEnums_OperationType_UNION;
  static const OperationType EXCEPT =
    ASTSetOperationEnums_OperationType_EXCEPT;
  static const OperationType INTERSECT =
    ASTSetOperationEnums_OperationType_INTERSECT;
  static inline bool OperationType_IsValid(int value) {
    return ASTSetOperationEnums_OperationType_IsValid(value);
  }
  static const OperationType OperationType_MIN =
    ASTSetOperationEnums_OperationType_OperationType_MIN;
  static const OperationType OperationType_MAX =
    ASTSetOperationEnums_OperationType_OperationType_MAX;
  static const int OperationType_ARRAYSIZE =
    ASTSetOperationEnums_OperationType_OperationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OperationType_descriptor() {
    return ASTSetOperationEnums_OperationType_descriptor();
  }
  static inline const ::std::string& OperationType_Name(OperationType value) {
    return ASTSetOperationEnums_OperationType_Name(value);
  }
  static inline bool OperationType_Parse(const ::std::string& name,
      OperationType* value) {
    return ASTSetOperationEnums_OperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTSetOperationEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTUnaryExpressionEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTUnaryExpressionEnums) */ {
 public:
  ASTUnaryExpressionEnums();
  virtual ~ASTUnaryExpressionEnums();

  ASTUnaryExpressionEnums(const ASTUnaryExpressionEnums& from);

  inline ASTUnaryExpressionEnums& operator=(const ASTUnaryExpressionEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTUnaryExpressionEnums(ASTUnaryExpressionEnums&& from) noexcept
    : ASTUnaryExpressionEnums() {
    *this = ::std::move(from);
  }

  inline ASTUnaryExpressionEnums& operator=(ASTUnaryExpressionEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTUnaryExpressionEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTUnaryExpressionEnums* internal_default_instance() {
    return reinterpret_cast<const ASTUnaryExpressionEnums*>(
               &_ASTUnaryExpressionEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ASTUnaryExpressionEnums* other);
  friend void swap(ASTUnaryExpressionEnums& a, ASTUnaryExpressionEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTUnaryExpressionEnums* New() const final {
    return CreateMaybeMessage<ASTUnaryExpressionEnums>(NULL);
  }

  ASTUnaryExpressionEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTUnaryExpressionEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTUnaryExpressionEnums& from);
  void MergeFrom(const ASTUnaryExpressionEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTUnaryExpressionEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTUnaryExpressionEnums_Op Op;
  static const Op NOT_SET =
    ASTUnaryExpressionEnums_Op_NOT_SET;
  static const Op NOT =
    ASTUnaryExpressionEnums_Op_NOT;
  static const Op BITWISE_NOT =
    ASTUnaryExpressionEnums_Op_BITWISE_NOT;
  static const Op MINUS =
    ASTUnaryExpressionEnums_Op_MINUS;
  static const Op PLUS =
    ASTUnaryExpressionEnums_Op_PLUS;
  static const Op IS_UNKNOWN =
    ASTUnaryExpressionEnums_Op_IS_UNKNOWN;
  static const Op IS_NOT_UNKNOWN =
    ASTUnaryExpressionEnums_Op_IS_NOT_UNKNOWN;
  static inline bool Op_IsValid(int value) {
    return ASTUnaryExpressionEnums_Op_IsValid(value);
  }
  static const Op Op_MIN =
    ASTUnaryExpressionEnums_Op_Op_MIN;
  static const Op Op_MAX =
    ASTUnaryExpressionEnums_Op_Op_MAX;
  static const int Op_ARRAYSIZE =
    ASTUnaryExpressionEnums_Op_Op_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Op_descriptor() {
    return ASTUnaryExpressionEnums_Op_descriptor();
  }
  static inline const ::std::string& Op_Name(Op value) {
    return ASTUnaryExpressionEnums_Op_Name(value);
  }
  static inline bool Op_Parse(const ::std::string& name,
      Op* value) {
    return ASTUnaryExpressionEnums_Op_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTUnaryExpressionEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTWindowFrameEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTWindowFrameEnums) */ {
 public:
  ASTWindowFrameEnums();
  virtual ~ASTWindowFrameEnums();

  ASTWindowFrameEnums(const ASTWindowFrameEnums& from);

  inline ASTWindowFrameEnums& operator=(const ASTWindowFrameEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTWindowFrameEnums(ASTWindowFrameEnums&& from) noexcept
    : ASTWindowFrameEnums() {
    *this = ::std::move(from);
  }

  inline ASTWindowFrameEnums& operator=(ASTWindowFrameEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTWindowFrameEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTWindowFrameEnums* internal_default_instance() {
    return reinterpret_cast<const ASTWindowFrameEnums*>(
               &_ASTWindowFrameEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ASTWindowFrameEnums* other);
  friend void swap(ASTWindowFrameEnums& a, ASTWindowFrameEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTWindowFrameEnums* New() const final {
    return CreateMaybeMessage<ASTWindowFrameEnums>(NULL);
  }

  ASTWindowFrameEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTWindowFrameEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTWindowFrameEnums& from);
  void MergeFrom(const ASTWindowFrameEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTWindowFrameEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTWindowFrameEnums_FrameUnit FrameUnit;
  static const FrameUnit ROWS =
    ASTWindowFrameEnums_FrameUnit_ROWS;
  static const FrameUnit RANGE =
    ASTWindowFrameEnums_FrameUnit_RANGE;
  static inline bool FrameUnit_IsValid(int value) {
    return ASTWindowFrameEnums_FrameUnit_IsValid(value);
  }
  static const FrameUnit FrameUnit_MIN =
    ASTWindowFrameEnums_FrameUnit_FrameUnit_MIN;
  static const FrameUnit FrameUnit_MAX =
    ASTWindowFrameEnums_FrameUnit_FrameUnit_MAX;
  static const int FrameUnit_ARRAYSIZE =
    ASTWindowFrameEnums_FrameUnit_FrameUnit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FrameUnit_descriptor() {
    return ASTWindowFrameEnums_FrameUnit_descriptor();
  }
  static inline const ::std::string& FrameUnit_Name(FrameUnit value) {
    return ASTWindowFrameEnums_FrameUnit_Name(value);
  }
  static inline bool FrameUnit_Parse(const ::std::string& name,
      FrameUnit* value) {
    return ASTWindowFrameEnums_FrameUnit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTWindowFrameEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTWindowFrameExprEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTWindowFrameExprEnums) */ {
 public:
  ASTWindowFrameExprEnums();
  virtual ~ASTWindowFrameExprEnums();

  ASTWindowFrameExprEnums(const ASTWindowFrameExprEnums& from);

  inline ASTWindowFrameExprEnums& operator=(const ASTWindowFrameExprEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTWindowFrameExprEnums(ASTWindowFrameExprEnums&& from) noexcept
    : ASTWindowFrameExprEnums() {
    *this = ::std::move(from);
  }

  inline ASTWindowFrameExprEnums& operator=(ASTWindowFrameExprEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTWindowFrameExprEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTWindowFrameExprEnums* internal_default_instance() {
    return reinterpret_cast<const ASTWindowFrameExprEnums*>(
               &_ASTWindowFrameExprEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ASTWindowFrameExprEnums* other);
  friend void swap(ASTWindowFrameExprEnums& a, ASTWindowFrameExprEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTWindowFrameExprEnums* New() const final {
    return CreateMaybeMessage<ASTWindowFrameExprEnums>(NULL);
  }

  ASTWindowFrameExprEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTWindowFrameExprEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTWindowFrameExprEnums& from);
  void MergeFrom(const ASTWindowFrameExprEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTWindowFrameExprEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTWindowFrameExprEnums_BoundaryType BoundaryType;
  static const BoundaryType UNBOUNDED_PRECEDING =
    ASTWindowFrameExprEnums_BoundaryType_UNBOUNDED_PRECEDING;
  static const BoundaryType OFFSET_PRECEDING =
    ASTWindowFrameExprEnums_BoundaryType_OFFSET_PRECEDING;
  static const BoundaryType CURRENT_ROW =
    ASTWindowFrameExprEnums_BoundaryType_CURRENT_ROW;
  static const BoundaryType OFFSET_FOLLOWING =
    ASTWindowFrameExprEnums_BoundaryType_OFFSET_FOLLOWING;
  static const BoundaryType UNBOUNDED_FOLLOWING =
    ASTWindowFrameExprEnums_BoundaryType_UNBOUNDED_FOLLOWING;
  static inline bool BoundaryType_IsValid(int value) {
    return ASTWindowFrameExprEnums_BoundaryType_IsValid(value);
  }
  static const BoundaryType BoundaryType_MIN =
    ASTWindowFrameExprEnums_BoundaryType_BoundaryType_MIN;
  static const BoundaryType BoundaryType_MAX =
    ASTWindowFrameExprEnums_BoundaryType_BoundaryType_MAX;
  static const int BoundaryType_ARRAYSIZE =
    ASTWindowFrameExprEnums_BoundaryType_BoundaryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BoundaryType_descriptor() {
    return ASTWindowFrameExprEnums_BoundaryType_descriptor();
  }
  static inline const ::std::string& BoundaryType_Name(BoundaryType value) {
    return ASTWindowFrameExprEnums_BoundaryType_Name(value);
  }
  static inline bool BoundaryType_Parse(const ::std::string& name,
      BoundaryType* value) {
    return ASTWindowFrameExprEnums_BoundaryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTWindowFrameExprEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTAnySomeAllOpEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTAnySomeAllOpEnums) */ {
 public:
  ASTAnySomeAllOpEnums();
  virtual ~ASTAnySomeAllOpEnums();

  ASTAnySomeAllOpEnums(const ASTAnySomeAllOpEnums& from);

  inline ASTAnySomeAllOpEnums& operator=(const ASTAnySomeAllOpEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTAnySomeAllOpEnums(ASTAnySomeAllOpEnums&& from) noexcept
    : ASTAnySomeAllOpEnums() {
    *this = ::std::move(from);
  }

  inline ASTAnySomeAllOpEnums& operator=(ASTAnySomeAllOpEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTAnySomeAllOpEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTAnySomeAllOpEnums* internal_default_instance() {
    return reinterpret_cast<const ASTAnySomeAllOpEnums*>(
               &_ASTAnySomeAllOpEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ASTAnySomeAllOpEnums* other);
  friend void swap(ASTAnySomeAllOpEnums& a, ASTAnySomeAllOpEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTAnySomeAllOpEnums* New() const final {
    return CreateMaybeMessage<ASTAnySomeAllOpEnums>(NULL);
  }

  ASTAnySomeAllOpEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTAnySomeAllOpEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTAnySomeAllOpEnums& from);
  void MergeFrom(const ASTAnySomeAllOpEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTAnySomeAllOpEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTAnySomeAllOpEnums_Op Op;
  static const Op kUninitialized =
    ASTAnySomeAllOpEnums_Op_kUninitialized;
  static const Op kAny =
    ASTAnySomeAllOpEnums_Op_kAny;
  static const Op kSome =
    ASTAnySomeAllOpEnums_Op_kSome;
  static const Op kAll =
    ASTAnySomeAllOpEnums_Op_kAll;
  static inline bool Op_IsValid(int value) {
    return ASTAnySomeAllOpEnums_Op_IsValid(value);
  }
  static const Op Op_MIN =
    ASTAnySomeAllOpEnums_Op_Op_MIN;
  static const Op Op_MAX =
    ASTAnySomeAllOpEnums_Op_Op_MAX;
  static const int Op_ARRAYSIZE =
    ASTAnySomeAllOpEnums_Op_Op_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Op_descriptor() {
    return ASTAnySomeAllOpEnums_Op_descriptor();
  }
  static inline const ::std::string& Op_Name(Op value) {
    return ASTAnySomeAllOpEnums_Op_Name(value);
  }
  static inline bool Op_Parse(const ::std::string& name,
      Op* value) {
    return ASTAnySomeAllOpEnums_Op_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTAnySomeAllOpEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTTransactionReadWriteModeEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTTransactionReadWriteModeEnums) */ {
 public:
  ASTTransactionReadWriteModeEnums();
  virtual ~ASTTransactionReadWriteModeEnums();

  ASTTransactionReadWriteModeEnums(const ASTTransactionReadWriteModeEnums& from);

  inline ASTTransactionReadWriteModeEnums& operator=(const ASTTransactionReadWriteModeEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTTransactionReadWriteModeEnums(ASTTransactionReadWriteModeEnums&& from) noexcept
    : ASTTransactionReadWriteModeEnums() {
    *this = ::std::move(from);
  }

  inline ASTTransactionReadWriteModeEnums& operator=(ASTTransactionReadWriteModeEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTTransactionReadWriteModeEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTTransactionReadWriteModeEnums* internal_default_instance() {
    return reinterpret_cast<const ASTTransactionReadWriteModeEnums*>(
               &_ASTTransactionReadWriteModeEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ASTTransactionReadWriteModeEnums* other);
  friend void swap(ASTTransactionReadWriteModeEnums& a, ASTTransactionReadWriteModeEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTTransactionReadWriteModeEnums* New() const final {
    return CreateMaybeMessage<ASTTransactionReadWriteModeEnums>(NULL);
  }

  ASTTransactionReadWriteModeEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTTransactionReadWriteModeEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTTransactionReadWriteModeEnums& from);
  void MergeFrom(const ASTTransactionReadWriteModeEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTTransactionReadWriteModeEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTTransactionReadWriteModeEnums_Mode Mode;
  static const Mode INVALID =
    ASTTransactionReadWriteModeEnums_Mode_INVALID;
  static const Mode READ_ONLY =
    ASTTransactionReadWriteModeEnums_Mode_READ_ONLY;
  static const Mode READ_WRITE =
    ASTTransactionReadWriteModeEnums_Mode_READ_WRITE;
  static inline bool Mode_IsValid(int value) {
    return ASTTransactionReadWriteModeEnums_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    ASTTransactionReadWriteModeEnums_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    ASTTransactionReadWriteModeEnums_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    ASTTransactionReadWriteModeEnums_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return ASTTransactionReadWriteModeEnums_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return ASTTransactionReadWriteModeEnums_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return ASTTransactionReadWriteModeEnums_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTTransactionReadWriteModeEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTImportStatementEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTImportStatementEnums) */ {
 public:
  ASTImportStatementEnums();
  virtual ~ASTImportStatementEnums();

  ASTImportStatementEnums(const ASTImportStatementEnums& from);

  inline ASTImportStatementEnums& operator=(const ASTImportStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTImportStatementEnums(ASTImportStatementEnums&& from) noexcept
    : ASTImportStatementEnums() {
    *this = ::std::move(from);
  }

  inline ASTImportStatementEnums& operator=(ASTImportStatementEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTImportStatementEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTImportStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTImportStatementEnums*>(
               &_ASTImportStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ASTImportStatementEnums* other);
  friend void swap(ASTImportStatementEnums& a, ASTImportStatementEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTImportStatementEnums* New() const final {
    return CreateMaybeMessage<ASTImportStatementEnums>(NULL);
  }

  ASTImportStatementEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTImportStatementEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTImportStatementEnums& from);
  void MergeFrom(const ASTImportStatementEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTImportStatementEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTImportStatementEnums_ImportKind ImportKind;
  static const ImportKind MODULE =
    ASTImportStatementEnums_ImportKind_MODULE;
  static const ImportKind PROTO =
    ASTImportStatementEnums_ImportKind_PROTO;
  static inline bool ImportKind_IsValid(int value) {
    return ASTImportStatementEnums_ImportKind_IsValid(value);
  }
  static const ImportKind ImportKind_MIN =
    ASTImportStatementEnums_ImportKind_ImportKind_MIN;
  static const ImportKind ImportKind_MAX =
    ASTImportStatementEnums_ImportKind_ImportKind_MAX;
  static const int ImportKind_ARRAYSIZE =
    ASTImportStatementEnums_ImportKind_ImportKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ImportKind_descriptor() {
    return ASTImportStatementEnums_ImportKind_descriptor();
  }
  static inline const ::std::string& ImportKind_Name(ImportKind value) {
    return ASTImportStatementEnums_ImportKind_Name(value);
  }
  static inline bool ImportKind_Parse(const ::std::string& name,
      ImportKind* value) {
    return ASTImportStatementEnums_ImportKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTImportStatementEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTUnpivotClauseEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTUnpivotClauseEnums) */ {
 public:
  ASTUnpivotClauseEnums();
  virtual ~ASTUnpivotClauseEnums();

  ASTUnpivotClauseEnums(const ASTUnpivotClauseEnums& from);

  inline ASTUnpivotClauseEnums& operator=(const ASTUnpivotClauseEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTUnpivotClauseEnums(ASTUnpivotClauseEnums&& from) noexcept
    : ASTUnpivotClauseEnums() {
    *this = ::std::move(from);
  }

  inline ASTUnpivotClauseEnums& operator=(ASTUnpivotClauseEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTUnpivotClauseEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTUnpivotClauseEnums* internal_default_instance() {
    return reinterpret_cast<const ASTUnpivotClauseEnums*>(
               &_ASTUnpivotClauseEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ASTUnpivotClauseEnums* other);
  friend void swap(ASTUnpivotClauseEnums& a, ASTUnpivotClauseEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTUnpivotClauseEnums* New() const final {
    return CreateMaybeMessage<ASTUnpivotClauseEnums>(NULL);
  }

  ASTUnpivotClauseEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTUnpivotClauseEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTUnpivotClauseEnums& from);
  void MergeFrom(const ASTUnpivotClauseEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTUnpivotClauseEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTUnpivotClauseEnums_NullFilter NullFilter;
  static const NullFilter kUnspecified =
    ASTUnpivotClauseEnums_NullFilter_kUnspecified;
  static const NullFilter kInclude =
    ASTUnpivotClauseEnums_NullFilter_kInclude;
  static const NullFilter kExclude =
    ASTUnpivotClauseEnums_NullFilter_kExclude;
  static inline bool NullFilter_IsValid(int value) {
    return ASTUnpivotClauseEnums_NullFilter_IsValid(value);
  }
  static const NullFilter NullFilter_MIN =
    ASTUnpivotClauseEnums_NullFilter_NullFilter_MIN;
  static const NullFilter NullFilter_MAX =
    ASTUnpivotClauseEnums_NullFilter_NullFilter_MAX;
  static const int NullFilter_ARRAYSIZE =
    ASTUnpivotClauseEnums_NullFilter_NullFilter_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NullFilter_descriptor() {
    return ASTUnpivotClauseEnums_NullFilter_descriptor();
  }
  static inline const ::std::string& NullFilter_Name(NullFilter value) {
    return ASTUnpivotClauseEnums_NullFilter_Name(value);
  }
  static inline bool NullFilter_Parse(const ::std::string& name,
      NullFilter* value) {
    return ASTUnpivotClauseEnums_NullFilter_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTUnpivotClauseEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTCreateStatementEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTCreateStatementEnums) */ {
 public:
  ASTCreateStatementEnums();
  virtual ~ASTCreateStatementEnums();

  ASTCreateStatementEnums(const ASTCreateStatementEnums& from);

  inline ASTCreateStatementEnums& operator=(const ASTCreateStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTCreateStatementEnums(ASTCreateStatementEnums&& from) noexcept
    : ASTCreateStatementEnums() {
    *this = ::std::move(from);
  }

  inline ASTCreateStatementEnums& operator=(ASTCreateStatementEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTCreateStatementEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTCreateStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTCreateStatementEnums*>(
               &_ASTCreateStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ASTCreateStatementEnums* other);
  friend void swap(ASTCreateStatementEnums& a, ASTCreateStatementEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTCreateStatementEnums* New() const final {
    return CreateMaybeMessage<ASTCreateStatementEnums>(NULL);
  }

  ASTCreateStatementEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTCreateStatementEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTCreateStatementEnums& from);
  void MergeFrom(const ASTCreateStatementEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTCreateStatementEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTCreateStatementEnums_Scope Scope;
  static const Scope DEFAULT_SCOPE =
    ASTCreateStatementEnums_Scope_DEFAULT_SCOPE;
  static const Scope PRIVATE =
    ASTCreateStatementEnums_Scope_PRIVATE;
  static const Scope PUBLIC =
    ASTCreateStatementEnums_Scope_PUBLIC;
  static const Scope TEMPORARY =
    ASTCreateStatementEnums_Scope_TEMPORARY;
  static inline bool Scope_IsValid(int value) {
    return ASTCreateStatementEnums_Scope_IsValid(value);
  }
  static const Scope Scope_MIN =
    ASTCreateStatementEnums_Scope_Scope_MIN;
  static const Scope Scope_MAX =
    ASTCreateStatementEnums_Scope_Scope_MAX;
  static const int Scope_ARRAYSIZE =
    ASTCreateStatementEnums_Scope_Scope_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Scope_descriptor() {
    return ASTCreateStatementEnums_Scope_descriptor();
  }
  static inline const ::std::string& Scope_Name(Scope value) {
    return ASTCreateStatementEnums_Scope_Name(value);
  }
  static inline bool Scope_Parse(const ::std::string& name,
      Scope* value) {
    return ASTCreateStatementEnums_Scope_Parse(name, value);
  }

  typedef ASTCreateStatementEnums_SqlSecurity SqlSecurity;
  static const SqlSecurity SQL_SECURITY_UNSPECIFIED =
    ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_UNSPECIFIED;
  static const SqlSecurity SQL_SECURITY_DEFINER =
    ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_DEFINER;
  static const SqlSecurity SQL_SECURITY_INVOKER =
    ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_INVOKER;
  static inline bool SqlSecurity_IsValid(int value) {
    return ASTCreateStatementEnums_SqlSecurity_IsValid(value);
  }
  static const SqlSecurity SqlSecurity_MIN =
    ASTCreateStatementEnums_SqlSecurity_SqlSecurity_MIN;
  static const SqlSecurity SqlSecurity_MAX =
    ASTCreateStatementEnums_SqlSecurity_SqlSecurity_MAX;
  static const int SqlSecurity_ARRAYSIZE =
    ASTCreateStatementEnums_SqlSecurity_SqlSecurity_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SqlSecurity_descriptor() {
    return ASTCreateStatementEnums_SqlSecurity_descriptor();
  }
  static inline const ::std::string& SqlSecurity_Name(SqlSecurity value) {
    return ASTCreateStatementEnums_SqlSecurity_Name(value);
  }
  static inline bool SqlSecurity_Parse(const ::std::string& name,
      SqlSecurity* value) {
    return ASTCreateStatementEnums_SqlSecurity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTCreateStatementEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTFunctionParameterEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTFunctionParameterEnums) */ {
 public:
  ASTFunctionParameterEnums();
  virtual ~ASTFunctionParameterEnums();

  ASTFunctionParameterEnums(const ASTFunctionParameterEnums& from);

  inline ASTFunctionParameterEnums& operator=(const ASTFunctionParameterEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTFunctionParameterEnums(ASTFunctionParameterEnums&& from) noexcept
    : ASTFunctionParameterEnums() {
    *this = ::std::move(from);
  }

  inline ASTFunctionParameterEnums& operator=(ASTFunctionParameterEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTFunctionParameterEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTFunctionParameterEnums* internal_default_instance() {
    return reinterpret_cast<const ASTFunctionParameterEnums*>(
               &_ASTFunctionParameterEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ASTFunctionParameterEnums* other);
  friend void swap(ASTFunctionParameterEnums& a, ASTFunctionParameterEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTFunctionParameterEnums* New() const final {
    return CreateMaybeMessage<ASTFunctionParameterEnums>(NULL);
  }

  ASTFunctionParameterEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTFunctionParameterEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTFunctionParameterEnums& from);
  void MergeFrom(const ASTFunctionParameterEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTFunctionParameterEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTFunctionParameterEnums_ProcedureParameterMode ProcedureParameterMode;
  static const ProcedureParameterMode NOT_SET =
    ASTFunctionParameterEnums_ProcedureParameterMode_NOT_SET;
  static const ProcedureParameterMode IN =
    ASTFunctionParameterEnums_ProcedureParameterMode_IN;
  static const ProcedureParameterMode OUT =
    ASTFunctionParameterEnums_ProcedureParameterMode_OUT;
  static const ProcedureParameterMode INOUT =
    ASTFunctionParameterEnums_ProcedureParameterMode_INOUT;
  static inline bool ProcedureParameterMode_IsValid(int value) {
    return ASTFunctionParameterEnums_ProcedureParameterMode_IsValid(value);
  }
  static const ProcedureParameterMode ProcedureParameterMode_MIN =
    ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_MIN;
  static const ProcedureParameterMode ProcedureParameterMode_MAX =
    ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_MAX;
  static const int ProcedureParameterMode_ARRAYSIZE =
    ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProcedureParameterMode_descriptor() {
    return ASTFunctionParameterEnums_ProcedureParameterMode_descriptor();
  }
  static inline const ::std::string& ProcedureParameterMode_Name(ProcedureParameterMode value) {
    return ASTFunctionParameterEnums_ProcedureParameterMode_Name(value);
  }
  static inline bool ProcedureParameterMode_Parse(const ::std::string& name,
      ProcedureParameterMode* value) {
    return ASTFunctionParameterEnums_ProcedureParameterMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTFunctionParameterEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTTemplatedParameterTypeEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTTemplatedParameterTypeEnums) */ {
 public:
  ASTTemplatedParameterTypeEnums();
  virtual ~ASTTemplatedParameterTypeEnums();

  ASTTemplatedParameterTypeEnums(const ASTTemplatedParameterTypeEnums& from);

  inline ASTTemplatedParameterTypeEnums& operator=(const ASTTemplatedParameterTypeEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTTemplatedParameterTypeEnums(ASTTemplatedParameterTypeEnums&& from) noexcept
    : ASTTemplatedParameterTypeEnums() {
    *this = ::std::move(from);
  }

  inline ASTTemplatedParameterTypeEnums& operator=(ASTTemplatedParameterTypeEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTTemplatedParameterTypeEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTTemplatedParameterTypeEnums* internal_default_instance() {
    return reinterpret_cast<const ASTTemplatedParameterTypeEnums*>(
               &_ASTTemplatedParameterTypeEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ASTTemplatedParameterTypeEnums* other);
  friend void swap(ASTTemplatedParameterTypeEnums& a, ASTTemplatedParameterTypeEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTTemplatedParameterTypeEnums* New() const final {
    return CreateMaybeMessage<ASTTemplatedParameterTypeEnums>(NULL);
  }

  ASTTemplatedParameterTypeEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTTemplatedParameterTypeEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTTemplatedParameterTypeEnums& from);
  void MergeFrom(const ASTTemplatedParameterTypeEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTTemplatedParameterTypeEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTTemplatedParameterTypeEnums_TemplatedTypeKind TemplatedTypeKind;
  static const TemplatedTypeKind UNINITIALIZED =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_UNINITIALIZED;
  static const TemplatedTypeKind ANY_TYPE =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_TYPE;
  static const TemplatedTypeKind ANY_PROTO =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_PROTO;
  static const TemplatedTypeKind ANY_ENUM =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_ENUM;
  static const TemplatedTypeKind ANY_STRUCT =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_STRUCT;
  static const TemplatedTypeKind ANY_ARRAY =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_ARRAY;
  static const TemplatedTypeKind ANY_TABLE =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_TABLE;
  static inline bool TemplatedTypeKind_IsValid(int value) {
    return ASTTemplatedParameterTypeEnums_TemplatedTypeKind_IsValid(value);
  }
  static const TemplatedTypeKind TemplatedTypeKind_MIN =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_MIN;
  static const TemplatedTypeKind TemplatedTypeKind_MAX =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_MAX;
  static const int TemplatedTypeKind_ARRAYSIZE =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TemplatedTypeKind_descriptor() {
    return ASTTemplatedParameterTypeEnums_TemplatedTypeKind_descriptor();
  }
  static inline const ::std::string& TemplatedTypeKind_Name(TemplatedTypeKind value) {
    return ASTTemplatedParameterTypeEnums_TemplatedTypeKind_Name(value);
  }
  static inline bool TemplatedTypeKind_Parse(const ::std::string& name,
      TemplatedTypeKind* value) {
    return ASTTemplatedParameterTypeEnums_TemplatedTypeKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTTemplatedParameterTypeEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTGeneratedColumnInfoEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTGeneratedColumnInfoEnums) */ {
 public:
  ASTGeneratedColumnInfoEnums();
  virtual ~ASTGeneratedColumnInfoEnums();

  ASTGeneratedColumnInfoEnums(const ASTGeneratedColumnInfoEnums& from);

  inline ASTGeneratedColumnInfoEnums& operator=(const ASTGeneratedColumnInfoEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTGeneratedColumnInfoEnums(ASTGeneratedColumnInfoEnums&& from) noexcept
    : ASTGeneratedColumnInfoEnums() {
    *this = ::std::move(from);
  }

  inline ASTGeneratedColumnInfoEnums& operator=(ASTGeneratedColumnInfoEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTGeneratedColumnInfoEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTGeneratedColumnInfoEnums* internal_default_instance() {
    return reinterpret_cast<const ASTGeneratedColumnInfoEnums*>(
               &_ASTGeneratedColumnInfoEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(ASTGeneratedColumnInfoEnums* other);
  friend void swap(ASTGeneratedColumnInfoEnums& a, ASTGeneratedColumnInfoEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTGeneratedColumnInfoEnums* New() const final {
    return CreateMaybeMessage<ASTGeneratedColumnInfoEnums>(NULL);
  }

  ASTGeneratedColumnInfoEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTGeneratedColumnInfoEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTGeneratedColumnInfoEnums& from);
  void MergeFrom(const ASTGeneratedColumnInfoEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTGeneratedColumnInfoEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTGeneratedColumnInfoEnums_StoredMode StoredMode;
  static const StoredMode NON_STORED =
    ASTGeneratedColumnInfoEnums_StoredMode_NON_STORED;
  static const StoredMode STORED =
    ASTGeneratedColumnInfoEnums_StoredMode_STORED;
  static const StoredMode STORED_VOLATILE =
    ASTGeneratedColumnInfoEnums_StoredMode_STORED_VOLATILE;
  static inline bool StoredMode_IsValid(int value) {
    return ASTGeneratedColumnInfoEnums_StoredMode_IsValid(value);
  }
  static const StoredMode StoredMode_MIN =
    ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_MIN;
  static const StoredMode StoredMode_MAX =
    ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_MAX;
  static const int StoredMode_ARRAYSIZE =
    ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StoredMode_descriptor() {
    return ASTGeneratedColumnInfoEnums_StoredMode_descriptor();
  }
  static inline const ::std::string& StoredMode_Name(StoredMode value) {
    return ASTGeneratedColumnInfoEnums_StoredMode_Name(value);
  }
  static inline bool StoredMode_Parse(const ::std::string& name,
      StoredMode* value) {
    return ASTGeneratedColumnInfoEnums_StoredMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTGeneratedColumnInfoEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTColumnPositionEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTColumnPositionEnums) */ {
 public:
  ASTColumnPositionEnums();
  virtual ~ASTColumnPositionEnums();

  ASTColumnPositionEnums(const ASTColumnPositionEnums& from);

  inline ASTColumnPositionEnums& operator=(const ASTColumnPositionEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTColumnPositionEnums(ASTColumnPositionEnums&& from) noexcept
    : ASTColumnPositionEnums() {
    *this = ::std::move(from);
  }

  inline ASTColumnPositionEnums& operator=(ASTColumnPositionEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTColumnPositionEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTColumnPositionEnums* internal_default_instance() {
    return reinterpret_cast<const ASTColumnPositionEnums*>(
               &_ASTColumnPositionEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ASTColumnPositionEnums* other);
  friend void swap(ASTColumnPositionEnums& a, ASTColumnPositionEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTColumnPositionEnums* New() const final {
    return CreateMaybeMessage<ASTColumnPositionEnums>(NULL);
  }

  ASTColumnPositionEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTColumnPositionEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTColumnPositionEnums& from);
  void MergeFrom(const ASTColumnPositionEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTColumnPositionEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTColumnPositionEnums_RelativePositionType RelativePositionType;
  static const RelativePositionType PRECEDING =
    ASTColumnPositionEnums_RelativePositionType_PRECEDING;
  static const RelativePositionType FOLLOWING =
    ASTColumnPositionEnums_RelativePositionType_FOLLOWING;
  static inline bool RelativePositionType_IsValid(int value) {
    return ASTColumnPositionEnums_RelativePositionType_IsValid(value);
  }
  static const RelativePositionType RelativePositionType_MIN =
    ASTColumnPositionEnums_RelativePositionType_RelativePositionType_MIN;
  static const RelativePositionType RelativePositionType_MAX =
    ASTColumnPositionEnums_RelativePositionType_RelativePositionType_MAX;
  static const int RelativePositionType_ARRAYSIZE =
    ASTColumnPositionEnums_RelativePositionType_RelativePositionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RelativePositionType_descriptor() {
    return ASTColumnPositionEnums_RelativePositionType_descriptor();
  }
  static inline const ::std::string& RelativePositionType_Name(RelativePositionType value) {
    return ASTColumnPositionEnums_RelativePositionType_Name(value);
  }
  static inline bool RelativePositionType_Parse(const ::std::string& name,
      RelativePositionType* value) {
    return ASTColumnPositionEnums_RelativePositionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTColumnPositionEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTInsertStatementEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTInsertStatementEnums) */ {
 public:
  ASTInsertStatementEnums();
  virtual ~ASTInsertStatementEnums();

  ASTInsertStatementEnums(const ASTInsertStatementEnums& from);

  inline ASTInsertStatementEnums& operator=(const ASTInsertStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTInsertStatementEnums(ASTInsertStatementEnums&& from) noexcept
    : ASTInsertStatementEnums() {
    *this = ::std::move(from);
  }

  inline ASTInsertStatementEnums& operator=(ASTInsertStatementEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTInsertStatementEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTInsertStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTInsertStatementEnums*>(
               &_ASTInsertStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(ASTInsertStatementEnums* other);
  friend void swap(ASTInsertStatementEnums& a, ASTInsertStatementEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTInsertStatementEnums* New() const final {
    return CreateMaybeMessage<ASTInsertStatementEnums>(NULL);
  }

  ASTInsertStatementEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTInsertStatementEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTInsertStatementEnums& from);
  void MergeFrom(const ASTInsertStatementEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTInsertStatementEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTInsertStatementEnums_InsertMode InsertMode;
  static const InsertMode DEFAULT_MODE =
    ASTInsertStatementEnums_InsertMode_DEFAULT_MODE;
  static const InsertMode REPLACE =
    ASTInsertStatementEnums_InsertMode_REPLACE;
  static const InsertMode UPDATE =
    ASTInsertStatementEnums_InsertMode_UPDATE;
  static const InsertMode IGNORE =
    ASTInsertStatementEnums_InsertMode_IGNORE;
  static inline bool InsertMode_IsValid(int value) {
    return ASTInsertStatementEnums_InsertMode_IsValid(value);
  }
  static const InsertMode InsertMode_MIN =
    ASTInsertStatementEnums_InsertMode_InsertMode_MIN;
  static const InsertMode InsertMode_MAX =
    ASTInsertStatementEnums_InsertMode_InsertMode_MAX;
  static const int InsertMode_ARRAYSIZE =
    ASTInsertStatementEnums_InsertMode_InsertMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InsertMode_descriptor() {
    return ASTInsertStatementEnums_InsertMode_descriptor();
  }
  static inline const ::std::string& InsertMode_Name(InsertMode value) {
    return ASTInsertStatementEnums_InsertMode_Name(value);
  }
  static inline bool InsertMode_Parse(const ::std::string& name,
      InsertMode* value) {
    return ASTInsertStatementEnums_InsertMode_Parse(name, value);
  }

  typedef ASTInsertStatementEnums_ParseProgress ParseProgress;
  static const ParseProgress kInitial =
    ASTInsertStatementEnums_ParseProgress_kInitial;
  static const ParseProgress kSeenOrIgnoreReplaceUpdate =
    ASTInsertStatementEnums_ParseProgress_kSeenOrIgnoreReplaceUpdate;
  static const ParseProgress kSeenTargetPath =
    ASTInsertStatementEnums_ParseProgress_kSeenTargetPath;
  static const ParseProgress kSeenColumnList =
    ASTInsertStatementEnums_ParseProgress_kSeenColumnList;
  static const ParseProgress kSeenValuesList =
    ASTInsertStatementEnums_ParseProgress_kSeenValuesList;
  static inline bool ParseProgress_IsValid(int value) {
    return ASTInsertStatementEnums_ParseProgress_IsValid(value);
  }
  static const ParseProgress ParseProgress_MIN =
    ASTInsertStatementEnums_ParseProgress_ParseProgress_MIN;
  static const ParseProgress ParseProgress_MAX =
    ASTInsertStatementEnums_ParseProgress_ParseProgress_MAX;
  static const int ParseProgress_ARRAYSIZE =
    ASTInsertStatementEnums_ParseProgress_ParseProgress_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ParseProgress_descriptor() {
    return ASTInsertStatementEnums_ParseProgress_descriptor();
  }
  static inline const ::std::string& ParseProgress_Name(ParseProgress value) {
    return ASTInsertStatementEnums_ParseProgress_Name(value);
  }
  static inline bool ParseProgress_Parse(const ::std::string& name,
      ParseProgress* value) {
    return ASTInsertStatementEnums_ParseProgress_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTInsertStatementEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTMergeActionEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTMergeActionEnums) */ {
 public:
  ASTMergeActionEnums();
  virtual ~ASTMergeActionEnums();

  ASTMergeActionEnums(const ASTMergeActionEnums& from);

  inline ASTMergeActionEnums& operator=(const ASTMergeActionEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTMergeActionEnums(ASTMergeActionEnums&& from) noexcept
    : ASTMergeActionEnums() {
    *this = ::std::move(from);
  }

  inline ASTMergeActionEnums& operator=(ASTMergeActionEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTMergeActionEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTMergeActionEnums* internal_default_instance() {
    return reinterpret_cast<const ASTMergeActionEnums*>(
               &_ASTMergeActionEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ASTMergeActionEnums* other);
  friend void swap(ASTMergeActionEnums& a, ASTMergeActionEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTMergeActionEnums* New() const final {
    return CreateMaybeMessage<ASTMergeActionEnums>(NULL);
  }

  ASTMergeActionEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTMergeActionEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTMergeActionEnums& from);
  void MergeFrom(const ASTMergeActionEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTMergeActionEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTMergeActionEnums_ActionType ActionType;
  static const ActionType NOT_SET =
    ASTMergeActionEnums_ActionType_NOT_SET;
  static const ActionType INSERT =
    ASTMergeActionEnums_ActionType_INSERT;
  static const ActionType UPDATE =
    ASTMergeActionEnums_ActionType_UPDATE;
  static const ActionType DELETE =
    ASTMergeActionEnums_ActionType_DELETE;
  static inline bool ActionType_IsValid(int value) {
    return ASTMergeActionEnums_ActionType_IsValid(value);
  }
  static const ActionType ActionType_MIN =
    ASTMergeActionEnums_ActionType_ActionType_MIN;
  static const ActionType ActionType_MAX =
    ASTMergeActionEnums_ActionType_ActionType_MAX;
  static const int ActionType_ARRAYSIZE =
    ASTMergeActionEnums_ActionType_ActionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionType_descriptor() {
    return ASTMergeActionEnums_ActionType_descriptor();
  }
  static inline const ::std::string& ActionType_Name(ActionType value) {
    return ASTMergeActionEnums_ActionType_Name(value);
  }
  static inline bool ActionType_Parse(const ::std::string& name,
      ActionType* value) {
    return ASTMergeActionEnums_ActionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTMergeActionEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTMergeWhenClauseEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTMergeWhenClauseEnums) */ {
 public:
  ASTMergeWhenClauseEnums();
  virtual ~ASTMergeWhenClauseEnums();

  ASTMergeWhenClauseEnums(const ASTMergeWhenClauseEnums& from);

  inline ASTMergeWhenClauseEnums& operator=(const ASTMergeWhenClauseEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTMergeWhenClauseEnums(ASTMergeWhenClauseEnums&& from) noexcept
    : ASTMergeWhenClauseEnums() {
    *this = ::std::move(from);
  }

  inline ASTMergeWhenClauseEnums& operator=(ASTMergeWhenClauseEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTMergeWhenClauseEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTMergeWhenClauseEnums* internal_default_instance() {
    return reinterpret_cast<const ASTMergeWhenClauseEnums*>(
               &_ASTMergeWhenClauseEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(ASTMergeWhenClauseEnums* other);
  friend void swap(ASTMergeWhenClauseEnums& a, ASTMergeWhenClauseEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTMergeWhenClauseEnums* New() const final {
    return CreateMaybeMessage<ASTMergeWhenClauseEnums>(NULL);
  }

  ASTMergeWhenClauseEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTMergeWhenClauseEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTMergeWhenClauseEnums& from);
  void MergeFrom(const ASTMergeWhenClauseEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTMergeWhenClauseEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTMergeWhenClauseEnums_MatchType MatchType;
  static const MatchType NOT_SET =
    ASTMergeWhenClauseEnums_MatchType_NOT_SET;
  static const MatchType MATCHED =
    ASTMergeWhenClauseEnums_MatchType_MATCHED;
  static const MatchType NOT_MATCHED_BY_SOURCE =
    ASTMergeWhenClauseEnums_MatchType_NOT_MATCHED_BY_SOURCE;
  static const MatchType NOT_MATCHED_BY_TARGET =
    ASTMergeWhenClauseEnums_MatchType_NOT_MATCHED_BY_TARGET;
  static inline bool MatchType_IsValid(int value) {
    return ASTMergeWhenClauseEnums_MatchType_IsValid(value);
  }
  static const MatchType MatchType_MIN =
    ASTMergeWhenClauseEnums_MatchType_MatchType_MIN;
  static const MatchType MatchType_MAX =
    ASTMergeWhenClauseEnums_MatchType_MatchType_MAX;
  static const int MatchType_ARRAYSIZE =
    ASTMergeWhenClauseEnums_MatchType_MatchType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MatchType_descriptor() {
    return ASTMergeWhenClauseEnums_MatchType_descriptor();
  }
  static inline const ::std::string& MatchType_Name(MatchType value) {
    return ASTMergeWhenClauseEnums_MatchType_Name(value);
  }
  static inline bool MatchType_Parse(const ::std::string& name,
      MatchType* value) {
    return ASTMergeWhenClauseEnums_MatchType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTMergeWhenClauseEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTFilterFieldsArgEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTFilterFieldsArgEnums) */ {
 public:
  ASTFilterFieldsArgEnums();
  virtual ~ASTFilterFieldsArgEnums();

  ASTFilterFieldsArgEnums(const ASTFilterFieldsArgEnums& from);

  inline ASTFilterFieldsArgEnums& operator=(const ASTFilterFieldsArgEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTFilterFieldsArgEnums(ASTFilterFieldsArgEnums&& from) noexcept
    : ASTFilterFieldsArgEnums() {
    *this = ::std::move(from);
  }

  inline ASTFilterFieldsArgEnums& operator=(ASTFilterFieldsArgEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTFilterFieldsArgEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTFilterFieldsArgEnums* internal_default_instance() {
    return reinterpret_cast<const ASTFilterFieldsArgEnums*>(
               &_ASTFilterFieldsArgEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(ASTFilterFieldsArgEnums* other);
  friend void swap(ASTFilterFieldsArgEnums& a, ASTFilterFieldsArgEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTFilterFieldsArgEnums* New() const final {
    return CreateMaybeMessage<ASTFilterFieldsArgEnums>(NULL);
  }

  ASTFilterFieldsArgEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTFilterFieldsArgEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTFilterFieldsArgEnums& from);
  void MergeFrom(const ASTFilterFieldsArgEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTFilterFieldsArgEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTFilterFieldsArgEnums_FilterType FilterType;
  static const FilterType NOT_SET =
    ASTFilterFieldsArgEnums_FilterType_NOT_SET;
  static const FilterType INCLUDE =
    ASTFilterFieldsArgEnums_FilterType_INCLUDE;
  static const FilterType EXCLUDE =
    ASTFilterFieldsArgEnums_FilterType_EXCLUDE;
  static inline bool FilterType_IsValid(int value) {
    return ASTFilterFieldsArgEnums_FilterType_IsValid(value);
  }
  static const FilterType FilterType_MIN =
    ASTFilterFieldsArgEnums_FilterType_FilterType_MIN;
  static const FilterType FilterType_MAX =
    ASTFilterFieldsArgEnums_FilterType_FilterType_MAX;
  static const int FilterType_ARRAYSIZE =
    ASTFilterFieldsArgEnums_FilterType_FilterType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FilterType_descriptor() {
    return ASTFilterFieldsArgEnums_FilterType_descriptor();
  }
  static inline const ::std::string& FilterType_Name(FilterType value) {
    return ASTFilterFieldsArgEnums_FilterType_Name(value);
  }
  static inline bool FilterType_Parse(const ::std::string& name,
      FilterType* value) {
    return ASTFilterFieldsArgEnums_FilterType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTFilterFieldsArgEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTSampleSizeEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTSampleSizeEnums) */ {
 public:
  ASTSampleSizeEnums();
  virtual ~ASTSampleSizeEnums();

  ASTSampleSizeEnums(const ASTSampleSizeEnums& from);

  inline ASTSampleSizeEnums& operator=(const ASTSampleSizeEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTSampleSizeEnums(ASTSampleSizeEnums&& from) noexcept
    : ASTSampleSizeEnums() {
    *this = ::std::move(from);
  }

  inline ASTSampleSizeEnums& operator=(ASTSampleSizeEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTSampleSizeEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTSampleSizeEnums* internal_default_instance() {
    return reinterpret_cast<const ASTSampleSizeEnums*>(
               &_ASTSampleSizeEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(ASTSampleSizeEnums* other);
  friend void swap(ASTSampleSizeEnums& a, ASTSampleSizeEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTSampleSizeEnums* New() const final {
    return CreateMaybeMessage<ASTSampleSizeEnums>(NULL);
  }

  ASTSampleSizeEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTSampleSizeEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTSampleSizeEnums& from);
  void MergeFrom(const ASTSampleSizeEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTSampleSizeEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTSampleSizeEnums_Unit Unit;
  static const Unit NOT_SET =
    ASTSampleSizeEnums_Unit_NOT_SET;
  static const Unit ROWS =
    ASTSampleSizeEnums_Unit_ROWS;
  static const Unit PERCENT =
    ASTSampleSizeEnums_Unit_PERCENT;
  static inline bool Unit_IsValid(int value) {
    return ASTSampleSizeEnums_Unit_IsValid(value);
  }
  static const Unit Unit_MIN =
    ASTSampleSizeEnums_Unit_Unit_MIN;
  static const Unit Unit_MAX =
    ASTSampleSizeEnums_Unit_Unit_MAX;
  static const int Unit_ARRAYSIZE =
    ASTSampleSizeEnums_Unit_Unit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Unit_descriptor() {
    return ASTSampleSizeEnums_Unit_descriptor();
  }
  static inline const ::std::string& Unit_Name(Unit value) {
    return ASTSampleSizeEnums_Unit_Name(value);
  }
  static inline bool Unit_Parse(const ::std::string& name,
      Unit* value) {
    return ASTSampleSizeEnums_Unit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTSampleSizeEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTForeignKeyActionsEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTForeignKeyActionsEnums) */ {
 public:
  ASTForeignKeyActionsEnums();
  virtual ~ASTForeignKeyActionsEnums();

  ASTForeignKeyActionsEnums(const ASTForeignKeyActionsEnums& from);

  inline ASTForeignKeyActionsEnums& operator=(const ASTForeignKeyActionsEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTForeignKeyActionsEnums(ASTForeignKeyActionsEnums&& from) noexcept
    : ASTForeignKeyActionsEnums() {
    *this = ::std::move(from);
  }

  inline ASTForeignKeyActionsEnums& operator=(ASTForeignKeyActionsEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTForeignKeyActionsEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTForeignKeyActionsEnums* internal_default_instance() {
    return reinterpret_cast<const ASTForeignKeyActionsEnums*>(
               &_ASTForeignKeyActionsEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(ASTForeignKeyActionsEnums* other);
  friend void swap(ASTForeignKeyActionsEnums& a, ASTForeignKeyActionsEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTForeignKeyActionsEnums* New() const final {
    return CreateMaybeMessage<ASTForeignKeyActionsEnums>(NULL);
  }

  ASTForeignKeyActionsEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTForeignKeyActionsEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTForeignKeyActionsEnums& from);
  void MergeFrom(const ASTForeignKeyActionsEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTForeignKeyActionsEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTForeignKeyActionsEnums_Action Action;
  static const Action NO_ACTION =
    ASTForeignKeyActionsEnums_Action_NO_ACTION;
  static const Action RESTRICT =
    ASTForeignKeyActionsEnums_Action_RESTRICT;
  static const Action CASCADE =
    ASTForeignKeyActionsEnums_Action_CASCADE;
  static const Action SET_NULL =
    ASTForeignKeyActionsEnums_Action_SET_NULL;
  static inline bool Action_IsValid(int value) {
    return ASTForeignKeyActionsEnums_Action_IsValid(value);
  }
  static const Action Action_MIN =
    ASTForeignKeyActionsEnums_Action_Action_MIN;
  static const Action Action_MAX =
    ASTForeignKeyActionsEnums_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    ASTForeignKeyActionsEnums_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Action_descriptor() {
    return ASTForeignKeyActionsEnums_Action_descriptor();
  }
  static inline const ::std::string& Action_Name(Action value) {
    return ASTForeignKeyActionsEnums_Action_Name(value);
  }
  static inline bool Action_Parse(const ::std::string& name,
      Action* value) {
    return ASTForeignKeyActionsEnums_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTForeignKeyActionsEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTForeignKeyReferenceEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTForeignKeyReferenceEnums) */ {
 public:
  ASTForeignKeyReferenceEnums();
  virtual ~ASTForeignKeyReferenceEnums();

  ASTForeignKeyReferenceEnums(const ASTForeignKeyReferenceEnums& from);

  inline ASTForeignKeyReferenceEnums& operator=(const ASTForeignKeyReferenceEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTForeignKeyReferenceEnums(ASTForeignKeyReferenceEnums&& from) noexcept
    : ASTForeignKeyReferenceEnums() {
    *this = ::std::move(from);
  }

  inline ASTForeignKeyReferenceEnums& operator=(ASTForeignKeyReferenceEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTForeignKeyReferenceEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTForeignKeyReferenceEnums* internal_default_instance() {
    return reinterpret_cast<const ASTForeignKeyReferenceEnums*>(
               &_ASTForeignKeyReferenceEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(ASTForeignKeyReferenceEnums* other);
  friend void swap(ASTForeignKeyReferenceEnums& a, ASTForeignKeyReferenceEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTForeignKeyReferenceEnums* New() const final {
    return CreateMaybeMessage<ASTForeignKeyReferenceEnums>(NULL);
  }

  ASTForeignKeyReferenceEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTForeignKeyReferenceEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTForeignKeyReferenceEnums& from);
  void MergeFrom(const ASTForeignKeyReferenceEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTForeignKeyReferenceEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTForeignKeyReferenceEnums_Match Match;
  static const Match SIMPLE =
    ASTForeignKeyReferenceEnums_Match_SIMPLE;
  static const Match FULL =
    ASTForeignKeyReferenceEnums_Match_FULL;
  static const Match NOT_DISTINCT =
    ASTForeignKeyReferenceEnums_Match_NOT_DISTINCT;
  static inline bool Match_IsValid(int value) {
    return ASTForeignKeyReferenceEnums_Match_IsValid(value);
  }
  static const Match Match_MIN =
    ASTForeignKeyReferenceEnums_Match_Match_MIN;
  static const Match Match_MAX =
    ASTForeignKeyReferenceEnums_Match_Match_MAX;
  static const int Match_ARRAYSIZE =
    ASTForeignKeyReferenceEnums_Match_Match_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Match_descriptor() {
    return ASTForeignKeyReferenceEnums_Match_descriptor();
  }
  static inline const ::std::string& Match_Name(Match value) {
    return ASTForeignKeyReferenceEnums_Match_Name(value);
  }
  static inline bool Match_Parse(const ::std::string& name,
      Match* value) {
    return ASTForeignKeyReferenceEnums_Match_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTForeignKeyReferenceEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTBreakContinueStatementEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTBreakContinueStatementEnums) */ {
 public:
  ASTBreakContinueStatementEnums();
  virtual ~ASTBreakContinueStatementEnums();

  ASTBreakContinueStatementEnums(const ASTBreakContinueStatementEnums& from);

  inline ASTBreakContinueStatementEnums& operator=(const ASTBreakContinueStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTBreakContinueStatementEnums(ASTBreakContinueStatementEnums&& from) noexcept
    : ASTBreakContinueStatementEnums() {
    *this = ::std::move(from);
  }

  inline ASTBreakContinueStatementEnums& operator=(ASTBreakContinueStatementEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTBreakContinueStatementEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTBreakContinueStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTBreakContinueStatementEnums*>(
               &_ASTBreakContinueStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(ASTBreakContinueStatementEnums* other);
  friend void swap(ASTBreakContinueStatementEnums& a, ASTBreakContinueStatementEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTBreakContinueStatementEnums* New() const final {
    return CreateMaybeMessage<ASTBreakContinueStatementEnums>(NULL);
  }

  ASTBreakContinueStatementEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTBreakContinueStatementEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTBreakContinueStatementEnums& from);
  void MergeFrom(const ASTBreakContinueStatementEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTBreakContinueStatementEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTBreakContinueStatementEnums_BreakContinueKeyword BreakContinueKeyword;
  static const BreakContinueKeyword BREAK =
    ASTBreakContinueStatementEnums_BreakContinueKeyword_BREAK;
  static const BreakContinueKeyword LEAVE =
    ASTBreakContinueStatementEnums_BreakContinueKeyword_LEAVE;
  static const BreakContinueKeyword CONTINUE =
    ASTBreakContinueStatementEnums_BreakContinueKeyword_CONTINUE;
  static const BreakContinueKeyword ITERATE =
    ASTBreakContinueStatementEnums_BreakContinueKeyword_ITERATE;
  static inline bool BreakContinueKeyword_IsValid(int value) {
    return ASTBreakContinueStatementEnums_BreakContinueKeyword_IsValid(value);
  }
  static const BreakContinueKeyword BreakContinueKeyword_MIN =
    ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_MIN;
  static const BreakContinueKeyword BreakContinueKeyword_MAX =
    ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_MAX;
  static const int BreakContinueKeyword_ARRAYSIZE =
    ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BreakContinueKeyword_descriptor() {
    return ASTBreakContinueStatementEnums_BreakContinueKeyword_descriptor();
  }
  static inline const ::std::string& BreakContinueKeyword_Name(BreakContinueKeyword value) {
    return ASTBreakContinueStatementEnums_BreakContinueKeyword_Name(value);
  }
  static inline bool BreakContinueKeyword_Parse(const ::std::string& name,
      BreakContinueKeyword* value) {
    return ASTBreakContinueStatementEnums_BreakContinueKeyword_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTBreakContinueStatementEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTDropStatementEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTDropStatementEnums) */ {
 public:
  ASTDropStatementEnums();
  virtual ~ASTDropStatementEnums();

  ASTDropStatementEnums(const ASTDropStatementEnums& from);

  inline ASTDropStatementEnums& operator=(const ASTDropStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTDropStatementEnums(ASTDropStatementEnums&& from) noexcept
    : ASTDropStatementEnums() {
    *this = ::std::move(from);
  }

  inline ASTDropStatementEnums& operator=(ASTDropStatementEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTDropStatementEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTDropStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTDropStatementEnums*>(
               &_ASTDropStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(ASTDropStatementEnums* other);
  friend void swap(ASTDropStatementEnums& a, ASTDropStatementEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTDropStatementEnums* New() const final {
    return CreateMaybeMessage<ASTDropStatementEnums>(NULL);
  }

  ASTDropStatementEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTDropStatementEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTDropStatementEnums& from);
  void MergeFrom(const ASTDropStatementEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTDropStatementEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTDropStatementEnums_DropMode DropMode;
  static const DropMode DROP_MODE_UNSPECIFIED =
    ASTDropStatementEnums_DropMode_DROP_MODE_UNSPECIFIED;
  static const DropMode RESTRICT =
    ASTDropStatementEnums_DropMode_RESTRICT;
  static const DropMode CASCADE =
    ASTDropStatementEnums_DropMode_CASCADE;
  static inline bool DropMode_IsValid(int value) {
    return ASTDropStatementEnums_DropMode_IsValid(value);
  }
  static const DropMode DropMode_MIN =
    ASTDropStatementEnums_DropMode_DropMode_MIN;
  static const DropMode DropMode_MAX =
    ASTDropStatementEnums_DropMode_DropMode_MAX;
  static const int DropMode_ARRAYSIZE =
    ASTDropStatementEnums_DropMode_DropMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DropMode_descriptor() {
    return ASTDropStatementEnums_DropMode_descriptor();
  }
  static inline const ::std::string& DropMode_Name(DropMode value) {
    return ASTDropStatementEnums_DropMode_Name(value);
  }
  static inline bool DropMode_Parse(const ::std::string& name,
      DropMode* value) {
    return ASTDropStatementEnums_DropMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTDropStatementEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTCreateFunctionStmtBaseEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTCreateFunctionStmtBaseEnums) */ {
 public:
  ASTCreateFunctionStmtBaseEnums();
  virtual ~ASTCreateFunctionStmtBaseEnums();

  ASTCreateFunctionStmtBaseEnums(const ASTCreateFunctionStmtBaseEnums& from);

  inline ASTCreateFunctionStmtBaseEnums& operator=(const ASTCreateFunctionStmtBaseEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTCreateFunctionStmtBaseEnums(ASTCreateFunctionStmtBaseEnums&& from) noexcept
    : ASTCreateFunctionStmtBaseEnums() {
    *this = ::std::move(from);
  }

  inline ASTCreateFunctionStmtBaseEnums& operator=(ASTCreateFunctionStmtBaseEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTCreateFunctionStmtBaseEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTCreateFunctionStmtBaseEnums* internal_default_instance() {
    return reinterpret_cast<const ASTCreateFunctionStmtBaseEnums*>(
               &_ASTCreateFunctionStmtBaseEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(ASTCreateFunctionStmtBaseEnums* other);
  friend void swap(ASTCreateFunctionStmtBaseEnums& a, ASTCreateFunctionStmtBaseEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTCreateFunctionStmtBaseEnums* New() const final {
    return CreateMaybeMessage<ASTCreateFunctionStmtBaseEnums>(NULL);
  }

  ASTCreateFunctionStmtBaseEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTCreateFunctionStmtBaseEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTCreateFunctionStmtBaseEnums& from);
  void MergeFrom(const ASTCreateFunctionStmtBaseEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTCreateFunctionStmtBaseEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTCreateFunctionStmtBaseEnums_DeterminismLevel DeterminismLevel;
  static const DeterminismLevel DETERMINISM_UNSPECIFIED =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DETERMINISM_UNSPECIFIED;
  static const DeterminismLevel DETERMINISTIC =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DETERMINISTIC;
  static const DeterminismLevel NOT_DETERMINISTIC =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_NOT_DETERMINISTIC;
  static const DeterminismLevel IMMUTABLE =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_IMMUTABLE;
  static const DeterminismLevel STABLE =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_STABLE;
  static const DeterminismLevel VOLATILE =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_VOLATILE;
  static inline bool DeterminismLevel_IsValid(int value) {
    return ASTCreateFunctionStmtBaseEnums_DeterminismLevel_IsValid(value);
  }
  static const DeterminismLevel DeterminismLevel_MIN =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_MIN;
  static const DeterminismLevel DeterminismLevel_MAX =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_MAX;
  static const int DeterminismLevel_ARRAYSIZE =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DeterminismLevel_descriptor() {
    return ASTCreateFunctionStmtBaseEnums_DeterminismLevel_descriptor();
  }
  static inline const ::std::string& DeterminismLevel_Name(DeterminismLevel value) {
    return ASTCreateFunctionStmtBaseEnums_DeterminismLevel_Name(value);
  }
  static inline bool DeterminismLevel_Parse(const ::std::string& name,
      DeterminismLevel* value) {
    return ASTCreateFunctionStmtBaseEnums_DeterminismLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTCreateFunctionStmtBaseEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ASTAuxLoadDataStatementEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ASTAuxLoadDataStatementEnums) */ {
 public:
  ASTAuxLoadDataStatementEnums();
  virtual ~ASTAuxLoadDataStatementEnums();

  ASTAuxLoadDataStatementEnums(const ASTAuxLoadDataStatementEnums& from);

  inline ASTAuxLoadDataStatementEnums& operator=(const ASTAuxLoadDataStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASTAuxLoadDataStatementEnums(ASTAuxLoadDataStatementEnums&& from) noexcept
    : ASTAuxLoadDataStatementEnums() {
    *this = ::std::move(from);
  }

  inline ASTAuxLoadDataStatementEnums& operator=(ASTAuxLoadDataStatementEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTAuxLoadDataStatementEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASTAuxLoadDataStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTAuxLoadDataStatementEnums*>(
               &_ASTAuxLoadDataStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(ASTAuxLoadDataStatementEnums* other);
  friend void swap(ASTAuxLoadDataStatementEnums& a, ASTAuxLoadDataStatementEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASTAuxLoadDataStatementEnums* New() const final {
    return CreateMaybeMessage<ASTAuxLoadDataStatementEnums>(NULL);
  }

  ASTAuxLoadDataStatementEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASTAuxLoadDataStatementEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASTAuxLoadDataStatementEnums& from);
  void MergeFrom(const ASTAuxLoadDataStatementEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASTAuxLoadDataStatementEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTAuxLoadDataStatementEnums_InsertionMode InsertionMode;
  static const InsertionMode NOT_SET =
    ASTAuxLoadDataStatementEnums_InsertionMode_NOT_SET;
  static const InsertionMode APPEND =
    ASTAuxLoadDataStatementEnums_InsertionMode_APPEND;
  static const InsertionMode OVERWRITE =
    ASTAuxLoadDataStatementEnums_InsertionMode_OVERWRITE;
  static inline bool InsertionMode_IsValid(int value) {
    return ASTAuxLoadDataStatementEnums_InsertionMode_IsValid(value);
  }
  static const InsertionMode InsertionMode_MIN =
    ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_MIN;
  static const InsertionMode InsertionMode_MAX =
    ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_MAX;
  static const int InsertionMode_ARRAYSIZE =
    ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InsertionMode_descriptor() {
    return ASTAuxLoadDataStatementEnums_InsertionMode_descriptor();
  }
  static inline const ::std::string& InsertionMode_Name(InsertionMode value) {
    return ASTAuxLoadDataStatementEnums_InsertionMode_Name(value);
  }
  static inline bool InsertionMode_Parse(const ::std::string& name,
      InsertionMode* value) {
    return ASTAuxLoadDataStatementEnums_InsertionMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTAuxLoadDataStatementEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fparser_2fast_5fenums_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ASTBinaryExpressionEnums

// -------------------------------------------------------------------

// ASTOrderingExpressionEnums

// -------------------------------------------------------------------

// ASTJoinEnums

// -------------------------------------------------------------------

// ASTSelectAsEnums

// -------------------------------------------------------------------

// ASTFunctionCallEnums

// -------------------------------------------------------------------

// ASTExpressionSubqueryEnums

// -------------------------------------------------------------------

// ASTHavingModifierEnums

// -------------------------------------------------------------------

// ASTSetOperationEnums

// -------------------------------------------------------------------

// ASTUnaryExpressionEnums

// -------------------------------------------------------------------

// ASTWindowFrameEnums

// -------------------------------------------------------------------

// ASTWindowFrameExprEnums

// -------------------------------------------------------------------

// ASTAnySomeAllOpEnums

// -------------------------------------------------------------------

// ASTTransactionReadWriteModeEnums

// -------------------------------------------------------------------

// ASTImportStatementEnums

// -------------------------------------------------------------------

// ASTUnpivotClauseEnums

// -------------------------------------------------------------------

// ASTCreateStatementEnums

// -------------------------------------------------------------------

// ASTFunctionParameterEnums

// -------------------------------------------------------------------

// ASTTemplatedParameterTypeEnums

// -------------------------------------------------------------------

// ASTGeneratedColumnInfoEnums

// -------------------------------------------------------------------

// ASTColumnPositionEnums

// -------------------------------------------------------------------

// ASTInsertStatementEnums

// -------------------------------------------------------------------

// ASTMergeActionEnums

// -------------------------------------------------------------------

// ASTMergeWhenClauseEnums

// -------------------------------------------------------------------

// ASTFilterFieldsArgEnums

// -------------------------------------------------------------------

// ASTSampleSizeEnums

// -------------------------------------------------------------------

// ASTForeignKeyActionsEnums

// -------------------------------------------------------------------

// ASTForeignKeyReferenceEnums

// -------------------------------------------------------------------

// ASTBreakContinueStatementEnums

// -------------------------------------------------------------------

// ASTDropStatementEnums

// -------------------------------------------------------------------

// ASTCreateFunctionStmtBaseEnums

// -------------------------------------------------------------------

// ASTAuxLoadDataStatementEnums

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace zetasql

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::zetasql::ASTBinaryExpressionEnums_Op> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTBinaryExpressionEnums_Op>() {
  return ::zetasql::ASTBinaryExpressionEnums_Op_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTOrderingExpressionEnums_OrderingSpec> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTOrderingExpressionEnums_OrderingSpec>() {
  return ::zetasql::ASTOrderingExpressionEnums_OrderingSpec_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTJoinEnums_JoinType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTJoinEnums_JoinType>() {
  return ::zetasql::ASTJoinEnums_JoinType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTJoinEnums_JoinHint> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTJoinEnums_JoinHint>() {
  return ::zetasql::ASTJoinEnums_JoinHint_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTSelectAsEnums_AsMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTSelectAsEnums_AsMode>() {
  return ::zetasql::ASTSelectAsEnums_AsMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTFunctionCallEnums_NullHandlingModifier> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTFunctionCallEnums_NullHandlingModifier>() {
  return ::zetasql::ASTFunctionCallEnums_NullHandlingModifier_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTExpressionSubqueryEnums_Modifier> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTExpressionSubqueryEnums_Modifier>() {
  return ::zetasql::ASTExpressionSubqueryEnums_Modifier_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTHavingModifierEnums_ModifierKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTHavingModifierEnums_ModifierKind>() {
  return ::zetasql::ASTHavingModifierEnums_ModifierKind_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTSetOperationEnums_OperationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTSetOperationEnums_OperationType>() {
  return ::zetasql::ASTSetOperationEnums_OperationType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTUnaryExpressionEnums_Op> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTUnaryExpressionEnums_Op>() {
  return ::zetasql::ASTUnaryExpressionEnums_Op_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTWindowFrameEnums_FrameUnit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTWindowFrameEnums_FrameUnit>() {
  return ::zetasql::ASTWindowFrameEnums_FrameUnit_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTWindowFrameExprEnums_BoundaryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTWindowFrameExprEnums_BoundaryType>() {
  return ::zetasql::ASTWindowFrameExprEnums_BoundaryType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTAnySomeAllOpEnums_Op> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTAnySomeAllOpEnums_Op>() {
  return ::zetasql::ASTAnySomeAllOpEnums_Op_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTTransactionReadWriteModeEnums_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTTransactionReadWriteModeEnums_Mode>() {
  return ::zetasql::ASTTransactionReadWriteModeEnums_Mode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTImportStatementEnums_ImportKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTImportStatementEnums_ImportKind>() {
  return ::zetasql::ASTImportStatementEnums_ImportKind_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTUnpivotClauseEnums_NullFilter> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTUnpivotClauseEnums_NullFilter>() {
  return ::zetasql::ASTUnpivotClauseEnums_NullFilter_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTCreateStatementEnums_Scope> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTCreateStatementEnums_Scope>() {
  return ::zetasql::ASTCreateStatementEnums_Scope_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTCreateStatementEnums_SqlSecurity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTCreateStatementEnums_SqlSecurity>() {
  return ::zetasql::ASTCreateStatementEnums_SqlSecurity_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTFunctionParameterEnums_ProcedureParameterMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTFunctionParameterEnums_ProcedureParameterMode>() {
  return ::zetasql::ASTFunctionParameterEnums_ProcedureParameterMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTTemplatedParameterTypeEnums_TemplatedTypeKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTTemplatedParameterTypeEnums_TemplatedTypeKind>() {
  return ::zetasql::ASTTemplatedParameterTypeEnums_TemplatedTypeKind_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTGeneratedColumnInfoEnums_StoredMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTGeneratedColumnInfoEnums_StoredMode>() {
  return ::zetasql::ASTGeneratedColumnInfoEnums_StoredMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTColumnPositionEnums_RelativePositionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTColumnPositionEnums_RelativePositionType>() {
  return ::zetasql::ASTColumnPositionEnums_RelativePositionType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTInsertStatementEnums_InsertMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTInsertStatementEnums_InsertMode>() {
  return ::zetasql::ASTInsertStatementEnums_InsertMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTInsertStatementEnums_ParseProgress> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTInsertStatementEnums_ParseProgress>() {
  return ::zetasql::ASTInsertStatementEnums_ParseProgress_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTMergeActionEnums_ActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTMergeActionEnums_ActionType>() {
  return ::zetasql::ASTMergeActionEnums_ActionType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTMergeWhenClauseEnums_MatchType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTMergeWhenClauseEnums_MatchType>() {
  return ::zetasql::ASTMergeWhenClauseEnums_MatchType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTFilterFieldsArgEnums_FilterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTFilterFieldsArgEnums_FilterType>() {
  return ::zetasql::ASTFilterFieldsArgEnums_FilterType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTSampleSizeEnums_Unit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTSampleSizeEnums_Unit>() {
  return ::zetasql::ASTSampleSizeEnums_Unit_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTForeignKeyActionsEnums_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTForeignKeyActionsEnums_Action>() {
  return ::zetasql::ASTForeignKeyActionsEnums_Action_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTForeignKeyReferenceEnums_Match> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTForeignKeyReferenceEnums_Match>() {
  return ::zetasql::ASTForeignKeyReferenceEnums_Match_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTBreakContinueStatementEnums_BreakContinueKeyword> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTBreakContinueStatementEnums_BreakContinueKeyword>() {
  return ::zetasql::ASTBreakContinueStatementEnums_BreakContinueKeyword_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTDropStatementEnums_DropMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTDropStatementEnums_DropMode>() {
  return ::zetasql::ASTDropStatementEnums_DropMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTCreateFunctionStmtBaseEnums_DeterminismLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTCreateFunctionStmtBaseEnums_DeterminismLevel>() {
  return ::zetasql::ASTCreateFunctionStmtBaseEnums_DeterminismLevel_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTAuxLoadDataStatementEnums_InsertionMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTAuxLoadDataStatementEnums_InsertionMode>() {
  return ::zetasql::ASTAuxLoadDataStatementEnums_InsertionMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::SchemaObjectKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::SchemaObjectKind>() {
  return ::zetasql::SchemaObjectKind_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_zetasql_2fparser_2fast_5fenums_2eproto
