//
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// resolved_ast.cc GENERATED FROM resolved_ast.cc.template
#include "zetasql/resolved_ast/resolved_ast.h"

#include <type_traits>

#include "google/protobuf/descriptor.h"
#include "zetasql/common/errors.h"
#include "zetasql/public/catalog.h"
#include "zetasql/public/constant.h"
#include "zetasql/public/strings.h"
#include "zetasql/public/type.h"
#include "zetasql/public/types/type_parameters.h"
#include "zetasql/resolved_ast/resolved_ast_visitor.h"
#include "absl/memory/memory.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_join.h"
#include "absl/strings/str_split.h"
#include "absl/types/span.h"
#include "zetasql/base/status.h"

namespace zetasql {

namespace {

// Helper for IsDefaultValue to allow template partial specialization,
// which we can do with a class but not with a function.
template <class T>
struct TestIsDefaultValue {
  static bool IsDefaultValue(const T& value) {
    static_assert(std::is_pod<T>::value,
                  "Customize IsDefaultValue for non-POD types");
    return value == T();
  }
};
template <class T>
struct TestIsDefaultValue<std::unique_ptr<T>> {
  static bool IsDefaultValue(const std::unique_ptr<T>& value) {
    return value == nullptr;
  }
};
template <class T>
struct TestIsDefaultValue<std::shared_ptr<T>> {
  static bool IsDefaultValue(const std::shared_ptr<T>& value) {
    return value == nullptr;
  }
};
template <class T>
struct TestIsDefaultValue<std::vector<T>> {
  static bool IsDefaultValue(const std::vector<T>& value) {
    return value.empty();
  }
};
template <>
struct TestIsDefaultValue<std::string> {
  static bool IsDefaultValue(const std::string& value) {
    return value.empty();
  }
};
template <>
struct TestIsDefaultValue<Value> {
  static bool IsDefaultValue(const Value& value) {
    return !value.is_valid();
  }
};
template <>
struct TestIsDefaultValue<FunctionSignature> {
  static bool IsDefaultValue(const FunctionSignature& signature) {
    return signature.NumOptionalArguments() == -1 &&
           signature.NumRepeatedArguments() == -1;
  }
};
template <>
struct TestIsDefaultValue<std::shared_ptr<ResolvedFunctionCallInfo>> {
  static bool IsDefaultValue(
      const std::shared_ptr<ResolvedFunctionCallInfo>& info) {
    return info == nullptr || info->Is<ResolvedFunctionCallInfo>();
  }
};
template <>
struct TestIsDefaultValue<ResolvedColumn> {
  static bool IsDefaultValue(const ResolvedColumn& column) {
    return !column.IsInitialized();
  }
};
template <>
struct TestIsDefaultValue<TypeParameters> {
  static bool IsDefaultValue(const TypeParameters& type_parameters) {
    return type_parameters.IsEmpty();
  }
};

template <>
struct TestIsDefaultValue<ResolvedCollation> {
  static bool IsDefaultValue(const ResolvedCollation& resolved_collation) {
    return resolved_collation.Empty();
  }
};

// Return true if <value> is equal to the default value for its type.
// e.g. for pointers, return true if <value> is nullptr.
// TODO This provides no way to distinguish an unset value from a
// value explicitly set to its default.  Replace this with something
// smarter and more explicit.
template <class T>
static bool IsDefaultValue(const T& value) {
  return TestIsDefaultValue<T>::IsDefaultValue(value);
}

static std::string ToStringImpl(const std::string& s) {
  return ToStringLiteral(s);
}
static std::string ToStringImpl(bool b) {
  return b ? "TRUE" : "FALSE";
}
static std::string ToStringImpl(int i) {
  return absl::StrCat(i);
}
static std::string ToStringCommaSeparated(const std::vector<int>& value_vector) {
  return absl::StrCat("[", absl::StrJoin(value_vector, ", "), "]");
}
static std::string ToStringImpl(
    const std::vector<ResolvedStatement::ObjectAccess>& value_vector) {
  std::string ret;
  for (const ResolvedStatement::ObjectAccess& value : value_vector) {
    std::string name = ResolvedStatementEnums::ObjectAccess_Name(value);
    if (name.empty()) {
      ZETASQL_LOG(DFATAL) << "Invalid ObjectAccess: " << value;
      name = absl::StrCat("INVALID_OBJECT_ACCESS(", value, ")");
    }
    if (!ret.empty()) ret += ",";
    ret += name;
  }
  return ret;
}
static std::string ToStringImpl(ResolvedJoinScan::JoinType join_type) {
  std::string name = ResolvedJoinScanEnums::JoinType_Name(join_type);
  if (!name.empty()) return name;
  ZETASQL_LOG(DFATAL) << "Invalid JoinType: " << join_type;
  return absl::StrCat("INVALID_JOIN_TYPE(", join_type, ")");
}
static std::string ToStringImpl(ResolvedSubqueryExpr::SubqueryType type) {
  std::string name = ResolvedSubqueryExprEnums::SubqueryType_Name(type);
  if (!name.empty()) return name;
  ZETASQL_LOG(DFATAL) << "Invalid SubqueryType: " << type;
  return absl::StrCat("INVALID_SUBQUERY_TYPE(", type, ")");
}
static std::string ToStringImpl(ResolvedSetOperationScan::SetOperationType type) {
  std::string name = ResolvedSetOperationScanEnums::SetOperationType_Name(type);
  if (!name.empty()) return name;
  ZETASQL_LOG(DFATAL) << "Invalid SetType: " << type;
  return absl::StrCat("INVALID_SET_TYPE(", type, ")");
}
static std::string ToStringImpl(ResolvedRecursiveScan::RecursiveSetOperationType type) {
  std::string name = ResolvedRecursiveScanEnums::RecursiveSetOperationType_Name(type);
  if (!name.empty()) return name;
  ZETASQL_LOG(DFATAL) << "Invalid RecursiveSetType: " << type;
  return absl::StrCat("INVALID_SET_TYPE(", type, ")");
}
static std::string ToStringImpl(ResolvedCreateStatement::CreateScope scope) {
  std::string name = ResolvedCreateStatementEnums::CreateScope_Name(scope);
  if (!name.empty()) return name;
  ZETASQL_LOG(DFATAL) << "Invalid CreateScope: " << scope;
  return absl::StrCat("INVALID_CREATE_SCOPE(", scope, ")");
}
static std::string ToStringImpl(ResolvedCreateStatement::CreateMode mode) {
  std::string name = ResolvedCreateStatementEnums::CreateMode_Name(mode);
  if (!name.empty()) return name;
  ZETASQL_LOG(DFATAL) << "Invalid CreateMode: " << mode;
  return absl::StrCat("INVALID_CREATE_MODE(", mode, ")");
}

static std::string ToStringImpl(ResolvedDropStmtEnums::DropMode mode) {
  std::string name = ResolvedDropStmtEnums::DropMode_Name(mode);
  if (!name.empty()) return name;
  ZETASQL_LOG(DFATAL) << "Invalid DropMode: " << mode;
  return absl::StrCat("INVALID_DROP_MODE(", mode, ")");
}
static std::string ToStringImpl(ResolvedBeginStmt::ReadWriteMode mode) {
  std::string name = ResolvedBeginStmtEnums::ReadWriteMode_Name(mode);
  if (!name.empty()) return name;
  ZETASQL_LOG(DFATAL) << "Invalid ReadWriteMode: " << mode;
  return absl::StrCat("INVALID_READ_WRITE_MODE(", mode, ")");
}
static std::string ToStringImpl(ResolvedSampleScan::SampleUnit unit) {
  std::string name = ResolvedSampleScanEnums::SampleUnit_Name(unit);
  if (!name.empty()) return name;
  ZETASQL_LOG(DFATAL) << "Invalid SampleUnit: " << unit;
  return absl::StrCat("INVALID_SAMPLE_UNIT(", unit, ")");
}
static std::string ToStringImpl(FieldFormat::Format format) {
  const std::string& str = FieldFormat_Format_Name(format);
  return !str.empty() ? str : absl::StrCat("INVALID_FORMAT(", format, ")");
}
static std::string ToStringImpl(ResolvedInsertStmt::InsertMode insert_mode) {
  return ResolvedInsertStmt::InsertModeToString(insert_mode);
}
static std::string ToStringImpl(
    ResolvedAggregateHavingModifier::HavingModifierKind kind) {
  return ResolvedAggregateHavingModifier::HavingModifierKindToString(kind);
}
static const std::string& ToStringImpl(
    ResolvedNonScalarFunctionCallBaseEnums::NullHandlingModifier kind) {
  return ResolvedNonScalarFunctionCallBaseEnums::NullHandlingModifier_Name(
      kind);
}
static std::string ToStringImpl(ResolvedArgumentDef::ArgumentKind kind) {
  const std::string& str = ResolvedArgumentDefEnums::ArgumentKind_Name(kind);
  return !str.empty() ? str : absl::StrCat("INVALID_ARGUMENT_KIND(", kind, ")");
}
static std::string ToStringImpl(ResolvedImportStmt::ImportKind kind) {
  return ResolvedImportStmt::ImportKindToString(kind);
}
static std::string ToStringImpl(ResolvedAuxLoadDataStmt::InsertionMode mode) {
  std::string name = ResolvedAuxLoadDataStmtEnums::InsertionMode_Name(mode);
  if (!name.empty()) return name;
  ZETASQL_LOG(DFATAL) << "Invalid InsertionMode: " << mode;
  return absl::StrCat("INVALID_INSERTION_MODE(", mode, ")");
}
static std::string ToStringImpl(const FunctionSignature& signature) {
  return signature.DebugString();
}
static std::string ToStringImpl(const std::shared_ptr<FunctionSignature>& signature) {
  return signature->DebugString();
}
static std::string ToStringImpl(
    const std::shared_ptr<ResolvedFunctionCallInfo>& function_call_info) {
  if (function_call_info == nullptr) return "<null>";
  return function_call_info->DebugString();
}
static std::string ToStringVerbose(const FunctionSignature& signature) {
  return signature.DebugString("" /* function_name */, true /* verbose */);
}
static std::string ToStringVerbose(const std::shared_ptr<FunctionSignature>& signature) {
  return signature->DebugString("" /* function_name */, true /* verbose */);
}
static std::string ToStringImpl(const Table* table) {
  return table == nullptr ? "<null>" : table->FullName();
}
static std::string ToStringImpl(const Model* model) {
  return model->FullName();
}
static std::string ToStringImpl(const Connection* connection) {
  return connection->FullName();
}
static std::string ToStringImpl(const TableValuedFunction* tvf) {
  return absl::StrCat(absl::StrJoin(tvf->function_name_path(), "."), "(",
                FunctionSignature::SignaturesToString(
                    tvf->signatures(), /*verbose=*/true, /*prefix=*/"",
                    /*separator=*/"; "),
                ")");
}
static std::string ToStringImpl(const Procedure* procedure) {
  return procedure->FullName();
}
static std::string ToStringImpl(const std::shared_ptr<TVFSignature>& tvf_signature) {
  return tvf_signature->DebugString();
}
static std::string ToStringImpl(const Type* type) {
  return type->DebugString();
}
static std::string ToStringImpl(const google::protobuf::FieldDescriptor* field) {
  return field->is_extension() ?
      absl::StrCat("[", field->full_name(), "]"): field->name();
}
static std::string ToStringVectorFieldDescriptor(const std::vector<const google::protobuf::FieldDescriptor*>& field_vector) {
  std::string output;
  for (const google::protobuf::FieldDescriptor* field : field_vector) {
    if (!output.empty()) {
      absl::StrAppend(&output, ".");
    }
    absl::StrAppend(&output, ToStringImpl(field));
  }
  return output;
}

static std::string ToStringImpl(const google::protobuf::OneofDescriptor* oneof) {
  return oneof->name();
}

static std::string ToStringImpl(const ResolvedColumn& column) {
  return column.DebugString();
}
static std::string ToStringImpl(const ResolvedColumnList& column_list) {
  return ResolvedColumnListToString(column_list);
}
static std::string ToStringImpl(const Value& value) {
  return value.ShortDebugString();
}
static std::string ToStringImpl(const std::vector<std::string>& value_vector,
                           const std::string& separator) {
  std::string ret;
  for (const std::string& value : value_vector) {
    if (!ret.empty()) ret += separator;
    ret += ToIdentifierLiteral(value);
  }
  return ret;
}
static std::string ToStringImpl(const ResolvedMergeWhen::MatchType match_type) {
  std::string name = ResolvedMergeWhenEnums::MatchType_Name(match_type);
  if (!name.empty()) return name;
  ZETASQL_LOG(DFATAL) << "Invalid MatchType: " << match_type;
  return absl::StrCat("INVALID_MATCH_TYPE(", match_type, ")");
}
static std::string ToStringImpl(const ResolvedMergeWhen::ActionType action_type) {
  std::string name = ResolvedMergeWhenEnums::ActionType_Name(action_type);
  if (!name.empty()) return name;
  ZETASQL_LOG(DFATAL) << "Invalid ActionType: " << action_type;
  return absl::StrCat("INVALID_ACTION_TYPE(", action_type, ")");
}
static std::string ToStringImpl(ResolvedForeignKeyEnums::MatchMode match_mode) {
  std::string name = ResolvedForeignKeyEnums::MatchMode_Name(match_mode);
  if (!name.empty()) return name;
  ZETASQL_LOG(DFATAL) << "Invalid MatchMode: " << match_mode;
  return absl::StrCat("INVALID_MATCH_MODE(", match_mode, ")");
}
static std::string ToStringImpl(
    ResolvedForeignKeyEnums::ActionOperation action_operation) {
  std::string name = ResolvedForeignKeyEnums::ActionOperation_Name(action_operation);
  if (!name.empty()) return name;
  ZETASQL_LOG(DFATAL) << "Invalid ActionOperation: " << action_operation;
  return absl::StrCat("INVALID_ACTION_OPERATION(", action_operation, ")");
}
static std::string ToStringImpl(
    ResolvedCreateStatementEnums::SqlSecurity sql_security) {
  std::string name = ResolvedCreateStatementEnums::SqlSecurity_Name(sql_security);
  if (!name.empty()) return name;
  ZETASQL_LOG(DFATAL) << "Invalid SqlSecurity: " << sql_security;
  return absl::StrCat("INVALID_SQL_SECURITY(", sql_security, ")");
}
static std::string ToStringImpl(
    ResolvedOrderByItemEnums::NullOrderMode null_order) {
  std::string name = ResolvedOrderByItemEnums::NullOrderMode_Name(null_order);
  if (!name.empty()) return name;
  ZETASQL_LOG(DFATAL) << "Invalid NullOrderMode: " << null_order;
  return absl::StrCat("INVALID_NULL_ORDER(", null_order, ")");
}
static std::string ToStringImpl(
    ResolvedCreateStatementEnums::DeterminismLevel level) {
  std::string name = ResolvedCreateStatementEnums::DeterminismLevel_Name(level);
  if (!name.empty()) return name;
  ZETASQL_LOG(DFATAL) << "Invalid DeterminismLevel: " << level;
  return absl::StrCat("INVALID_DETERMINISM_LEVEL(", level, ")");
}
static std::string ToStringImpl(
    ResolvedGeneratedColumnInfoEnums::StoredMode mode) {
  switch (mode) {
    case ResolvedGeneratedColumnInfoEnums::STORED:
      return "STORED";
    case ResolvedGeneratedColumnInfoEnums::STORED_VOLATILE:
      return "STORED_VOLATILE";
    default:
      ZETASQL_LOG(DFATAL) << "Invalid StoredMode: " << mode;
      return absl::StrCat("INVALID_STORED_MODE(", mode, ")");
  }
}

// Most vector<std::string> fields are identifier paths so we format
// the value that way by default.
// For other vector<std::string> fields, we can override this with to_string_method.
static std::string ToStringImpl(const std::vector<std::string>& value_vector) {
  return ToStringImpl(value_vector, ".");
}
// This formats a list of identifiers (quoting if needed).
static std::string ToStringCommaSeparated(const std::vector<std::string>& value_vector) {
  return absl::StrCat("[", ToStringImpl(value_vector, ", "), "]");
}

// Use template functions to allow functions with the same argument list but
// different return types.
template <class R, class P>
absl::StatusOr<R> RestoreFromImpl(const P& proto, const ResolvedNode::RestoreParams& params);

// The SaveToImpl(ScalarType, FileDescriptorSetMap*, ScalarProtoType*) functions
// implement the serialization logic for scalar types. The FileDescriptorSetMap
// argument is used for serialization of zetasql::Type and data structures
// that contain zetasql::Types. For detailed usage, see comments above
// Type::SerializeToProtoAndDistinctFileDescriptors().
static absl::Status SaveToImpl(
    const Table* table,
    FileDescriptorSetMap* file_descriptor_set_map,
    TableRefProto* proto) {
  if (table != nullptr) {
    proto->set_name(table->Name());
    proto->set_serialization_id(table->GetSerializationId());
    proto->set_full_name(table->FullName());
  }
  return absl::OkStatus();
}

// The RestoreFrom functions reverse the effect of the SaveTo functions.
template<>
absl::StatusOr<const Table*> RestoreFromImpl(
    const TableRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  const Table* table;
  const std::vector<std::string> path = absl::StrSplit(proto.full_name(), '.');
  if (proto.has_serialization_id()) {
    ZETASQL_RETURN_IF_ERROR(params.catalog->FindTable(path, &table));
  } else {
    // The original table was a nullptr.
    table = nullptr;
  }
  return table;
}

static absl::Status SaveToImpl(
    const Model* model,
    FileDescriptorSetMap* file_descriptor_set_map,
    ModelRefProto* proto) {
  proto->set_name(model->Name());
  proto->set_serialization_id(model->GetSerializationId());
  proto->set_full_name(model->FullName());
  return absl::OkStatus();
}

// The RestoreFrom functions reverse the effect of the SaveTo functions.
template<>
absl::StatusOr<const Model*> RestoreFromImpl(
    const ModelRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  const Model* model;
  const std::vector<std::string> path = absl::StrSplit(proto.full_name(), '.');
  ZETASQL_RETURN_IF_ERROR(params.catalog->FindModel(path, &model));
  return model;
}

static absl::Status SaveToImpl(
   const Connection* connection,
   FileDescriptorSetMap* file_descriptor_set_map,
   ConnectionRefProto* proto) {
  proto->set_name(connection->Name());
  proto->set_full_name(connection->FullName());
  return absl::OkStatus();
}

template<>
absl::StatusOr<const Connection*> RestoreFromImpl(
    const ConnectionRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  const Connection* connection;
  const std::vector<std::string> path = absl::StrSplit(proto.full_name(), '.');
  ZETASQL_RETURN_IF_ERROR(params.catalog->FindConnection(path, &connection,
                                                 Catalog::FindOptions()));
  return connection;
}

static absl::Status SaveToImpl(
    const Constant* constant,
    FileDescriptorSetMap* file_descriptor_set_map,
    ConstantRefProto* proto) {
  proto->set_name(constant->FullName());
  return absl::OkStatus();
}

template<>
absl::StatusOr<const Constant*> RestoreFromImpl(
    const ConstantRefProto& proto, const ResolvedNode::RestoreParams& params) {
  if (proto.name().empty()) {
    return zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
           << "Tried to parse function with blank name: "
           << proto.DebugString();
  }

  const Constant* constant;
  const std::vector<std::string> path = absl::StrSplit(proto.name(), '.');
  ZETASQL_RETURN_IF_ERROR(params.catalog->FindConstant(path, &constant));
  return constant;
}

static absl::Status SaveToImpl(
    const Function* func,
    FileDescriptorSetMap* file_descriptor_set_map,
    FunctionRefProto* proto) {
  proto->set_name(func->FullName(true  /* include_group */));
  return absl::OkStatus();
}

template<>
absl::StatusOr<const Function*> RestoreFromImpl(
    const FunctionRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  // Serialized function names include the group. We do not need this to look
  // up a function in the catalog.
  const std::vector<absl::string_view> group_and_name =
      absl::StrSplit(proto.name(), ":");
  if (group_and_name.empty()) {
    return zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
        << "Tried to parse function with blank name: " << proto.DebugString();
  }

  const Function* func;
  const std::vector<std::string> path = absl::StrSplit(group_and_name.back(), '.');
  ZETASQL_RETURN_IF_ERROR(params.catalog->FindFunction(path, &func));
  return func;
}

static absl::Status SaveToImpl(
    const TableValuedFunction* func,
    FileDescriptorSetMap* file_descriptor_set_map,
    TableValuedFunctionRefProto* proto) {
  proto->set_name(func->FullName());
  return absl::OkStatus();
}

template<>
absl::StatusOr<const TableValuedFunction*> RestoreFromImpl(
    const TableValuedFunctionRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  const TableValuedFunction* func;
  const std::vector<std::string> path = absl::StrSplit(proto.name(), '.');
  ZETASQL_RETURN_IF_ERROR(params.catalog->FindTableValuedFunction(path, &func));
  return func;
}

static absl::Status SaveToImpl(
    const Procedure* procedure,
    FileDescriptorSetMap* file_descriptor_set_map,
    ProcedureRefProto* proto) {
  proto->set_name(procedure->FullName());
  return absl::OkStatus();
}

template<>
absl::StatusOr<const Procedure*> RestoreFromImpl(
    const ProcedureRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  const Procedure* procedure;
  const std::vector<std::string> path = absl::StrSplit(proto.name(), '.');
  ZETASQL_RETURN_IF_ERROR(params.catalog->FindProcedure(path, &procedure));
  return procedure;
}

static absl::Status SaveToImpl(
    const FunctionSignature& sig,
    FileDescriptorSetMap* file_descriptor_set_map,
    FunctionSignatureProto* proto) {
  return sig.Serialize(file_descriptor_set_map, proto);
}

template<>
absl::StatusOr<FunctionSignature> RestoreFromImpl(
    const FunctionSignatureProto& proto,
    const ResolvedNode::RestoreParams& params) {
  // Some fields demand being set as FunctionSignature, not
  // std::unique_ptr<FunctionSignature>. It's fine if we just copy the returned
  // one though.
  std::unique_ptr<FunctionSignature> sig;
  ZETASQL_RETURN_IF_ERROR(FunctionSignature::Deserialize(
      proto, params.pools, params.type_factory, &sig));
  return *sig;
}

static absl::Status SaveToImpl(
    const std::shared_ptr<FunctionSignature>& sig,
    FileDescriptorSetMap* file_descriptor_set_map,
    FunctionSignatureProto* proto) {
  if (sig != nullptr) {
    return sig->Serialize(file_descriptor_set_map, proto);
  }
  return absl::OkStatus();
}

template<>
absl::StatusOr<std::shared_ptr<FunctionSignature>> RestoreFromImpl(
    const FunctionSignatureProto& proto,
    const ResolvedNode::RestoreParams& params) {
  // Some fields demand being set as FunctionSignature, not
  // std::unique_ptr<FunctionSignature>. It's fine if we just copy the returned
  // one though.
  std::unique_ptr<FunctionSignature> sig;
  ZETASQL_RETURN_IF_ERROR(FunctionSignature::Deserialize(
      proto, params.pools, params.type_factory, &sig));
  return sig;
}

static absl::Status SaveToImpl(
    const Type* type,
    FileDescriptorSetMap* file_descriptor_set_map,
    TypeProto* proto) {
  return type->SerializeToProtoAndDistinctFileDescriptors(
      proto, file_descriptor_set_map);
}

template<>
absl::StatusOr<const Type*> RestoreFromImpl(
    const TypeProto& proto,
    const ResolvedNode::RestoreParams& params) {
  const Type* type;
  ZETASQL_RETURN_IF_ERROR(params.type_factory->DeserializeFromProtoUsingExistingPools(
      proto, params.pools, &type));
  return type;
}

static absl::Status SaveToImpl(
    const google::protobuf::FieldDescriptor* desc,
    FileDescriptorSetMap* file_descriptor_set_map,
    FieldDescriptorRefProto* proto) {
  TypeFactory factory;
  const ProtoType* proto_type;
  ZETASQL_RETURN_IF_ERROR(factory.MakeProtoType(desc->containing_type(), &proto_type));
  TypeProto type_proto;
  ZETASQL_RETURN_IF_ERROR(proto_type->SerializeToProtoAndDistinctFileDescriptors(
      &type_proto, file_descriptor_set_map));
  *proto->mutable_containing_proto() = type_proto.proto_type();
  proto->set_number(desc->number());
  return absl::OkStatus();
}

template<>
absl::StatusOr<const google::protobuf::FieldDescriptor*> RestoreFromImpl(
    const FieldDescriptorRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  TypeProto type_proto;
  type_proto.set_type_kind(TypeKind::TYPE_PROTO);
  *type_proto.mutable_proto_type() = proto.containing_proto();
  const Type* containing_type;
  ZETASQL_RETURN_IF_ERROR(params.type_factory->DeserializeFromProtoUsingExistingPools(
      type_proto, params.pools, &containing_type));
  const ProtoType* proto_type = containing_type->AsProto();
  if (!proto_type) {
    return zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
        << "Expected ProtoType, got: " << containing_type->DebugString();
  }
  const google::protobuf::FieldDescriptor* field_descriptor =
      proto_type->descriptor()->FindFieldByNumber(proto.number());
  if (field_descriptor) return field_descriptor;

  // Otherwise, let's look through the extensions and see if one of those match.
  for (const auto* pool : params.pools) {
    field_descriptor = pool->FindExtensionByNumber(proto_type->descriptor(),
                                                   proto.number());
    if (field_descriptor) return field_descriptor;
  }

  return zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
      << "Field number " << proto.number() << " is neither a field or a known "
      << "extension of " << proto_type->DebugString();
}

static absl::Status SaveToImpl(const google::protobuf::OneofDescriptor* oneof_desc,
                               FileDescriptorSetMap* file_descriptor_set_map,
                               OneofDescriptorRefProto* oneof_proto) {
  TypeFactory factory;
  const ProtoType* containing_proto_type;
  ZETASQL_RETURN_IF_ERROR(factory.MakeProtoType(oneof_desc->containing_type(),
                                        &containing_proto_type));
  TypeProto containing_proto;
  ZETASQL_RETURN_IF_ERROR(
      containing_proto_type->SerializeToProtoAndDistinctFileDescriptors(
          &containing_proto, file_descriptor_set_map));
  *oneof_proto->mutable_containing_proto() = containing_proto.proto_type();
  oneof_proto->set_index(oneof_desc->index());
  return absl::OkStatus();
}

template<>
absl::StatusOr<const google::protobuf::OneofDescriptor*> RestoreFromImpl(
    const OneofDescriptorRefProto& oneof_proto,
    const ResolvedNode::RestoreParams& params) {
  TypeProto containing_proto;
  containing_proto.set_type_kind(TypeKind::TYPE_PROTO);
  *containing_proto.mutable_proto_type() = oneof_proto.containing_proto();
  const Type* containing_type;
  ZETASQL_RETURN_IF_ERROR(params.type_factory->DeserializeFromProtoUsingExistingPools(
      containing_proto, params.pools, &containing_type));
  ZETASQL_RET_CHECK(containing_type != nullptr);
  const ProtoType* containing_proto_type = containing_type->AsProto();
  ZETASQL_RET_CHECK(containing_proto_type != nullptr);
  if (oneof_proto.index() < 0 ||
      oneof_proto.index() >=
          containing_proto_type->descriptor()->oneof_decl_count()) {
    return zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
           << "Invalid Oneof index " << oneof_proto.index() << " in message "
           << containing_proto_type->DebugString();
  }
  return containing_proto_type->descriptor()->oneof_decl(oneof_proto.index());
}

static absl::Status SaveToImpl(
    const ResolvedColumn& column,
    FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedColumnProto* proto) {
  return column.SaveTo(file_descriptor_set_map, proto);
}

template<>
absl::StatusOr<ResolvedColumn> RestoreFromImpl(
    const ResolvedColumnProto& proto,
    const ResolvedNode::RestoreParams& params) {
  return ResolvedColumn::RestoreFrom(proto, params);
}

static absl::Status SaveToImpl(
    const Value& value,
    FileDescriptorSetMap* file_descriptor_set_map,
    ValueWithTypeProto* proto) {
  if (!value.is_valid()) {
    return absl::OkStatus();
  }
  ZETASQL_RETURN_IF_ERROR(value.Serialize(proto->mutable_value()));
  return SaveToImpl(
      value.type(), file_descriptor_set_map, proto->mutable_type());
}

template<>
absl::StatusOr<Value> RestoreFromImpl(
    const ValueWithTypeProto& proto,
    const ResolvedNode::RestoreParams& params) {
  if (!proto.has_value()) {
    // The only way you get a blank value field is by serializing an invalid
    // value. So that's what we return if we see !has_value.
    return Value();
  }
  ZETASQL_ASSIGN_OR_RETURN(const Type* type, RestoreFromImpl<const Type*>(proto.type(), params));
  return Value::Deserialize(proto.value(), type);
}

static absl::Status SaveToImpl(
    const std::shared_ptr<TVFSignature>& tvf_signature,
    FileDescriptorSetMap* file_descriptor_set_map,
    TVFSignatureProto* proto) {
  for (const TVFInputArgumentType& arg : tvf_signature->input_arguments()) {
    TVFArgumentProto* arg_proto = proto->add_argument();
    if (arg.is_relation()) {
      for (const TVFRelation::Column& col : arg.relation().columns()) {
        TVFRelationColumnProto* col_proto =
            arg_proto->mutable_relation_argument()->add_column();
        col_proto->set_name(col.name);
        ZETASQL_RETURN_IF_ERROR(SaveToImpl(
            col.type, file_descriptor_set_map, col_proto->mutable_type()));
      }
      arg_proto->mutable_relation_argument()->set_is_value_table(
          arg.relation().is_value_table());
    } else if (arg.is_model()) {
      TVFModelProto* model_proto = arg_proto->mutable_model_argument();
      model_proto->set_name(arg.model().model()->Name());
      model_proto->set_full_name(arg.model().model()->FullName());
    } else if (arg.is_connection()) {
      TVFConnectionProto* connection_proto =
          arg_proto->mutable_connection_argument();
      connection_proto->set_name(arg.connection().connection()->Name());
      connection_proto->set_full_name(
          arg.connection().connection()->FullName());
    } else if (arg.is_descriptor()) {
      TVFDescriptorProto* descriptor_proto =
          arg_proto->mutable_descriptor_argument();
      for (const auto& name : arg.descriptor_argument().column_names()) {
        *(descriptor_proto->add_column_name()) = name;
      }
    } else {
      ZETASQL_ASSIGN_OR_RETURN(const InputArgumentType& arg_type,
                       arg.GetScalarArgType());
      ZETASQL_RETURN_IF_ERROR(SaveToImpl(
          arg_type.type(), file_descriptor_set_map,
          arg_proto->mutable_scalar_argument()->mutable_type()));
      if (arg_type.literal_value() != nullptr) {
        ZETASQL_RETURN_IF_ERROR(SaveToImpl(
            *arg_type.literal_value(), file_descriptor_set_map,
            arg_proto->mutable_scalar_argument()));
      }
    }
  }
  TVFRelationProto* output_schema_proto = proto->mutable_output_schema();
  for (const TVFRelation::Column& col :
           tvf_signature->result_schema().columns()) {
    TVFRelationColumnProto* col_proto = output_schema_proto->add_column();
    col_proto->set_name(col.name);
    col_proto->set_is_pseudo_column(col.is_pseudo_column);
    ZETASQL_RETURN_IF_ERROR(SaveToImpl(
        col.type, file_descriptor_set_map, col_proto->mutable_type()));
  }
  output_schema_proto->set_is_value_table(
      tvf_signature->result_schema().is_value_table());

  for (const FreestandingDeprecationWarning& warning :
           tvf_signature->options().additional_deprecation_warnings) {
    *proto->mutable_options()->add_additional_deprecation_warning() =
        warning;
  }

  return absl::OkStatus();
}

template<>
absl::StatusOr<std::shared_ptr<TVFSignature>> RestoreFromImpl(
    const TVFSignatureProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<TVFInputArgumentType> input_args;
  input_args.reserve(proto.argument_size());
  for (const TVFArgumentProto& argument : proto.argument()) {
    if (argument.has_relation_argument()) {
      const TVFRelationProto& relation_arg = argument.relation_argument();
      std::vector<TVFRelation::Column> cols;
      cols.reserve(relation_arg.column_size());
      const Type* type = nullptr;
      for (const TVFRelationColumnProto& col_proto : relation_arg.column()) {
        ZETASQL_ASSIGN_OR_RETURN(
            type, RestoreFromImpl<const Type*>(col_proto.type(), params));
        cols.emplace_back(TVFRelation::Column(col_proto.name(), type));
      }
      if (relation_arg.is_value_table()) {
        input_args.push_back(TVFInputArgumentType(
            TVFRelation::ValueTable(type)));
      } else {
        input_args.push_back(TVFInputArgumentType(TVFRelation(cols)));
      }
    } else if (argument.has_model_argument()) {
      const Model* model;
      const std::vector<std::string> path = absl::StrSplit(
        argument.model_argument().full_name(), '.');
      ZETASQL_RETURN_IF_ERROR(params.catalog->FindModel(path, &model));
      input_args.push_back(TVFInputArgumentType(TVFModelArgument(
        model)));
    } else if (argument.has_connection_argument()) {
      const Connection* connection;
      const std::vector<std::string> path = absl::StrSplit(
        argument.connection_argument().full_name(), '.');
      ZETASQL_RETURN_IF_ERROR(params.catalog->FindConnection(path, &connection,
                                                     Catalog::FindOptions()));
      input_args.push_back(TVFInputArgumentType(TVFConnectionArgument(
        connection)));
    } else if (argument.has_descriptor_argument()) {
      std::vector<std::string> names;
      const TVFDescriptorProto& descriptor_arg = argument.descriptor_argument();
      for (const auto& name : descriptor_arg.column_name()) {
        names.push_back(name);
      }
      input_args.push_back(TVFInputArgumentType(TVFDescriptorArgument(names)));
    } else {
      const ValueWithTypeProto& scalar_arg = argument.scalar_argument();
      if (scalar_arg.has_value()) {
        ZETASQL_ASSIGN_OR_RETURN(const Value value,
                         RestoreFromImpl<Value>(scalar_arg, params));
        input_args.push_back(TVFInputArgumentType(InputArgumentType(value)));
      } else {
        ZETASQL_ASSIGN_OR_RETURN(
            const Type* type,
            RestoreFromImpl<const Type*>(scalar_arg.type(), params));
        input_args.push_back(TVFInputArgumentType(InputArgumentType(type)));
      }
    }
  }
  std::vector<TVFRelation::Column> cols;
  cols.reserve(proto.output_schema().column_size());
  const Type* type = nullptr;
  for (const TVFRelationColumnProto& col_proto :
       proto.output_schema().column()) {
    ZETASQL_ASSIGN_OR_RETURN(
        type, RestoreFromImpl<const Type*>(col_proto.type(), params));
    cols.emplace_back(TVFRelation::Column(col_proto.name(), type,
                                          col_proto.is_pseudo_column()));
  }

  TVFSignatureOptions options;
  for (const FreestandingDeprecationWarning& warning :
           proto.options().additional_deprecation_warning()) {
    options.additional_deprecation_warnings.push_back(warning);
  }

  if (proto.output_schema().is_value_table()) {
    const Type* type = cols[0].type;
    cols.erase(cols.begin());
    ZETASQL_ASSIGN_OR_RETURN(TVFRelation table_schema,
                     TVFRelation::ValueTable(type, cols));
    return std::shared_ptr<TVFSignature>(
        new TVFSignature(input_args, std::move(table_schema), options));
  } else {
    return std::shared_ptr<TVFSignature>(
        new TVFSignature(input_args, TVFRelation(cols), options));
  }
}

static absl::Status SaveToImpl(
    const std::shared_ptr<ResolvedFunctionCallInfo>& context,
    FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedFunctionCallInfoProto* proto) {
  // TODO: Implement this for ResolvedFunctionCallInfo subclasses.
  return absl::OkStatus();
}

template<>
absl::StatusOr<std::shared_ptr<ResolvedFunctionCallInfo>>
    RestoreFromImpl(
        const ResolvedFunctionCallInfoProto& proto,
        const ResolvedNode::RestoreParams& params) {
  // TODO: Implement this for ResolvedFunctionCallInfo subclasses.
  return std::shared_ptr<ResolvedFunctionCallInfo>(
      new ResolvedFunctionCallInfo());
}

static std::string ToStringImpl(const ResolvedCollation& resolved_collation) {
  return resolved_collation.DebugString();
}

static std::string ToStringImpl(
    const std::vector<ResolvedCollation>& resolved_collation_list) {
  return ResolvedCollation::ToString(resolved_collation_list);
}

static absl::Status SaveToImpl(
    const ResolvedCollation& resolved_collation,
    FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCollationProto* proto) {
  return resolved_collation.Serialize(proto);
}

template<>
absl::StatusOr<ResolvedCollation>
    RestoreFromImpl(
        const ResolvedCollationProto& proto,
        const ResolvedNode::RestoreParams& params) {
  return ResolvedCollation::Deserialize(proto);
}

static std::string ToStringImpl(const AnnotationMap* annotation_map) {
  return annotation_map->DebugString();
}

static absl::Status SaveToImpl(
    const AnnotationMap* annotation_map,
    FileDescriptorSetMap* file_descriptor_set_map,
    AnnotationMapProto* proto) {
  if (annotation_map != nullptr && !annotation_map->Empty()) {
    ZETASQL_RETURN_IF_ERROR(annotation_map->Serialize(proto));
  }
  return absl::OkStatus();
}

template<>
absl::StatusOr<const AnnotationMap*>
    RestoreFromImpl(
        const AnnotationMapProto& proto,
        const ResolvedNode::RestoreParams& params) {
  const AnnotationMap* annotation_map = nullptr;
  if (proto.annotations_size() > 0
      || proto.has_array_element()
      || proto.struct_fields_size() > 0) {
    ZETASQL_RETURN_IF_ERROR(
        params.type_factory->DeserializeAnnotationMap(proto,
                                                      &annotation_map));
  }
  return annotation_map;
}

static std::string ToStringImpl(const TypeParameters& type_parameters) {
  return type_parameters.DebugString();
}

static absl::Status SaveToImpl(
    const TypeParameters& type_parameters,
    FileDescriptorSetMap* file_descriptor_set_map,
    TypeParametersProto* proto) {
  if (!type_parameters.IsEmpty()) {
    ZETASQL_RETURN_IF_ERROR(type_parameters.Serialize(proto));
  }
  return absl::OkStatus();
}

template<>
absl::StatusOr<TypeParameters>
    RestoreFromImpl(
        const TypeParametersProto& proto,
        const ResolvedNode::RestoreParams& params) {
  return TypeParameters::Deserialize(proto);
}

}  // anonymous namespace

// This is defined separately from the rest of the RestoreFrom implementations
// because the root node does not have a proper entry in the tree generated in
// gen_resolved_ast.py, so we have to iterate the nodes in a different way.
absl::StatusOr<std::unique_ptr<ResolvedNode>> ResolvedNode::RestoreFrom(
    const AnyResolvedNodeProto& proto, const RestoreParams& params) {
  switch (proto.node_case()) {
    case AnyResolvedNodeProto::kResolvedArgumentNode:
      return ResolvedArgument::RestoreFrom(
          proto.resolved_argument_node(), params);
    case AnyResolvedNodeProto::kResolvedExprNode:
      return ResolvedExpr::RestoreFrom(
          proto.resolved_expr_node(), params);
    case AnyResolvedNodeProto::kResolvedScanNode:
      return ResolvedScan::RestoreFrom(
          proto.resolved_scan_node(), params);
    case AnyResolvedNodeProto::kResolvedStatementNode:
      return ResolvedStatement::RestoreFrom(
          proto.resolved_statement_node(), params);
    case AnyResolvedNodeProto::NODE_NOT_SET:
      return ::zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
          << "No subnode types set in AnyResolvedNodeProto";
  }
}

std::string ResolvedNodeKindToString(ResolvedNodeKind kind) {
  switch (kind) {
    case RESOLVED_LITERAL: return "Literal";
    case RESOLVED_PARAMETER: return "Parameter";
    case RESOLVED_EXPRESSION_COLUMN: return "ExpressionColumn";
    case RESOLVED_COLUMN_REF: return "ColumnRef";
    case RESOLVED_CONSTANT: return "Constant";
    case RESOLVED_SYSTEM_VARIABLE: return "SystemVariable";
    case RESOLVED_INLINE_LAMBDA: return "InlineLambda";
    case RESOLVED_FILTER_FIELD_ARG: return "FilterFieldArg";
    case RESOLVED_FILTER_FIELD: return "FilterField";
    case RESOLVED_FUNCTION_CALL: return "FunctionCall";
    case RESOLVED_AGGREGATE_FUNCTION_CALL: return "AggregateFunctionCall";
    case RESOLVED_ANALYTIC_FUNCTION_CALL: return "AnalyticFunctionCall";
    case RESOLVED_EXTENDED_CAST_ELEMENT: return "ExtendedCastElement";
    case RESOLVED_EXTENDED_CAST: return "ExtendedCast";
    case RESOLVED_CAST: return "Cast";
    case RESOLVED_MAKE_STRUCT: return "MakeStruct";
    case RESOLVED_MAKE_PROTO: return "MakeProto";
    case RESOLVED_MAKE_PROTO_FIELD: return "MakeProtoField";
    case RESOLVED_GET_STRUCT_FIELD: return "GetStructField";
    case RESOLVED_GET_PROTO_FIELD: return "GetProtoField";
    case RESOLVED_GET_JSON_FIELD: return "GetJsonField";
    case RESOLVED_FLATTEN: return "Flatten";
    case RESOLVED_FLATTENED_ARG: return "FlattenedArg";
    case RESOLVED_REPLACE_FIELD_ITEM: return "ReplaceFieldItem";
    case RESOLVED_REPLACE_FIELD: return "ReplaceField";
    case RESOLVED_SUBQUERY_EXPR: return "SubqueryExpr";
    case RESOLVED_LET_EXPR: return "LetExpr";
    case RESOLVED_MODEL: return "Model";
    case RESOLVED_CONNECTION: return "Connection";
    case RESOLVED_DESCRIPTOR: return "Descriptor";
    case RESOLVED_SINGLE_ROW_SCAN: return "SingleRowScan";
    case RESOLVED_TABLE_SCAN: return "TableScan";
    case RESOLVED_JOIN_SCAN: return "JoinScan";
    case RESOLVED_ARRAY_SCAN: return "ArrayScan";
    case RESOLVED_COLUMN_HOLDER: return "ColumnHolder";
    case RESOLVED_FILTER_SCAN: return "FilterScan";
    case RESOLVED_GROUPING_SET: return "GroupingSet";
    case RESOLVED_AGGREGATE_SCAN: return "AggregateScan";
    case RESOLVED_ANONYMIZED_AGGREGATE_SCAN: return "AnonymizedAggregateScan";
    case RESOLVED_SET_OPERATION_ITEM: return "SetOperationItem";
    case RESOLVED_SET_OPERATION_SCAN: return "SetOperationScan";
    case RESOLVED_ORDER_BY_SCAN: return "OrderByScan";
    case RESOLVED_LIMIT_OFFSET_SCAN: return "LimitOffsetScan";
    case RESOLVED_WITH_REF_SCAN: return "WithRefScan";
    case RESOLVED_ANALYTIC_SCAN: return "AnalyticScan";
    case RESOLVED_SAMPLE_SCAN: return "SampleScan";
    case RESOLVED_COMPUTED_COLUMN: return "ComputedColumn";
    case RESOLVED_ORDER_BY_ITEM: return "OrderByItem";
    case RESOLVED_COLUMN_ANNOTATIONS: return "ColumnAnnotations";
    case RESOLVED_GENERATED_COLUMN_INFO: return "GeneratedColumnInfo";
    case RESOLVED_COLUMN_DEFAULT_VALUE: return "ColumnDefaultValue";
    case RESOLVED_COLUMN_DEFINITION: return "ColumnDefinition";
    case RESOLVED_PRIMARY_KEY: return "PrimaryKey";
    case RESOLVED_FOREIGN_KEY: return "ForeignKey";
    case RESOLVED_CHECK_CONSTRAINT: return "CheckConstraint";
    case RESOLVED_OUTPUT_COLUMN: return "OutputColumn";
    case RESOLVED_PROJECT_SCAN: return "ProjectScan";
    case RESOLVED_TVFSCAN: return "TVFScan";
    case RESOLVED_GROUP_ROWS_SCAN: return "GroupRowsScan";
    case RESOLVED_FUNCTION_ARGUMENT: return "FunctionArgument";
    case RESOLVED_EXPLAIN_STMT: return "ExplainStmt";
    case RESOLVED_QUERY_STMT: return "QueryStmt";
    case RESOLVED_CREATE_DATABASE_STMT: return "CreateDatabaseStmt";
    case RESOLVED_INDEX_ITEM: return "IndexItem";
    case RESOLVED_UNNEST_ITEM: return "UnnestItem";
    case RESOLVED_CREATE_INDEX_STMT: return "CreateIndexStmt";
    case RESOLVED_CREATE_SCHEMA_STMT: return "CreateSchemaStmt";
    case RESOLVED_CREATE_TABLE_STMT: return "CreateTableStmt";
    case RESOLVED_CREATE_TABLE_AS_SELECT_STMT: return "CreateTableAsSelectStmt";
    case RESOLVED_CREATE_MODEL_STMT: return "CreateModelStmt";
    case RESOLVED_CREATE_VIEW_STMT: return "CreateViewStmt";
    case RESOLVED_WITH_PARTITION_COLUMNS: return "WithPartitionColumns";
    case RESOLVED_CREATE_SNAPSHOT_TABLE_STMT: return "CreateSnapshotTableStmt";
    case RESOLVED_CREATE_EXTERNAL_TABLE_STMT: return "CreateExternalTableStmt";
    case RESOLVED_EXPORT_MODEL_STMT: return "ExportModelStmt";
    case RESOLVED_EXPORT_DATA_STMT: return "ExportDataStmt";
    case RESOLVED_DEFINE_TABLE_STMT: return "DefineTableStmt";
    case RESOLVED_DESCRIBE_STMT: return "DescribeStmt";
    case RESOLVED_SHOW_STMT: return "ShowStmt";
    case RESOLVED_BEGIN_STMT: return "BeginStmt";
    case RESOLVED_SET_TRANSACTION_STMT: return "SetTransactionStmt";
    case RESOLVED_COMMIT_STMT: return "CommitStmt";
    case RESOLVED_ROLLBACK_STMT: return "RollbackStmt";
    case RESOLVED_START_BATCH_STMT: return "StartBatchStmt";
    case RESOLVED_RUN_BATCH_STMT: return "RunBatchStmt";
    case RESOLVED_ABORT_BATCH_STMT: return "AbortBatchStmt";
    case RESOLVED_DROP_STMT: return "DropStmt";
    case RESOLVED_DROP_MATERIALIZED_VIEW_STMT: return "DropMaterializedViewStmt";
    case RESOLVED_DROP_SNAPSHOT_TABLE_STMT: return "DropSnapshotTableStmt";
    case RESOLVED_RECURSIVE_REF_SCAN: return "RecursiveRefScan";
    case RESOLVED_RECURSIVE_SCAN: return "RecursiveScan";
    case RESOLVED_WITH_SCAN: return "WithScan";
    case RESOLVED_WITH_ENTRY: return "WithEntry";
    case RESOLVED_OPTION: return "Option";
    case RESOLVED_WINDOW_PARTITIONING: return "WindowPartitioning";
    case RESOLVED_WINDOW_ORDERING: return "WindowOrdering";
    case RESOLVED_WINDOW_FRAME: return "WindowFrame";
    case RESOLVED_ANALYTIC_FUNCTION_GROUP: return "AnalyticFunctionGroup";
    case RESOLVED_WINDOW_FRAME_EXPR: return "WindowFrameExpr";
    case RESOLVED_DMLVALUE: return "DMLValue";
    case RESOLVED_DMLDEFAULT: return "DMLDefault";
    case RESOLVED_ASSERT_STMT: return "AssertStmt";
    case RESOLVED_ASSERT_ROWS_MODIFIED: return "AssertRowsModified";
    case RESOLVED_INSERT_ROW: return "InsertRow";
    case RESOLVED_INSERT_STMT: return "InsertStmt";
    case RESOLVED_DELETE_STMT: return "DeleteStmt";
    case RESOLVED_UPDATE_ITEM: return "UpdateItem";
    case RESOLVED_UPDATE_ARRAY_ITEM: return "UpdateArrayItem";
    case RESOLVED_UPDATE_STMT: return "UpdateStmt";
    case RESOLVED_MERGE_WHEN: return "MergeWhen";
    case RESOLVED_MERGE_STMT: return "MergeStmt";
    case RESOLVED_TRUNCATE_STMT: return "TruncateStmt";
    case RESOLVED_OBJECT_UNIT: return "ObjectUnit";
    case RESOLVED_PRIVILEGE: return "Privilege";
    case RESOLVED_GRANT_STMT: return "GrantStmt";
    case RESOLVED_REVOKE_STMT: return "RevokeStmt";
    case RESOLVED_ALTER_DATABASE_STMT: return "AlterDatabaseStmt";
    case RESOLVED_ALTER_MATERIALIZED_VIEW_STMT: return "AlterMaterializedViewStmt";
    case RESOLVED_ALTER_SCHEMA_STMT: return "AlterSchemaStmt";
    case RESOLVED_ALTER_TABLE_STMT: return "AlterTableStmt";
    case RESOLVED_ALTER_VIEW_STMT: return "AlterViewStmt";
    case RESOLVED_SET_OPTIONS_ACTION: return "SetOptionsAction";
    case RESOLVED_ADD_COLUMN_ACTION: return "AddColumnAction";
    case RESOLVED_ADD_CONSTRAINT_ACTION: return "AddConstraintAction";
    case RESOLVED_DROP_CONSTRAINT_ACTION: return "DropConstraintAction";
    case RESOLVED_DROP_PRIMARY_KEY_ACTION: return "DropPrimaryKeyAction";
    case RESOLVED_ALTER_COLUMN_OPTIONS_ACTION: return "AlterColumnOptionsAction";
    case RESOLVED_ALTER_COLUMN_DROP_NOT_NULL_ACTION: return "AlterColumnDropNotNullAction";
    case RESOLVED_ALTER_COLUMN_SET_DATA_TYPE_ACTION: return "AlterColumnSetDataTypeAction";
    case RESOLVED_ALTER_COLUMN_SET_DEFAULT_ACTION: return "AlterColumnSetDefaultAction";
    case RESOLVED_ALTER_COLUMN_DROP_DEFAULT_ACTION: return "AlterColumnDropDefaultAction";
    case RESOLVED_DROP_COLUMN_ACTION: return "DropColumnAction";
    case RESOLVED_RENAME_COLUMN_ACTION: return "RenameColumnAction";
    case RESOLVED_SET_AS_ACTION: return "SetAsAction";
    case RESOLVED_SET_COLLATE_CLAUSE: return "SetCollateClause";
    case RESOLVED_ALTER_TABLE_SET_OPTIONS_STMT: return "AlterTableSetOptionsStmt";
    case RESOLVED_RENAME_STMT: return "RenameStmt";
    case RESOLVED_CREATE_PRIVILEGE_RESTRICTION_STMT: return "CreatePrivilegeRestrictionStmt";
    case RESOLVED_CREATE_ROW_ACCESS_POLICY_STMT: return "CreateRowAccessPolicyStmt";
    case RESOLVED_DROP_PRIVILEGE_RESTRICTION_STMT: return "DropPrivilegeRestrictionStmt";
    case RESOLVED_DROP_ROW_ACCESS_POLICY_STMT: return "DropRowAccessPolicyStmt";
    case RESOLVED_DROP_SEARCH_INDEX_STMT: return "DropSearchIndexStmt";
    case RESOLVED_GRANT_TO_ACTION: return "GrantToAction";
    case RESOLVED_RESTRICT_TO_ACTION: return "RestrictToAction";
    case RESOLVED_ADD_TO_RESTRICTEE_LIST_ACTION: return "AddToRestricteeListAction";
    case RESOLVED_REMOVE_FROM_RESTRICTEE_LIST_ACTION: return "RemoveFromRestricteeListAction";
    case RESOLVED_FILTER_USING_ACTION: return "FilterUsingAction";
    case RESOLVED_REVOKE_FROM_ACTION: return "RevokeFromAction";
    case RESOLVED_RENAME_TO_ACTION: return "RenameToAction";
    case RESOLVED_ALTER_PRIVILEGE_RESTRICTION_STMT: return "AlterPrivilegeRestrictionStmt";
    case RESOLVED_ALTER_ROW_ACCESS_POLICY_STMT: return "AlterRowAccessPolicyStmt";
    case RESOLVED_ALTER_ALL_ROW_ACCESS_POLICIES_STMT: return "AlterAllRowAccessPoliciesStmt";
    case RESOLVED_CREATE_CONSTANT_STMT: return "CreateConstantStmt";
    case RESOLVED_CREATE_FUNCTION_STMT: return "CreateFunctionStmt";
    case RESOLVED_ARGUMENT_DEF: return "ArgumentDef";
    case RESOLVED_ARGUMENT_REF: return "ArgumentRef";
    case RESOLVED_CREATE_TABLE_FUNCTION_STMT: return "CreateTableFunctionStmt";
    case RESOLVED_RELATION_ARGUMENT_SCAN: return "RelationArgumentScan";
    case RESOLVED_ARGUMENT_LIST: return "ArgumentList";
    case RESOLVED_FUNCTION_SIGNATURE_HOLDER: return "FunctionSignatureHolder";
    case RESOLVED_DROP_FUNCTION_STMT: return "DropFunctionStmt";
    case RESOLVED_DROP_TABLE_FUNCTION_STMT: return "DropTableFunctionStmt";
    case RESOLVED_CALL_STMT: return "CallStmt";
    case RESOLVED_IMPORT_STMT: return "ImportStmt";
    case RESOLVED_MODULE_STMT: return "ModuleStmt";
    case RESOLVED_AGGREGATE_HAVING_MODIFIER: return "AggregateHavingModifier";
    case RESOLVED_CREATE_MATERIALIZED_VIEW_STMT: return "CreateMaterializedViewStmt";
    case RESOLVED_CREATE_PROCEDURE_STMT: return "CreateProcedureStmt";
    case RESOLVED_EXECUTE_IMMEDIATE_ARGUMENT: return "ExecuteImmediateArgument";
    case RESOLVED_EXECUTE_IMMEDIATE_STMT: return "ExecuteImmediateStmt";
    case RESOLVED_ASSIGNMENT_STMT: return "AssignmentStmt";
    case RESOLVED_CREATE_ENTITY_STMT: return "CreateEntityStmt";
    case RESOLVED_ALTER_ENTITY_STMT: return "AlterEntityStmt";
    case RESOLVED_PIVOT_COLUMN: return "PivotColumn";
    case RESOLVED_PIVOT_SCAN: return "PivotScan";
    case RESOLVED_RETURNING_CLAUSE: return "ReturningClause";
    case RESOLVED_UNPIVOT_ARG: return "UnpivotArg";
    case RESOLVED_UNPIVOT_SCAN: return "UnpivotScan";
    case RESOLVED_CLONE_DATA_STMT: return "CloneDataStmt";
    case RESOLVED_TABLE_AND_COLUMN_INFO: return "TableAndColumnInfo";
    case RESOLVED_ANALYZE_STMT: return "AnalyzeStmt";
    case RESOLVED_AUX_LOAD_DATA_STMT: return "AuxLoadDataStmt";
    default:
      return absl::StrCat("INVALID_RESOLVED_NODE_KIND(", kind, ")");
  }
}

ResolvedArgument::~ResolvedArgument() {
}

absl::Status ResolvedArgument::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedNodeProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_argument_node());
}

absl::Status ResolvedArgument::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedArgumentProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedArgument>> ResolvedArgument::RestoreFrom(
    const AnyResolvedArgumentProto& proto,
    const ResolvedNode::RestoreParams& params) {
  switch (proto.node_case()) {
    case AnyResolvedArgumentProto::kResolvedMakeProtoFieldNode:
      return ResolvedMakeProtoField::RestoreFrom(
          proto.resolved_make_proto_field_node(), params);
    case AnyResolvedArgumentProto::kResolvedColumnHolderNode:
      return ResolvedColumnHolder::RestoreFrom(
          proto.resolved_column_holder_node(), params);
    case AnyResolvedArgumentProto::kResolvedComputedColumnNode:
      return ResolvedComputedColumn::RestoreFrom(
          proto.resolved_computed_column_node(), params);
    case AnyResolvedArgumentProto::kResolvedOrderByItemNode:
      return ResolvedOrderByItem::RestoreFrom(
          proto.resolved_order_by_item_node(), params);
    case AnyResolvedArgumentProto::kResolvedOutputColumnNode:
      return ResolvedOutputColumn::RestoreFrom(
          proto.resolved_output_column_node(), params);
    case AnyResolvedArgumentProto::kResolvedWithEntryNode:
      return ResolvedWithEntry::RestoreFrom(
          proto.resolved_with_entry_node(), params);
    case AnyResolvedArgumentProto::kResolvedOptionNode:
      return ResolvedOption::RestoreFrom(
          proto.resolved_option_node(), params);
    case AnyResolvedArgumentProto::kResolvedWindowPartitioningNode:
      return ResolvedWindowPartitioning::RestoreFrom(
          proto.resolved_window_partitioning_node(), params);
    case AnyResolvedArgumentProto::kResolvedWindowOrderingNode:
      return ResolvedWindowOrdering::RestoreFrom(
          proto.resolved_window_ordering_node(), params);
    case AnyResolvedArgumentProto::kResolvedWindowFrameNode:
      return ResolvedWindowFrame::RestoreFrom(
          proto.resolved_window_frame_node(), params);
    case AnyResolvedArgumentProto::kResolvedAnalyticFunctionGroupNode:
      return ResolvedAnalyticFunctionGroup::RestoreFrom(
          proto.resolved_analytic_function_group_node(), params);
    case AnyResolvedArgumentProto::kResolvedWindowFrameExprNode:
      return ResolvedWindowFrameExpr::RestoreFrom(
          proto.resolved_window_frame_expr_node(), params);
    case AnyResolvedArgumentProto::kResolvedDmlvalueNode:
      return ResolvedDMLValue::RestoreFrom(
          proto.resolved_dmlvalue_node(), params);
    case AnyResolvedArgumentProto::kResolvedAssertRowsModifiedNode:
      return ResolvedAssertRowsModified::RestoreFrom(
          proto.resolved_assert_rows_modified_node(), params);
    case AnyResolvedArgumentProto::kResolvedInsertRowNode:
      return ResolvedInsertRow::RestoreFrom(
          proto.resolved_insert_row_node(), params);
    case AnyResolvedArgumentProto::kResolvedUpdateItemNode:
      return ResolvedUpdateItem::RestoreFrom(
          proto.resolved_update_item_node(), params);
    case AnyResolvedArgumentProto::kResolvedPrivilegeNode:
      return ResolvedPrivilege::RestoreFrom(
          proto.resolved_privilege_node(), params);
    case AnyResolvedArgumentProto::kResolvedArgumentDefNode:
      return ResolvedArgumentDef::RestoreFrom(
          proto.resolved_argument_def_node(), params);
    case AnyResolvedArgumentProto::kResolvedArgumentListNode:
      return ResolvedArgumentList::RestoreFrom(
          proto.resolved_argument_list_node(), params);
    case AnyResolvedArgumentProto::kResolvedFunctionArgumentNode:
      return ResolvedFunctionArgument::RestoreFrom(
          proto.resolved_function_argument_node(), params);
    case AnyResolvedArgumentProto::kResolvedFunctionSignatureHolderNode:
      return ResolvedFunctionSignatureHolder::RestoreFrom(
          proto.resolved_function_signature_holder_node(), params);
    case AnyResolvedArgumentProto::kResolvedAggregateHavingModifierNode:
      return ResolvedAggregateHavingModifier::RestoreFrom(
          proto.resolved_aggregate_having_modifier_node(), params);
    case AnyResolvedArgumentProto::kResolvedColumnDefinitionNode:
      return ResolvedColumnDefinition::RestoreFrom(
          proto.resolved_column_definition_node(), params);
    case AnyResolvedArgumentProto::kResolvedGroupingSetNode:
      return ResolvedGroupingSet::RestoreFrom(
          proto.resolved_grouping_set_node(), params);
    case AnyResolvedArgumentProto::kResolvedSetOperationItemNode:
      return ResolvedSetOperationItem::RestoreFrom(
          proto.resolved_set_operation_item_node(), params);
    case AnyResolvedArgumentProto::kResolvedIndexItemNode:
      return ResolvedIndexItem::RestoreFrom(
          proto.resolved_index_item_node(), params);
    case AnyResolvedArgumentProto::kResolvedMergeWhenNode:
      return ResolvedMergeWhen::RestoreFrom(
          proto.resolved_merge_when_node(), params);
    case AnyResolvedArgumentProto::kResolvedUpdateArrayItemNode:
      return ResolvedUpdateArrayItem::RestoreFrom(
          proto.resolved_update_array_item_node(), params);
    case AnyResolvedArgumentProto::kResolvedColumnAnnotationsNode:
      return ResolvedColumnAnnotations::RestoreFrom(
          proto.resolved_column_annotations_node(), params);
    case AnyResolvedArgumentProto::kResolvedGeneratedColumnInfoNode:
      return ResolvedGeneratedColumnInfo::RestoreFrom(
          proto.resolved_generated_column_info_node(), params);
    case AnyResolvedArgumentProto::kResolvedModelNode:
      return ResolvedModel::RestoreFrom(
          proto.resolved_model_node(), params);
    case AnyResolvedArgumentProto::kResolvedAlterActionNode:
      return ResolvedAlterAction::RestoreFrom(
          proto.resolved_alter_action_node(), params);
    case AnyResolvedArgumentProto::kResolvedUnnestItemNode:
      return ResolvedUnnestItem::RestoreFrom(
          proto.resolved_unnest_item_node(), params);
    case AnyResolvedArgumentProto::kResolvedReplaceFieldItemNode:
      return ResolvedReplaceFieldItem::RestoreFrom(
          proto.resolved_replace_field_item_node(), params);
    case AnyResolvedArgumentProto::kResolvedConnectionNode:
      return ResolvedConnection::RestoreFrom(
          proto.resolved_connection_node(), params);
    case AnyResolvedArgumentProto::kResolvedExecuteImmediateArgumentNode:
      return ResolvedExecuteImmediateArgument::RestoreFrom(
          proto.resolved_execute_immediate_argument_node(), params);
    case AnyResolvedArgumentProto::kResolvedDescriptorNode:
      return ResolvedDescriptor::RestoreFrom(
          proto.resolved_descriptor_node(), params);
    case AnyResolvedArgumentProto::kResolvedExtendedCastElementNode:
      return ResolvedExtendedCastElement::RestoreFrom(
          proto.resolved_extended_cast_element_node(), params);
    case AnyResolvedArgumentProto::kResolvedWithPartitionColumnsNode:
      return ResolvedWithPartitionColumns::RestoreFrom(
          proto.resolved_with_partition_columns_node(), params);
    case AnyResolvedArgumentProto::kResolvedExtendedCastNode:
      return ResolvedExtendedCast::RestoreFrom(
          proto.resolved_extended_cast_node(), params);
    case AnyResolvedArgumentProto::kResolvedInlineLambdaNode:
      return ResolvedInlineLambda::RestoreFrom(
          proto.resolved_inline_lambda_node(), params);
    case AnyResolvedArgumentProto::kResolvedConstraintNode:
      return ResolvedConstraint::RestoreFrom(
          proto.resolved_constraint_node(), params);
    case AnyResolvedArgumentProto::kResolvedPivotColumnNode:
      return ResolvedPivotColumn::RestoreFrom(
          proto.resolved_pivot_column_node(), params);
    case AnyResolvedArgumentProto::kResolvedReturningClauseNode:
      return ResolvedReturningClause::RestoreFrom(
          proto.resolved_returning_clause_node(), params);
    case AnyResolvedArgumentProto::kResolvedUnpivotArgNode:
      return ResolvedUnpivotArg::RestoreFrom(
          proto.resolved_unpivot_arg_node(), params);
    case AnyResolvedArgumentProto::kResolvedFilterFieldArgNode:
      return ResolvedFilterFieldArg::RestoreFrom(
          proto.resolved_filter_field_arg_node(), params);
    case AnyResolvedArgumentProto::kResolvedTableAndColumnInfoNode:
      return ResolvedTableAndColumnInfo::RestoreFrom(
          proto.resolved_table_and_column_info_node(), params);
    case AnyResolvedArgumentProto::kResolvedColumnDefaultValueNode:
      return ResolvedColumnDefaultValue::RestoreFrom(
          proto.resolved_column_default_value_node(), params);
    case AnyResolvedArgumentProto::kResolvedObjectUnitNode:
      return ResolvedObjectUnit::RestoreFrom(
          proto.resolved_object_unit_node(), params);
  case AnyResolvedArgumentProto::NODE_NOT_SET:
    return ::zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
        << "No subnode types set in ResolvedArgumentProto";
  }
}

absl::Status ResolvedArgument::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedArgument(this);
}

absl::Status ResolvedArgument::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

ResolvedExpr::~ResolvedExpr() {
}

absl::Status ResolvedExpr::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedNodeProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_expr_node());
}

absl::Status ResolvedExpr::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedExprProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      type_, file_descriptor_set_map,
      proto->mutable_type()));
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      type_annotation_map_, file_descriptor_set_map,
      proto->mutable_type_annotation_map()));
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedExpr>> ResolvedExpr::RestoreFrom(
    const AnyResolvedExprProto& proto,
    const ResolvedNode::RestoreParams& params) {
  switch (proto.node_case()) {
    case AnyResolvedExprProto::kResolvedLiteralNode:
      return ResolvedLiteral::RestoreFrom(
          proto.resolved_literal_node(), params);
    case AnyResolvedExprProto::kResolvedParameterNode:
      return ResolvedParameter::RestoreFrom(
          proto.resolved_parameter_node(), params);
    case AnyResolvedExprProto::kResolvedExpressionColumnNode:
      return ResolvedExpressionColumn::RestoreFrom(
          proto.resolved_expression_column_node(), params);
    case AnyResolvedExprProto::kResolvedColumnRefNode:
      return ResolvedColumnRef::RestoreFrom(
          proto.resolved_column_ref_node(), params);
    case AnyResolvedExprProto::kResolvedFunctionCallBaseNode:
      return ResolvedFunctionCallBase::RestoreFrom(
          proto.resolved_function_call_base_node(), params);
    case AnyResolvedExprProto::kResolvedCastNode:
      return ResolvedCast::RestoreFrom(
          proto.resolved_cast_node(), params);
    case AnyResolvedExprProto::kResolvedMakeStructNode:
      return ResolvedMakeStruct::RestoreFrom(
          proto.resolved_make_struct_node(), params);
    case AnyResolvedExprProto::kResolvedMakeProtoNode:
      return ResolvedMakeProto::RestoreFrom(
          proto.resolved_make_proto_node(), params);
    case AnyResolvedExprProto::kResolvedGetStructFieldNode:
      return ResolvedGetStructField::RestoreFrom(
          proto.resolved_get_struct_field_node(), params);
    case AnyResolvedExprProto::kResolvedGetProtoFieldNode:
      return ResolvedGetProtoField::RestoreFrom(
          proto.resolved_get_proto_field_node(), params);
    case AnyResolvedExprProto::kResolvedSubqueryExprNode:
      return ResolvedSubqueryExpr::RestoreFrom(
          proto.resolved_subquery_expr_node(), params);
    case AnyResolvedExprProto::kResolvedDmldefaultNode:
      return ResolvedDMLDefault::RestoreFrom(
          proto.resolved_dmldefault_node(), params);
    case AnyResolvedExprProto::kResolvedArgumentRefNode:
      return ResolvedArgumentRef::RestoreFrom(
          proto.resolved_argument_ref_node(), params);
    case AnyResolvedExprProto::kResolvedConstantNode:
      return ResolvedConstant::RestoreFrom(
          proto.resolved_constant_node(), params);
    case AnyResolvedExprProto::kResolvedReplaceFieldNode:
      return ResolvedReplaceField::RestoreFrom(
          proto.resolved_replace_field_node(), params);
    case AnyResolvedExprProto::kResolvedSystemVariableNode:
      return ResolvedSystemVariable::RestoreFrom(
          proto.resolved_system_variable_node(), params);
    case AnyResolvedExprProto::kResolvedFlattenNode:
      return ResolvedFlatten::RestoreFrom(
          proto.resolved_flatten_node(), params);
    case AnyResolvedExprProto::kResolvedFlattenedArgNode:
      return ResolvedFlattenedArg::RestoreFrom(
          proto.resolved_flattened_arg_node(), params);
    case AnyResolvedExprProto::kResolvedGetJsonFieldNode:
      return ResolvedGetJsonField::RestoreFrom(
          proto.resolved_get_json_field_node(), params);
    case AnyResolvedExprProto::kResolvedFilterFieldNode:
      return ResolvedFilterField::RestoreFrom(
          proto.resolved_filter_field_node(), params);
    case AnyResolvedExprProto::kResolvedLetExprNode:
      return ResolvedLetExpr::RestoreFrom(
          proto.resolved_let_expr_node(), params);
  case AnyResolvedExprProto::NODE_NOT_SET:
    return ::zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
        << "No subnode types set in ResolvedExprProto";
  }
}

void ResolvedExpr::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedExpr::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedExpr::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedExpr(this);
}

absl::Status ResolvedExpr::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedExpr::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(type_)) {
    fields->emplace_back("type", ToStringImpl(type_));
  }
  if (!IsDefaultValue(type_annotation_map_)) {
    fields->emplace_back("type_annotation_map", ToStringImpl(type_annotation_map_));
  }
}

absl::Status ResolvedExpr::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  return absl::OkStatus();
}

absl::Status ResolvedExpr::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  return absl::OkStatus();
}

void ResolvedExpr::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedExpr::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedLiteral::TYPE;

ResolvedLiteral::~ResolvedLiteral() {
}

absl::Status ResolvedLiteral::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_literal_node());
}

absl::Status ResolvedLiteral::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedLiteralProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      value_, file_descriptor_set_map,
      proto->mutable_value()));
  proto->set_has_explicit_type(has_explicit_type_);
  proto->set_float_literal_id(float_literal_id_);
  proto->set_preserve_in_literal_remover(preserve_in_literal_remover_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedLiteral>> ResolvedLiteral::RestoreFrom(
    const ResolvedLiteralProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto value,
                   RestoreFromImpl<Value>(
                       proto.value(),
                       params));
  bool has_explicit_type =
      proto.has_explicit_type();
  int float_literal_id =
      proto.float_literal_id();
  bool preserve_in_literal_remover =
      proto.preserve_in_literal_remover();
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedLiteral(
      std::move(type),
      std::move(value),
      std::move(has_explicit_type),
      std::move(float_literal_id));

  node->set_type_annotation_map(std::move(type_annotation_map));
  node->set_preserve_in_literal_remover(std::move(preserve_in_literal_remover));
  return node;
}

void ResolvedLiteral::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedLiteral::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedLiteral::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedLiteral(this);
}

absl::Status ResolvedLiteral::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedLiteral::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("value", ToStringImpl(value_));
  }
  if (!IsDefaultValue(has_explicit_type_)) {
    fields->emplace_back("has_explicit_type", ToStringImpl(has_explicit_type_));
  }
  if (!IsDefaultValue(float_literal_id_)) {
    fields->emplace_back("float_literal_id", ToStringImpl(float_literal_id_));
  }
  if (!IsDefaultValue(preserve_in_literal_remover_)) {
    fields->emplace_back("preserve_in_literal_remover", ToStringImpl(preserve_in_literal_remover_));
  }
}

absl::Status ResolvedLiteral::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedLiteral::value not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedLiteral::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedLiteral::value is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedLiteral::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedLiteral::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedParameter::TYPE;

ResolvedParameter::~ResolvedParameter() {
}

absl::Status ResolvedParameter::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_parameter_node());
}

absl::Status ResolvedParameter::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedParameterProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_name(name_);
  proto->set_position(position_);
  proto->set_is_untyped(is_untyped_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedParameter>> ResolvedParameter::RestoreFrom(
    const ResolvedParameterProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string name =
      proto.name();
  int position =
      proto.position();
  bool is_untyped =
      proto.is_untyped();
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedParameter(
      std::move(type),
      std::move(name),
      std::move(position),
      std::move(is_untyped));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

void ResolvedParameter::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedParameter::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedParameter::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedParameter(this);
}

absl::Status ResolvedParameter::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedParameter::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(name_)) {
    fields->emplace_back("name", ToStringImpl(name_));
  }
  if (!IsDefaultValue(position_)) {
    fields->emplace_back("position", ToStringImpl(position_));
  }
  if (!IsDefaultValue(is_untyped_)) {
    fields->emplace_back("is_untyped", ToStringImpl(is_untyped_));
  }
}

absl::Status ResolvedParameter::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(name_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedParameter::name not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(position_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedParameter::position not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedParameter::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedParameter::name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedParameter::position is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedParameter::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedParameter::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedExpressionColumn::TYPE;

ResolvedExpressionColumn::~ResolvedExpressionColumn() {
}

absl::Status ResolvedExpressionColumn::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_expression_column_node());
}

absl::Status ResolvedExpressionColumn::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedExpressionColumnProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_name(name_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedExpressionColumn>> ResolvedExpressionColumn::RestoreFrom(
    const ResolvedExpressionColumnProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string name =
      proto.name();
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedExpressionColumn(
      std::move(type),
      std::move(name));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

void ResolvedExpressionColumn::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedExpressionColumn::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedExpressionColumn::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedExpressionColumn(this);
}

absl::Status ResolvedExpressionColumn::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedExpressionColumn::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("name", ToStringImpl(name_));
  }
}

absl::Status ResolvedExpressionColumn::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedExpressionColumn::name not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedExpressionColumn::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedExpressionColumn::name is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedExpressionColumn::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedExpressionColumn::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedColumnRef::TYPE;

ResolvedColumnRef::~ResolvedColumnRef() {
}

absl::Status ResolvedColumnRef::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_column_ref_node());
}

absl::Status ResolvedColumnRef::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedColumnRefProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      column_, file_descriptor_set_map,
      proto->mutable_column()));
  proto->set_is_correlated(is_correlated_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedColumnRef>> ResolvedColumnRef::RestoreFrom(
    const ResolvedColumnRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto column,
                   RestoreFromImpl<ResolvedColumn>(
                       proto.column(),
                       params));
  bool is_correlated =
      proto.is_correlated();
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedColumnRef(
      std::move(type),
      std::move(column),
      std::move(is_correlated));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

void ResolvedColumnRef::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedColumnRef::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedColumnRef::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedColumnRef(this);
}

absl::Status ResolvedColumnRef::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedColumnRef::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("column", ToStringImpl(column_));
  }
  if (!IsDefaultValue(is_correlated_)) {
    fields->emplace_back("is_correlated", ToStringImpl(is_correlated_));
  }
}

absl::Status ResolvedColumnRef::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedColumnRef::column not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedColumnRef::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedColumnRef::column is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedColumnRef::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedColumnRef::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedConstant::TYPE;

ResolvedConstant::~ResolvedConstant() {
}

absl::Status ResolvedConstant::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_constant_node());
}

absl::Status ResolvedConstant::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedConstantProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      constant_, file_descriptor_set_map,
      proto->mutable_constant()));
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedConstant>> ResolvedConstant::RestoreFrom(
    const ResolvedConstantProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto constant,
                   RestoreFromImpl<const Constant*>(
                       proto.constant(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedConstant(
      std::move(type),
      std::move(constant));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

void ResolvedConstant::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedConstant::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedConstant::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedConstant(this);
}

absl::Status ResolvedConstant::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

absl::Status ResolvedConstant::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedConstant::constant not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedConstant::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedConstant::constant is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedConstant::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedConstant::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedSystemVariable::TYPE;

ResolvedSystemVariable::~ResolvedSystemVariable() {
}

absl::Status ResolvedSystemVariable::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_system_variable_node());
}

absl::Status ResolvedSystemVariable::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedSystemVariableProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedSystemVariable>> ResolvedSystemVariable::RestoreFrom(
    const ResolvedSystemVariableProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::string> name_path;
  for (const auto& elem : proto.name_path()) {
    name_path.push_back(elem);
  }
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedSystemVariable(
      std::move(type),
      std::move(name_path));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

void ResolvedSystemVariable::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedSystemVariable::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedSystemVariable::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedSystemVariable(this);
}

absl::Status ResolvedSystemVariable::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

absl::Status ResolvedSystemVariable::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSystemVariable::name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedSystemVariable::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSystemVariable::name_path is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedSystemVariable::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedSystemVariable::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedInlineLambda::TYPE;

ResolvedInlineLambda::~ResolvedInlineLambda() {
}

absl::Status ResolvedInlineLambda::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_inline_lambda_node());
}

absl::Status ResolvedInlineLambda::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedInlineLambdaProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : argument_list_) {
    ZETASQL_RETURN_IF_ERROR(SaveToImpl(
        elem, file_descriptor_set_map, proto->add_argument_list()));
  }
  for (const auto& elem : parameter_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_parameter_list()));
  }
  if (body_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(body_->SaveTo(
        file_descriptor_set_map, proto->mutable_body()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedInlineLambda>> ResolvedInlineLambda::RestoreFrom(
    const ResolvedInlineLambdaProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<ResolvedColumn> argument_list;
  for (const auto& elem : proto.argument_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    argument_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedColumnRef>> parameter_list;
  for (const auto& elem : proto.parameter_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedColumnRef> elem_restored,
                     ResolvedColumnRef::RestoreFrom(elem, params));
    parameter_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedExpr> body;
  if (proto.
  has_body()) {
    ZETASQL_ASSIGN_OR_RETURN(body,
                     ResolvedExpr::RestoreFrom(
                         proto.body(), params));
  }
  auto node = MakeResolvedInlineLambda(
      std::move(argument_list),
      std::move(parameter_list),
      std::move(body));

  return node;
}

void ResolvedInlineLambda::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : parameter_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (body_ != nullptr) {
    child_nodes->emplace_back(body_.get());
  }
}

void ResolvedInlineLambda::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : parameter_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (body_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &body_));
    static_assert(sizeof(body_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedInlineLambda::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedInlineLambda(this);
}

absl::Status ResolvedInlineLambda::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : parameter_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (body_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(body_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedInlineLambda::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("argument_list", ToStringImpl(argument_list_));
  }
  if (!parameter_list_.empty()) {
    fields->emplace_back("parameter_list", parameter_list_);
  }
  if (body_ != nullptr) {
    fields->emplace_back("body", body_.get());
  }
}

absl::Status ResolvedInlineLambda::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedInlineLambda::argument_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedInlineLambda::parameter_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedInlineLambda::body not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : parameter_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (body_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          body_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedInlineLambda::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedInlineLambda::argument_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedInlineLambda::parameter_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedInlineLambda::body is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : parameter_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (body_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(body_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedInlineLambda::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : parameter_list_) it->ClearFieldsAccessed();
  if (body_ != nullptr) body_->ClearFieldsAccessed();
}

void ResolvedInlineLambda::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : parameter_list_) it->MarkFieldsAccessed();
  if (body_ != nullptr) body_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedFilterFieldArg::TYPE;

ResolvedFilterFieldArg::~ResolvedFilterFieldArg() {
}

absl::Status ResolvedFilterFieldArg::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_filter_field_arg_node());
}

absl::Status ResolvedFilterFieldArg::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedFilterFieldArgProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_include(include_);
  for (const auto& elem : field_descriptor_path_) {
    ZETASQL_RETURN_IF_ERROR(SaveToImpl(
        elem, file_descriptor_set_map, proto->add_field_descriptor_path()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedFilterFieldArg>> ResolvedFilterFieldArg::RestoreFrom(
    const ResolvedFilterFieldArgProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool include =
      proto.include();
  std::vector<const google::protobuf::FieldDescriptor*> field_descriptor_path;
  for (const auto& elem : proto.field_descriptor_path()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<const google::protobuf::FieldDescriptor*>::value_type>(elem, params));
    field_descriptor_path.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedFilterFieldArg(
      std::move(include),
      std::move(field_descriptor_path));

  return node;
}

void ResolvedFilterFieldArg::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedFilterFieldArg::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedFilterFieldArg::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedFilterFieldArg(this);
}

absl::Status ResolvedFilterFieldArg::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedFilterFieldArg::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("include", ToStringImpl(include_));
  }
  {
    fields->emplace_back("field_descriptor_path", ToStringVectorFieldDescriptor(field_descriptor_path_));
  }
}

absl::Status ResolvedFilterFieldArg::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFilterFieldArg::include not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFilterFieldArg::field_descriptor_path not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedFilterFieldArg::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFilterFieldArg::include is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFilterFieldArg::field_descriptor_path is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedFilterFieldArg::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedFilterFieldArg::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedFilterField::TYPE;

ResolvedFilterField::~ResolvedFilterField() {
}

absl::Status ResolvedFilterField::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_filter_field_node());
}

absl::Status ResolvedFilterField::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedFilterFieldProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_expr()));
  }
  for (const auto& elem : filter_field_arg_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_filter_field_arg_list()));
  }
  proto->set_reset_cleared_required_fields(reset_cleared_required_fields_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedFilterField>> ResolvedFilterField::RestoreFrom(
    const ResolvedFilterFieldProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> expr;
  if (proto.
  has_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(expr,
                     ResolvedExpr::RestoreFrom(
                         proto.expr(), params));
  }
  std::vector<std::unique_ptr<const ResolvedFilterFieldArg>> filter_field_arg_list;
  for (const auto& elem : proto.filter_field_arg_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedFilterFieldArg> elem_restored,
                     ResolvedFilterFieldArg::RestoreFrom(elem, params));
    filter_field_arg_list.push_back(std::move(elem_restored));
  }
  bool reset_cleared_required_fields =
      proto.reset_cleared_required_fields();
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedFilterField(
      std::move(type),
      std::move(expr),
      std::move(filter_field_arg_list),
      std::move(reset_cleared_required_fields));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

void ResolvedFilterField::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expr_ != nullptr) {
    child_nodes->emplace_back(expr_.get());
  }
  for (const auto& elem : filter_field_arg_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedFilterField::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expr_));
    static_assert(sizeof(expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : filter_field_arg_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedFilterField::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedFilterField(this);
}

absl::Status ResolvedFilterField::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_.get()->Accept(visitor));
  }
  for (const auto& elem : filter_field_arg_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedFilterField::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (expr_ != nullptr) {
    fields->emplace_back("expr", expr_.get());
  }
  if (!filter_field_arg_list_.empty()) {
    fields->emplace_back("filter_field_arg_list", filter_field_arg_list_);
  }
  {
    fields->emplace_back("reset_cleared_required_fields", ToStringImpl(reset_cleared_required_fields_));
  }
}

absl::Status ResolvedFilterField::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFilterField::expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFilterField::filter_field_arg_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFilterField::reset_cleared_required_fields not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expr_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : filter_field_arg_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedFilterField::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFilterField::expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFilterField::filter_field_arg_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFilterField::reset_cleared_required_fields is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expr_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : filter_field_arg_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedFilterField::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expr_ != nullptr) expr_->ClearFieldsAccessed();
  for (const auto& it : filter_field_arg_list_) it->ClearFieldsAccessed();
}

void ResolvedFilterField::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expr_ != nullptr) expr_->MarkFieldsAccessed();
  for (const auto& it : filter_field_arg_list_) it->MarkFieldsAccessed();
}

const ResolvedFunctionCallBase::ErrorMode ResolvedFunctionCallBase::DEFAULT_ERROR_MODE;
const ResolvedFunctionCallBase::ErrorMode ResolvedFunctionCallBase::SAFE_ERROR_MODE;

ResolvedFunctionCallBase::~ResolvedFunctionCallBase() {
}

absl::Status ResolvedFunctionCallBase::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_function_call_base_node());
}

absl::Status ResolvedFunctionCallBase::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedFunctionCallBaseProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      function_, file_descriptor_set_map,
      proto->mutable_function()));
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      signature_, file_descriptor_set_map,
      proto->mutable_signature()));
  for (const auto& elem : argument_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_argument_list()));
  }
  for (const auto& elem : generic_argument_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_generic_argument_list()));
  }
  proto->set_error_mode(error_mode_);
  for (const auto& elem : hint_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_hint_list()));
  }
  for (const auto& elem : collation_list_) {
    ZETASQL_RETURN_IF_ERROR(SaveToImpl(
        elem, file_descriptor_set_map, proto->add_collation_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedFunctionCallBase>> ResolvedFunctionCallBase::RestoreFrom(
    const AnyResolvedFunctionCallBaseProto& proto,
    const ResolvedNode::RestoreParams& params) {
  switch (proto.node_case()) {
    case AnyResolvedFunctionCallBaseProto::kResolvedFunctionCallNode:
      return ResolvedFunctionCall::RestoreFrom(
          proto.resolved_function_call_node(), params);
    case AnyResolvedFunctionCallBaseProto::kResolvedNonScalarFunctionCallBaseNode:
      return ResolvedNonScalarFunctionCallBase::RestoreFrom(
          proto.resolved_non_scalar_function_call_base_node(), params);
  case AnyResolvedFunctionCallBaseProto::NODE_NOT_SET:
    return ::zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
        << "No subnode types set in ResolvedFunctionCallBaseProto";
  }
}

void ResolvedFunctionCallBase::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : argument_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : generic_argument_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : hint_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedFunctionCallBase::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : argument_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : generic_argument_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : hint_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedFunctionCallBase::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedFunctionCallBase(this);
}

absl::Status ResolvedFunctionCallBase::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : argument_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : generic_argument_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : hint_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

absl::Status ResolvedFunctionCallBase::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFunctionCallBase::function not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(argument_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFunctionCallBase::argument_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(generic_argument_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFunctionCallBase::generic_argument_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(error_mode_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFunctionCallBase::error_mode not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<6)) == 0 &&
      !IsDefaultValue(collation_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFunctionCallBase::collation_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : argument_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : generic_argument_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : hint_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedFunctionCallBase::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFunctionCallBase::function is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFunctionCallBase::argument_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFunctionCallBase::generic_argument_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFunctionCallBase::error_mode is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<6)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFunctionCallBase::collation_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : argument_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : generic_argument_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : hint_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedFunctionCallBase::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : argument_list_) it->ClearFieldsAccessed();
  for (const auto& it : generic_argument_list_) it->ClearFieldsAccessed();
  for (const auto& it : hint_list_) it->ClearFieldsAccessed();
}

void ResolvedFunctionCallBase::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : argument_list_) it->MarkFieldsAccessed();
  for (const auto& it : generic_argument_list_) it->MarkFieldsAccessed();
  for (const auto& it : hint_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedFunctionCall::TYPE;

ResolvedFunctionCall::~ResolvedFunctionCall() {
}

absl::Status ResolvedFunctionCall::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedFunctionCallBaseProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_function_call_node());
}

absl::Status ResolvedFunctionCall::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedFunctionCallProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      function_call_info_, file_descriptor_set_map,
      proto->mutable_function_call_info()));
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedFunctionCall>> ResolvedFunctionCall::RestoreFrom(
    const ResolvedFunctionCallProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto function_call_info,
                   RestoreFromImpl<std::shared_ptr<ResolvedFunctionCallInfo>>(
                       proto.function_call_info(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().parent().type_annotation_map(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto function,
                   RestoreFromImpl<const Function*>(
                       proto.parent().function(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto signature,
                   RestoreFromImpl<FunctionSignature>(
                       proto.parent().signature(),
                       params));
  std::vector<std::unique_ptr<const ResolvedExpr>> argument_list;
  for (const auto& elem : proto.parent().argument_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    argument_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedFunctionArgument>> generic_argument_list;
  for (const auto& elem : proto.parent().generic_argument_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedFunctionArgument> elem_restored,
                     ResolvedFunctionArgument::RestoreFrom(elem, params));
    generic_argument_list.push_back(std::move(elem_restored));
  }
  ErrorMode error_mode =
      proto.parent().error_mode();
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<ResolvedCollation> collation_list;
  for (const auto& elem : proto.parent().collation_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedCollation>::value_type>(elem, params));
    collation_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedFunctionCall(
      std::move(type),
      std::move(function),
      std::move(signature),
      std::move(argument_list),
      std::move(generic_argument_list),
      std::move(error_mode),
      std::move(function_call_info));

  node->set_type_annotation_map(std::move(type_annotation_map));
  node->set_hint_list(std::move(hint_list));
  node->set_collation_list(std::move(collation_list));
  return node;
}

void ResolvedFunctionCall::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedFunctionCall::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedFunctionCall::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedFunctionCall(this);
}

absl::Status ResolvedFunctionCall::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedFunctionCall::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(function_call_info_)) {
    fields->emplace_back("function_call_info", ToStringImpl(function_call_info_));
  }
}

absl::Status ResolvedFunctionCall::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  return absl::OkStatus();
}

absl::Status ResolvedFunctionCall::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  return absl::OkStatus();
}

void ResolvedFunctionCall::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedFunctionCall::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNonScalarFunctionCallBase::NullHandlingModifier ResolvedNonScalarFunctionCallBase::DEFAULT_NULL_HANDLING;
const ResolvedNonScalarFunctionCallBase::NullHandlingModifier ResolvedNonScalarFunctionCallBase::IGNORE_NULLS;
const ResolvedNonScalarFunctionCallBase::NullHandlingModifier ResolvedNonScalarFunctionCallBase::RESPECT_NULLS;

ResolvedNonScalarFunctionCallBase::~ResolvedNonScalarFunctionCallBase() {
}

absl::Status ResolvedNonScalarFunctionCallBase::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedFunctionCallBaseProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_non_scalar_function_call_base_node());
}

absl::Status ResolvedNonScalarFunctionCallBase::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedNonScalarFunctionCallBaseProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_distinct(distinct_);
  proto->set_null_handling_modifier(null_handling_modifier_);
  if (with_group_rows_subquery_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(with_group_rows_subquery_->SaveTo(
        file_descriptor_set_map, proto->mutable_with_group_rows_subquery()));
  }
  for (const auto& elem : with_group_rows_parameter_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_with_group_rows_parameter_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedNonScalarFunctionCallBase>> ResolvedNonScalarFunctionCallBase::RestoreFrom(
    const AnyResolvedNonScalarFunctionCallBaseProto& proto,
    const ResolvedNode::RestoreParams& params) {
  switch (proto.node_case()) {
    case AnyResolvedNonScalarFunctionCallBaseProto::kResolvedAggregateFunctionCallNode:
      return ResolvedAggregateFunctionCall::RestoreFrom(
          proto.resolved_aggregate_function_call_node(), params);
    case AnyResolvedNonScalarFunctionCallBaseProto::kResolvedAnalyticFunctionCallNode:
      return ResolvedAnalyticFunctionCall::RestoreFrom(
          proto.resolved_analytic_function_call_node(), params);
  case AnyResolvedNonScalarFunctionCallBaseProto::NODE_NOT_SET:
    return ::zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
        << "No subnode types set in ResolvedNonScalarFunctionCallBaseProto";
  }
}

void ResolvedNonScalarFunctionCallBase::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (with_group_rows_subquery_ != nullptr) {
    child_nodes->emplace_back(with_group_rows_subquery_.get());
  }
  for (const auto& elem : with_group_rows_parameter_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedNonScalarFunctionCallBase::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (with_group_rows_subquery_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &with_group_rows_subquery_));
    static_assert(sizeof(with_group_rows_subquery_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : with_group_rows_parameter_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedNonScalarFunctionCallBase::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedNonScalarFunctionCallBase(this);
}

absl::Status ResolvedNonScalarFunctionCallBase::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (with_group_rows_subquery_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(with_group_rows_subquery_.get()->Accept(visitor));
  }
  for (const auto& elem : with_group_rows_parameter_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedNonScalarFunctionCallBase::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(distinct_)) {
    fields->emplace_back("distinct", ToStringImpl(distinct_));
  }
  if (!IsDefaultValue(null_handling_modifier_)) {
    fields->emplace_back("null_handling_modifier", ToStringImpl(null_handling_modifier_));
  }
  if (with_group_rows_subquery_ != nullptr) {
    fields->emplace_back("with_group_rows_subquery", with_group_rows_subquery_.get());
  }
  if (!with_group_rows_parameter_list_.empty()) {
    fields->emplace_back("with_group_rows_parameter_list", with_group_rows_parameter_list_);
  }
}

absl::Status ResolvedNonScalarFunctionCallBase::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(distinct_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedNonScalarFunctionCallBase::distinct not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(null_handling_modifier_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedNonScalarFunctionCallBase::null_handling_modifier not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(with_group_rows_subquery_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedNonScalarFunctionCallBase::with_group_rows_subquery not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(with_group_rows_parameter_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedNonScalarFunctionCallBase::with_group_rows_parameter_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (with_group_rows_subquery_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          with_group_rows_subquery_.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : with_group_rows_parameter_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedNonScalarFunctionCallBase::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedNonScalarFunctionCallBase::distinct is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedNonScalarFunctionCallBase::null_handling_modifier is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedNonScalarFunctionCallBase::with_group_rows_subquery is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedNonScalarFunctionCallBase::with_group_rows_parameter_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (with_group_rows_subquery_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(with_group_rows_subquery_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : with_group_rows_parameter_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedNonScalarFunctionCallBase::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (with_group_rows_subquery_ != nullptr) with_group_rows_subquery_->ClearFieldsAccessed();
  for (const auto& it : with_group_rows_parameter_list_) it->ClearFieldsAccessed();
}

void ResolvedNonScalarFunctionCallBase::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (with_group_rows_subquery_ != nullptr) with_group_rows_subquery_->MarkFieldsAccessed();
  for (const auto& it : with_group_rows_parameter_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAggregateFunctionCall::TYPE;

ResolvedAggregateFunctionCall::~ResolvedAggregateFunctionCall() {
}

absl::Status ResolvedAggregateFunctionCall::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedNonScalarFunctionCallBaseProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_aggregate_function_call_node());
}

absl::Status ResolvedAggregateFunctionCall::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAggregateFunctionCallProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (having_modifier_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(having_modifier_->SaveTo(
        file_descriptor_set_map, proto->mutable_having_modifier()));
  }
  for (const auto& elem : order_by_item_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_order_by_item_list()));
  }
  if (limit_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(limit_->SaveTo(
        file_descriptor_set_map, proto->mutable_limit()));
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      function_call_info_, file_descriptor_set_map,
      proto->mutable_function_call_info()));
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAggregateFunctionCall>> ResolvedAggregateFunctionCall::RestoreFrom(
    const ResolvedAggregateFunctionCallProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedAggregateHavingModifier> having_modifier;
  if (proto.
  has_having_modifier()) {
    ZETASQL_ASSIGN_OR_RETURN(having_modifier,
                     ResolvedAggregateHavingModifier::RestoreFrom(
                         proto.having_modifier(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOrderByItem>> order_by_item_list;
  for (const auto& elem : proto.order_by_item_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOrderByItem> elem_restored,
                     ResolvedOrderByItem::RestoreFrom(elem, params));
    order_by_item_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedExpr> limit;
  if (proto.
  has_limit()) {
    ZETASQL_ASSIGN_OR_RETURN(limit,
                     ResolvedExpr::RestoreFrom(
                         proto.limit(), params));
  }
  ZETASQL_ASSIGN_OR_RETURN(auto function_call_info,
                   RestoreFromImpl<std::shared_ptr<ResolvedFunctionCallInfo>>(
                       proto.function_call_info(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().parent().parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().parent().parent().type_annotation_map(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto function,
                   RestoreFromImpl<const Function*>(
                       proto.parent().parent().function(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto signature,
                   RestoreFromImpl<FunctionSignature>(
                       proto.parent().parent().signature(),
                       params));
  std::vector<std::unique_ptr<const ResolvedExpr>> argument_list;
  for (const auto& elem : proto.parent().parent().argument_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    argument_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedFunctionArgument>> generic_argument_list;
  for (const auto& elem : proto.parent().parent().generic_argument_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedFunctionArgument> elem_restored,
                     ResolvedFunctionArgument::RestoreFrom(elem, params));
    generic_argument_list.push_back(std::move(elem_restored));
  }
  ErrorMode error_mode =
      proto.parent().parent().error_mode();
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<ResolvedCollation> collation_list;
  for (const auto& elem : proto.parent().parent().collation_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedCollation>::value_type>(elem, params));
    collation_list.push_back(std::move(elem_restored));
  }
  bool distinct =
      proto.parent().distinct();
  NullHandlingModifier null_handling_modifier =
      proto.parent().null_handling_modifier();
  std::unique_ptr<const ResolvedScan> with_group_rows_subquery;
  if (proto.parent().
  has_with_group_rows_subquery()) {
    ZETASQL_ASSIGN_OR_RETURN(with_group_rows_subquery,
                     ResolvedScan::RestoreFrom(
                         proto.parent().with_group_rows_subquery(), params));
  }
  std::vector<std::unique_ptr<const ResolvedColumnRef>> with_group_rows_parameter_list;
  for (const auto& elem : proto.parent().with_group_rows_parameter_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedColumnRef> elem_restored,
                     ResolvedColumnRef::RestoreFrom(elem, params));
    with_group_rows_parameter_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedAggregateFunctionCall(
      std::move(type),
      std::move(function),
      std::move(signature),
      std::move(argument_list),
      std::move(generic_argument_list),
      std::move(error_mode),
      std::move(distinct),
      std::move(null_handling_modifier),
      std::move(having_modifier),
      std::move(order_by_item_list),
      std::move(limit),
      std::move(function_call_info));

  node->set_type_annotation_map(std::move(type_annotation_map));
  node->set_hint_list(std::move(hint_list));
  node->set_collation_list(std::move(collation_list));
  node->set_with_group_rows_subquery(std::move(with_group_rows_subquery));
  node->set_with_group_rows_parameter_list(std::move(with_group_rows_parameter_list));
  return node;
}

void ResolvedAggregateFunctionCall::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (having_modifier_ != nullptr) {
    child_nodes->emplace_back(having_modifier_.get());
  }
  for (const auto& elem : order_by_item_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (limit_ != nullptr) {
    child_nodes->emplace_back(limit_.get());
  }
}

void ResolvedAggregateFunctionCall::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (having_modifier_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &having_modifier_));
    static_assert(sizeof(having_modifier_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : order_by_item_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (limit_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &limit_));
    static_assert(sizeof(limit_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedAggregateFunctionCall::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAggregateFunctionCall(this);
}

absl::Status ResolvedAggregateFunctionCall::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (having_modifier_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(having_modifier_.get()->Accept(visitor));
  }
  for (const auto& elem : order_by_item_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (limit_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(limit_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAggregateFunctionCall::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (having_modifier_ != nullptr) {
    fields->emplace_back("having_modifier", having_modifier_.get());
  }
  if (!order_by_item_list_.empty()) {
    fields->emplace_back("order_by_item_list", order_by_item_list_);
  }
  if (limit_ != nullptr) {
    fields->emplace_back("limit", limit_.get());
  }
  if (!IsDefaultValue(function_call_info_)) {
    fields->emplace_back("function_call_info", ToStringImpl(function_call_info_));
  }
}

absl::Status ResolvedAggregateFunctionCall::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(having_modifier_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAggregateFunctionCall::having_modifier not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(order_by_item_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAggregateFunctionCall::order_by_item_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(limit_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAggregateFunctionCall::limit not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (having_modifier_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          having_modifier_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : order_by_item_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (limit_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          limit_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAggregateFunctionCall::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAggregateFunctionCall::having_modifier is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAggregateFunctionCall::order_by_item_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAggregateFunctionCall::limit is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (having_modifier_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(having_modifier_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : order_by_item_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (limit_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(limit_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAggregateFunctionCall::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (having_modifier_ != nullptr) having_modifier_->ClearFieldsAccessed();
  for (const auto& it : order_by_item_list_) it->ClearFieldsAccessed();
  if (limit_ != nullptr) limit_->ClearFieldsAccessed();
}

void ResolvedAggregateFunctionCall::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (having_modifier_ != nullptr) having_modifier_->MarkFieldsAccessed();
  for (const auto& it : order_by_item_list_) it->MarkFieldsAccessed();
  if (limit_ != nullptr) limit_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAnalyticFunctionCall::TYPE;

ResolvedAnalyticFunctionCall::~ResolvedAnalyticFunctionCall() {
}

absl::Status ResolvedAnalyticFunctionCall::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedNonScalarFunctionCallBaseProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_analytic_function_call_node());
}

absl::Status ResolvedAnalyticFunctionCall::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAnalyticFunctionCallProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (window_frame_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(window_frame_->SaveTo(
        file_descriptor_set_map, proto->mutable_window_frame()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAnalyticFunctionCall>> ResolvedAnalyticFunctionCall::RestoreFrom(
    const ResolvedAnalyticFunctionCallProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedWindowFrame> window_frame;
  if (proto.
  has_window_frame()) {
    ZETASQL_ASSIGN_OR_RETURN(window_frame,
                     ResolvedWindowFrame::RestoreFrom(
                         proto.window_frame(), params));
  }
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().parent().parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().parent().parent().type_annotation_map(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto function,
                   RestoreFromImpl<const Function*>(
                       proto.parent().parent().function(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto signature,
                   RestoreFromImpl<FunctionSignature>(
                       proto.parent().parent().signature(),
                       params));
  std::vector<std::unique_ptr<const ResolvedExpr>> argument_list;
  for (const auto& elem : proto.parent().parent().argument_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    argument_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedFunctionArgument>> generic_argument_list;
  for (const auto& elem : proto.parent().parent().generic_argument_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedFunctionArgument> elem_restored,
                     ResolvedFunctionArgument::RestoreFrom(elem, params));
    generic_argument_list.push_back(std::move(elem_restored));
  }
  ErrorMode error_mode =
      proto.parent().parent().error_mode();
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<ResolvedCollation> collation_list;
  for (const auto& elem : proto.parent().parent().collation_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedCollation>::value_type>(elem, params));
    collation_list.push_back(std::move(elem_restored));
  }
  bool distinct =
      proto.parent().distinct();
  NullHandlingModifier null_handling_modifier =
      proto.parent().null_handling_modifier();
  std::unique_ptr<const ResolvedScan> with_group_rows_subquery;
  if (proto.parent().
  has_with_group_rows_subquery()) {
    ZETASQL_ASSIGN_OR_RETURN(with_group_rows_subquery,
                     ResolvedScan::RestoreFrom(
                         proto.parent().with_group_rows_subquery(), params));
  }
  std::vector<std::unique_ptr<const ResolvedColumnRef>> with_group_rows_parameter_list;
  for (const auto& elem : proto.parent().with_group_rows_parameter_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedColumnRef> elem_restored,
                     ResolvedColumnRef::RestoreFrom(elem, params));
    with_group_rows_parameter_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedAnalyticFunctionCall(
      std::move(type),
      std::move(function),
      std::move(signature),
      std::move(argument_list),
      std::move(generic_argument_list),
      std::move(error_mode),
      std::move(distinct),
      std::move(null_handling_modifier),
      std::move(window_frame));

  node->set_type_annotation_map(std::move(type_annotation_map));
  node->set_hint_list(std::move(hint_list));
  node->set_collation_list(std::move(collation_list));
  node->set_with_group_rows_subquery(std::move(with_group_rows_subquery));
  node->set_with_group_rows_parameter_list(std::move(with_group_rows_parameter_list));
  return node;
}

void ResolvedAnalyticFunctionCall::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (window_frame_ != nullptr) {
    child_nodes->emplace_back(window_frame_.get());
  }
}

void ResolvedAnalyticFunctionCall::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (window_frame_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &window_frame_));
    static_assert(sizeof(window_frame_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedAnalyticFunctionCall::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAnalyticFunctionCall(this);
}

absl::Status ResolvedAnalyticFunctionCall::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (window_frame_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(window_frame_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAnalyticFunctionCall::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (window_frame_ != nullptr) {
    fields->emplace_back("window_frame", window_frame_.get());
  }
}

absl::Status ResolvedAnalyticFunctionCall::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAnalyticFunctionCall::window_frame not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (window_frame_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          window_frame_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAnalyticFunctionCall::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAnalyticFunctionCall::window_frame is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (window_frame_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(window_frame_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAnalyticFunctionCall::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (window_frame_ != nullptr) window_frame_->ClearFieldsAccessed();
}

void ResolvedAnalyticFunctionCall::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (window_frame_ != nullptr) window_frame_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedExtendedCastElement::TYPE;

ResolvedExtendedCastElement::~ResolvedExtendedCastElement() {
}

absl::Status ResolvedExtendedCastElement::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_extended_cast_element_node());
}

absl::Status ResolvedExtendedCastElement::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedExtendedCastElementProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      from_type_, file_descriptor_set_map,
      proto->mutable_from_type()));
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      to_type_, file_descriptor_set_map,
      proto->mutable_to_type()));
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      function_, file_descriptor_set_map,
      proto->mutable_function()));
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedExtendedCastElement>> ResolvedExtendedCastElement::RestoreFrom(
    const ResolvedExtendedCastElementProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto from_type,
                   RestoreFromImpl<const Type*>(
                       proto.from_type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto to_type,
                   RestoreFromImpl<const Type*>(
                       proto.to_type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto function,
                   RestoreFromImpl<const Function*>(
                       proto.function(),
                       params));
  auto node = MakeResolvedExtendedCastElement(
      std::move(from_type),
      std::move(to_type),
      std::move(function));

  return node;
}

void ResolvedExtendedCastElement::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedExtendedCastElement::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedExtendedCastElement::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedExtendedCastElement(this);
}

absl::Status ResolvedExtendedCastElement::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

absl::Status ResolvedExtendedCastElement::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  return absl::OkStatus();
}

absl::Status ResolvedExtendedCastElement::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  return absl::OkStatus();
}

void ResolvedExtendedCastElement::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedExtendedCastElement::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedExtendedCast::TYPE;

ResolvedExtendedCast::~ResolvedExtendedCast() {
}

absl::Status ResolvedExtendedCast::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_extended_cast_node());
}

absl::Status ResolvedExtendedCast::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedExtendedCastProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : element_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_element_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedExtendedCast>> ResolvedExtendedCast::RestoreFrom(
    const ResolvedExtendedCastProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedExtendedCastElement>> element_list;
  for (const auto& elem : proto.element_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExtendedCastElement> elem_restored,
                     ResolvedExtendedCastElement::RestoreFrom(elem, params));
    element_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedExtendedCast(
      std::move(element_list));

  return node;
}

void ResolvedExtendedCast::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : element_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedExtendedCast::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : element_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedExtendedCast::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedExtendedCast(this);
}

absl::Status ResolvedExtendedCast::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : element_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedExtendedCast::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!element_list_.empty()) {
    fields->emplace_back("element_list", element_list_);
  }
}

absl::Status ResolvedExtendedCast::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedExtendedCast::element_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : element_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedExtendedCast::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedExtendedCast::element_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : element_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedExtendedCast::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : element_list_) it->ClearFieldsAccessed();
}

void ResolvedExtendedCast::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : element_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCast::TYPE;

ResolvedCast::~ResolvedCast() {
}

absl::Status ResolvedCast::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_cast_node());
}

absl::Status ResolvedCast::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCastProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_expr()));
  }
  proto->set_return_null_on_error(return_null_on_error_);
  if (extended_cast_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(extended_cast_->SaveTo(
        file_descriptor_set_map, proto->mutable_extended_cast()));
  }
  if (format_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(format_->SaveTo(
        file_descriptor_set_map, proto->mutable_format()));
  }
  if (time_zone_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(time_zone_->SaveTo(
        file_descriptor_set_map, proto->mutable_time_zone()));
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      type_parameters_, file_descriptor_set_map,
      proto->mutable_type_parameters()));
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCast>> ResolvedCast::RestoreFrom(
    const ResolvedCastProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> expr;
  if (proto.
  has_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(expr,
                     ResolvedExpr::RestoreFrom(
                         proto.expr(), params));
  }
  bool return_null_on_error =
      proto.return_null_on_error();
  std::unique_ptr<const ResolvedExtendedCast> extended_cast;
  if (proto.
  has_extended_cast()) {
    ZETASQL_ASSIGN_OR_RETURN(extended_cast,
                     ResolvedExtendedCast::RestoreFrom(
                         proto.extended_cast(), params));
  }
  std::unique_ptr<const ResolvedExpr> format;
  if (proto.
  has_format()) {
    ZETASQL_ASSIGN_OR_RETURN(format,
                     ResolvedExpr::RestoreFrom(
                         proto.format(), params));
  }
  std::unique_ptr<const ResolvedExpr> time_zone;
  if (proto.
  has_time_zone()) {
    ZETASQL_ASSIGN_OR_RETURN(time_zone,
                     ResolvedExpr::RestoreFrom(
                         proto.time_zone(), params));
  }
  ZETASQL_ASSIGN_OR_RETURN(auto type_parameters,
                   RestoreFromImpl<TypeParameters>(
                       proto.type_parameters(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedCast(
      std::move(type),
      std::move(expr),
      std::move(return_null_on_error),
      std::move(extended_cast),
      std::move(format),
      std::move(time_zone),
      std::move(type_parameters));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

void ResolvedCast::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expr_ != nullptr) {
    child_nodes->emplace_back(expr_.get());
  }
  if (extended_cast_ != nullptr) {
    child_nodes->emplace_back(extended_cast_.get());
  }
  if (format_ != nullptr) {
    child_nodes->emplace_back(format_.get());
  }
  if (time_zone_ != nullptr) {
    child_nodes->emplace_back(time_zone_.get());
  }
}

void ResolvedCast::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expr_));
    static_assert(sizeof(expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (extended_cast_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &extended_cast_));
    static_assert(sizeof(extended_cast_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (format_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &format_));
    static_assert(sizeof(format_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (time_zone_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &time_zone_));
    static_assert(sizeof(time_zone_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedCast::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCast(this);
}

absl::Status ResolvedCast::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_.get()->Accept(visitor));
  }
  if (extended_cast_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(extended_cast_.get()->Accept(visitor));
  }
  if (format_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(format_.get()->Accept(visitor));
  }
  if (time_zone_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(time_zone_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

absl::Status ResolvedCast::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCast::expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(return_null_on_error_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCast::return_null_on_error not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(format_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCast::format not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(time_zone_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCast::time_zone not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0 &&
      !IsDefaultValue(type_parameters_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCast::type_parameters not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expr_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (extended_cast_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          extended_cast_.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (format_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          format_.get(), root));
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (time_zone_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          time_zone_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCast::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCast::expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCast::return_null_on_error is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCast::format is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCast::time_zone is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCast::type_parameters is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expr_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (extended_cast_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(extended_cast_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (format_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(format_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (time_zone_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(time_zone_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCast::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expr_ != nullptr) expr_->ClearFieldsAccessed();
  if (extended_cast_ != nullptr) extended_cast_->ClearFieldsAccessed();
  if (format_ != nullptr) format_->ClearFieldsAccessed();
  if (time_zone_ != nullptr) time_zone_->ClearFieldsAccessed();
}

void ResolvedCast::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expr_ != nullptr) expr_->MarkFieldsAccessed();
  if (extended_cast_ != nullptr) extended_cast_->MarkFieldsAccessed();
  if (format_ != nullptr) format_->MarkFieldsAccessed();
  if (time_zone_ != nullptr) time_zone_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedMakeStruct::TYPE;

ResolvedMakeStruct::~ResolvedMakeStruct() {
}

absl::Status ResolvedMakeStruct::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_make_struct_node());
}

absl::Status ResolvedMakeStruct::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedMakeStructProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : field_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_field_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedMakeStruct>> ResolvedMakeStruct::RestoreFrom(
    const ResolvedMakeStructProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedExpr>> field_list;
  for (const auto& elem : proto.field_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    field_list.push_back(std::move(elem_restored));
  }
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedMakeStruct(
      std::move(type),
      std::move(field_list));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

void ResolvedMakeStruct::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : field_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedMakeStruct::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : field_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedMakeStruct::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedMakeStruct(this);
}

absl::Status ResolvedMakeStruct::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : field_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedMakeStruct::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!field_list_.empty()) {
    fields->emplace_back("field_list", field_list_);
  }
}

absl::Status ResolvedMakeStruct::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedMakeStruct::field_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : field_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedMakeStruct::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedMakeStruct::field_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : field_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedMakeStruct::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : field_list_) it->ClearFieldsAccessed();
}

void ResolvedMakeStruct::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : field_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedMakeProto::TYPE;

ResolvedMakeProto::~ResolvedMakeProto() {
}

absl::Status ResolvedMakeProto::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_make_proto_node());
}

absl::Status ResolvedMakeProto::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedMakeProtoProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : field_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_field_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedMakeProto>> ResolvedMakeProto::RestoreFrom(
    const ResolvedMakeProtoProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedMakeProtoField>> field_list;
  for (const auto& elem : proto.field_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedMakeProtoField> elem_restored,
                     ResolvedMakeProtoField::RestoreFrom(elem, params));
    field_list.push_back(std::move(elem_restored));
  }
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedMakeProto(
      std::move(type),
      std::move(field_list));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

void ResolvedMakeProto::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : field_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedMakeProto::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : field_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedMakeProto::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedMakeProto(this);
}

absl::Status ResolvedMakeProto::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : field_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedMakeProto::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!field_list_.empty()) {
    fields->emplace_back("field_list", field_list_);
  }
}

absl::Status ResolvedMakeProto::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedMakeProto::field_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : field_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedMakeProto::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedMakeProto::field_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : field_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedMakeProto::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : field_list_) it->ClearFieldsAccessed();
}

void ResolvedMakeProto::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : field_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedMakeProtoField::TYPE;

ResolvedMakeProtoField::~ResolvedMakeProtoField() {
}

absl::Status ResolvedMakeProtoField::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_make_proto_field_node());
}

absl::Status ResolvedMakeProtoField::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedMakeProtoFieldProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      field_descriptor_, file_descriptor_set_map,
      proto->mutable_field_descriptor()));
  proto->set_format(format_);
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_expr()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedMakeProtoField>> ResolvedMakeProtoField::RestoreFrom(
    const ResolvedMakeProtoFieldProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto field_descriptor,
                   RestoreFromImpl<const google::protobuf::FieldDescriptor*>(
                       proto.field_descriptor(),
                       params));
  FieldFormat::Format format =
      proto.format();
  std::unique_ptr<const ResolvedExpr> expr;
  if (proto.
  has_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(expr,
                     ResolvedExpr::RestoreFrom(
                         proto.expr(), params));
  }
  auto node = MakeResolvedMakeProtoField(
      std::move(field_descriptor),
      std::move(format),
      std::move(expr));

  return node;
}

void ResolvedMakeProtoField::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expr_ != nullptr) {
    child_nodes->emplace_back(expr_.get());
  }
}

void ResolvedMakeProtoField::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expr_));
    static_assert(sizeof(expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedMakeProtoField::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedMakeProtoField(this);
}

absl::Status ResolvedMakeProtoField::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

absl::Status ResolvedMakeProtoField::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedMakeProtoField::field_descriptor not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(format_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedMakeProtoField::format not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedMakeProtoField::expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedMakeProtoField::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedMakeProtoField::field_descriptor is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedMakeProtoField::format is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedMakeProtoField::expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedMakeProtoField::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expr_ != nullptr) expr_->ClearFieldsAccessed();
}

void ResolvedMakeProtoField::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expr_ != nullptr) expr_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedGetStructField::TYPE;

ResolvedGetStructField::~ResolvedGetStructField() {
}

absl::Status ResolvedGetStructField::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_get_struct_field_node());
}

absl::Status ResolvedGetStructField::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedGetStructFieldProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_expr()));
  }
  proto->set_field_idx(field_idx_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedGetStructField>> ResolvedGetStructField::RestoreFrom(
    const ResolvedGetStructFieldProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> expr;
  if (proto.
  has_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(expr,
                     ResolvedExpr::RestoreFrom(
                         proto.expr(), params));
  }
  int field_idx =
      proto.field_idx();
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedGetStructField(
      std::move(type),
      std::move(expr),
      std::move(field_idx));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

void ResolvedGetStructField::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expr_ != nullptr) {
    child_nodes->emplace_back(expr_.get());
  }
}

void ResolvedGetStructField::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expr_));
    static_assert(sizeof(expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedGetStructField::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedGetStructField(this);
}

absl::Status ResolvedGetStructField::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedGetStructField::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (expr_ != nullptr) {
    fields->emplace_back("expr", expr_.get());
  }
  {
    fields->emplace_back("field_idx", ToStringImpl(field_idx_));
  }
}

absl::Status ResolvedGetStructField::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGetStructField::expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGetStructField::field_idx not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedGetStructField::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGetStructField::expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGetStructField::field_idx is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedGetStructField::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expr_ != nullptr) expr_->ClearFieldsAccessed();
}

void ResolvedGetStructField::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expr_ != nullptr) expr_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedGetProtoField::TYPE;

ResolvedGetProtoField::~ResolvedGetProtoField() {
}

absl::Status ResolvedGetProtoField::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_get_proto_field_node());
}

absl::Status ResolvedGetProtoField::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedGetProtoFieldProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_expr()));
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      field_descriptor_, file_descriptor_set_map,
      proto->mutable_field_descriptor()));
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      default_value_, file_descriptor_set_map,
      proto->mutable_default_value()));
  proto->set_get_has_bit(get_has_bit_);
  proto->set_format(format_);
  proto->set_return_default_value_when_unset(return_default_value_when_unset_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedGetProtoField>> ResolvedGetProtoField::RestoreFrom(
    const ResolvedGetProtoFieldProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> expr;
  if (proto.
  has_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(expr,
                     ResolvedExpr::RestoreFrom(
                         proto.expr(), params));
  }
  ZETASQL_ASSIGN_OR_RETURN(auto field_descriptor,
                   RestoreFromImpl<const google::protobuf::FieldDescriptor*>(
                       proto.field_descriptor(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto default_value,
                   RestoreFromImpl<Value>(
                       proto.default_value(),
                       params));
  bool get_has_bit =
      proto.get_has_bit();
  FieldFormat::Format format =
      proto.format();
  bool return_default_value_when_unset =
      proto.return_default_value_when_unset();
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedGetProtoField(
      std::move(type),
      std::move(expr),
      std::move(field_descriptor),
      std::move(default_value),
      std::move(get_has_bit),
      std::move(format),
      std::move(return_default_value_when_unset));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

void ResolvedGetProtoField::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expr_ != nullptr) {
    child_nodes->emplace_back(expr_.get());
  }
}

void ResolvedGetProtoField::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expr_));
    static_assert(sizeof(expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedGetProtoField::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedGetProtoField(this);
}

absl::Status ResolvedGetProtoField::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedGetProtoField::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (expr_ != nullptr) {
    fields->emplace_back("expr", expr_.get());
  }
  {
    fields->emplace_back("field_descriptor", ToStringImpl(field_descriptor_));
  }
  if (!IsDefaultValue(default_value_)) {
    fields->emplace_back("default_value", ToStringImpl(default_value_));
  }
  if (!IsDefaultValue(get_has_bit_)) {
    fields->emplace_back("get_has_bit", ToStringImpl(get_has_bit_));
  }
  if (!IsDefaultValue(format_)) {
    fields->emplace_back("format", ToStringImpl(format_));
  }
  if (!IsDefaultValue(return_default_value_when_unset_)) {
    fields->emplace_back("return_default_value_when_unset", ToStringImpl(return_default_value_when_unset_));
  }
}

absl::Status ResolvedGetProtoField::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGetProtoField::expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGetProtoField::field_descriptor not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(get_has_bit_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGetProtoField::get_has_bit not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(format_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGetProtoField::format not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0 &&
      !IsDefaultValue(return_default_value_when_unset_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGetProtoField::return_default_value_when_unset not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedGetProtoField::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGetProtoField::expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGetProtoField::field_descriptor is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGetProtoField::get_has_bit is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGetProtoField::format is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGetProtoField::return_default_value_when_unset is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedGetProtoField::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expr_ != nullptr) expr_->ClearFieldsAccessed();
}

void ResolvedGetProtoField::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expr_ != nullptr) expr_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedGetJsonField::TYPE;

ResolvedGetJsonField::~ResolvedGetJsonField() {
}

absl::Status ResolvedGetJsonField::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_get_json_field_node());
}

absl::Status ResolvedGetJsonField::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedGetJsonFieldProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_expr()));
  }
  proto->set_field_name(field_name_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedGetJsonField>> ResolvedGetJsonField::RestoreFrom(
    const ResolvedGetJsonFieldProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> expr;
  if (proto.
  has_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(expr,
                     ResolvedExpr::RestoreFrom(
                         proto.expr(), params));
  }
  std::string field_name =
      proto.field_name();
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedGetJsonField(
      std::move(type),
      std::move(expr),
      std::move(field_name));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

void ResolvedGetJsonField::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expr_ != nullptr) {
    child_nodes->emplace_back(expr_.get());
  }
}

void ResolvedGetJsonField::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expr_));
    static_assert(sizeof(expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedGetJsonField::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedGetJsonField(this);
}

absl::Status ResolvedGetJsonField::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedGetJsonField::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (expr_ != nullptr) {
    fields->emplace_back("expr", expr_.get());
  }
  {
    fields->emplace_back("field_name", ToStringImpl(field_name_));
  }
}

absl::Status ResolvedGetJsonField::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGetJsonField::expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGetJsonField::field_name not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedGetJsonField::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGetJsonField::expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGetJsonField::field_name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedGetJsonField::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expr_ != nullptr) expr_->ClearFieldsAccessed();
}

void ResolvedGetJsonField::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expr_ != nullptr) expr_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedFlatten::TYPE;

ResolvedFlatten::~ResolvedFlatten() {
}

absl::Status ResolvedFlatten::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_flatten_node());
}

absl::Status ResolvedFlatten::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedFlattenProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_expr()));
  }
  for (const auto& elem : get_field_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_get_field_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedFlatten>> ResolvedFlatten::RestoreFrom(
    const ResolvedFlattenProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> expr;
  if (proto.
  has_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(expr,
                     ResolvedExpr::RestoreFrom(
                         proto.expr(), params));
  }
  std::vector<std::unique_ptr<const ResolvedExpr>> get_field_list;
  for (const auto& elem : proto.get_field_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    get_field_list.push_back(std::move(elem_restored));
  }
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedFlatten(
      std::move(type),
      std::move(expr),
      std::move(get_field_list));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

void ResolvedFlatten::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expr_ != nullptr) {
    child_nodes->emplace_back(expr_.get());
  }
  for (const auto& elem : get_field_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedFlatten::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expr_));
    static_assert(sizeof(expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : get_field_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedFlatten::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedFlatten(this);
}

absl::Status ResolvedFlatten::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_.get()->Accept(visitor));
  }
  for (const auto& elem : get_field_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedFlatten::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (expr_ != nullptr) {
    fields->emplace_back("expr", expr_.get());
  }
  if (!get_field_list_.empty()) {
    fields->emplace_back("get_field_list", get_field_list_);
  }
}

absl::Status ResolvedFlatten::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFlatten::expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFlatten::get_field_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expr_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : get_field_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedFlatten::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFlatten::expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFlatten::get_field_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expr_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : get_field_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedFlatten::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expr_ != nullptr) expr_->ClearFieldsAccessed();
  for (const auto& it : get_field_list_) it->ClearFieldsAccessed();
}

void ResolvedFlatten::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expr_ != nullptr) expr_->MarkFieldsAccessed();
  for (const auto& it : get_field_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedFlattenedArg::TYPE;

ResolvedFlattenedArg::~ResolvedFlattenedArg() {
}

absl::Status ResolvedFlattenedArg::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_flattened_arg_node());
}

absl::Status ResolvedFlattenedArg::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedFlattenedArgProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedFlattenedArg>> ResolvedFlattenedArg::RestoreFrom(
    const ResolvedFlattenedArgProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedFlattenedArg(
      std::move(type));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

absl::Status ResolvedFlattenedArg::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedFlattenedArg(this);
}

absl::Status ResolvedFlattenedArg::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

const ResolvedNodeKind ResolvedReplaceFieldItem::TYPE;

ResolvedReplaceFieldItem::~ResolvedReplaceFieldItem() {
}

absl::Status ResolvedReplaceFieldItem::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_replace_field_item_node());
}

absl::Status ResolvedReplaceFieldItem::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedReplaceFieldItemProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_expr()));
  }
  for (const auto& elem : struct_index_path_) {
    proto->add_struct_index_path(elem);
  }
  for (const auto& elem : proto_field_path_) {
    ZETASQL_RETURN_IF_ERROR(SaveToImpl(
        elem, file_descriptor_set_map, proto->add_proto_field_path()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedReplaceFieldItem>> ResolvedReplaceFieldItem::RestoreFrom(
    const ResolvedReplaceFieldItemProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> expr;
  if (proto.
  has_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(expr,
                     ResolvedExpr::RestoreFrom(
                         proto.expr(), params));
  }
  std::vector<int> struct_index_path;
  for (const auto& elem : proto.struct_index_path()) {
    struct_index_path.push_back(elem);
  }
  std::vector<const google::protobuf::FieldDescriptor*> proto_field_path;
  for (const auto& elem : proto.proto_field_path()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<const google::protobuf::FieldDescriptor*>::value_type>(elem, params));
    proto_field_path.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedReplaceFieldItem(
      std::move(expr),
      std::move(struct_index_path),
      std::move(proto_field_path));

  return node;
}

void ResolvedReplaceFieldItem::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expr_ != nullptr) {
    child_nodes->emplace_back(expr_.get());
  }
}

void ResolvedReplaceFieldItem::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expr_));
    static_assert(sizeof(expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedReplaceFieldItem::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedReplaceFieldItem(this);
}

absl::Status ResolvedReplaceFieldItem::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedReplaceFieldItem::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (expr_ != nullptr) {
    fields->emplace_back("expr", expr_.get());
  }
  if (!IsDefaultValue(struct_index_path_)) {
    fields->emplace_back("struct_index_path", ToStringCommaSeparated(struct_index_path_));
  }
  if (!IsDefaultValue(proto_field_path_)) {
    fields->emplace_back("proto_field_path", ToStringVectorFieldDescriptor(proto_field_path_));
  }
}

absl::Status ResolvedReplaceFieldItem::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedReplaceFieldItem::expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(struct_index_path_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedReplaceFieldItem::struct_index_path not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(proto_field_path_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedReplaceFieldItem::proto_field_path not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedReplaceFieldItem::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedReplaceFieldItem::expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedReplaceFieldItem::struct_index_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedReplaceFieldItem::proto_field_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedReplaceFieldItem::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expr_ != nullptr) expr_->ClearFieldsAccessed();
}

void ResolvedReplaceFieldItem::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expr_ != nullptr) expr_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedReplaceField::TYPE;

ResolvedReplaceField::~ResolvedReplaceField() {
}

absl::Status ResolvedReplaceField::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_replace_field_node());
}

absl::Status ResolvedReplaceField::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedReplaceFieldProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_expr()));
  }
  for (const auto& elem : replace_field_item_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_replace_field_item_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedReplaceField>> ResolvedReplaceField::RestoreFrom(
    const ResolvedReplaceFieldProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> expr;
  if (proto.
  has_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(expr,
                     ResolvedExpr::RestoreFrom(
                         proto.expr(), params));
  }
  std::vector<std::unique_ptr<const ResolvedReplaceFieldItem>> replace_field_item_list;
  for (const auto& elem : proto.replace_field_item_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedReplaceFieldItem> elem_restored,
                     ResolvedReplaceFieldItem::RestoreFrom(elem, params));
    replace_field_item_list.push_back(std::move(elem_restored));
  }
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedReplaceField(
      std::move(type),
      std::move(expr),
      std::move(replace_field_item_list));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

void ResolvedReplaceField::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expr_ != nullptr) {
    child_nodes->emplace_back(expr_.get());
  }
  for (const auto& elem : replace_field_item_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedReplaceField::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expr_));
    static_assert(sizeof(expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : replace_field_item_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedReplaceField::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedReplaceField(this);
}

absl::Status ResolvedReplaceField::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_.get()->Accept(visitor));
  }
  for (const auto& elem : replace_field_item_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedReplaceField::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (expr_ != nullptr) {
    fields->emplace_back("expr", expr_.get());
  }
  if (!replace_field_item_list_.empty()) {
    fields->emplace_back("replace_field_item_list", replace_field_item_list_);
  }
}

absl::Status ResolvedReplaceField::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedReplaceField::expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedReplaceField::replace_field_item_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expr_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : replace_field_item_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedReplaceField::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedReplaceField::expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedReplaceField::replace_field_item_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expr_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : replace_field_item_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedReplaceField::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expr_ != nullptr) expr_->ClearFieldsAccessed();
  for (const auto& it : replace_field_item_list_) it->ClearFieldsAccessed();
}

void ResolvedReplaceField::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expr_ != nullptr) expr_->MarkFieldsAccessed();
  for (const auto& it : replace_field_item_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedSubqueryExpr::TYPE;

const ResolvedSubqueryExpr::SubqueryType ResolvedSubqueryExpr::SCALAR;
const ResolvedSubqueryExpr::SubqueryType ResolvedSubqueryExpr::ARRAY;
const ResolvedSubqueryExpr::SubqueryType ResolvedSubqueryExpr::EXISTS;
const ResolvedSubqueryExpr::SubqueryType ResolvedSubqueryExpr::IN;
const ResolvedSubqueryExpr::SubqueryType ResolvedSubqueryExpr::LIKE_ANY;
const ResolvedSubqueryExpr::SubqueryType ResolvedSubqueryExpr::LIKE_ALL;

ResolvedSubqueryExpr::~ResolvedSubqueryExpr() {
}

absl::Status ResolvedSubqueryExpr::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_subquery_expr_node());
}

absl::Status ResolvedSubqueryExpr::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedSubqueryExprProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_subquery_type(subquery_type_);
  for (const auto& elem : parameter_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_parameter_list()));
  }
  if (in_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(in_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_in_expr()));
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      in_collation_, file_descriptor_set_map,
      proto->mutable_in_collation()));
  if (subquery_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(subquery_->SaveTo(
        file_descriptor_set_map, proto->mutable_subquery()));
  }
  for (const auto& elem : hint_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_hint_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedSubqueryExpr>> ResolvedSubqueryExpr::RestoreFrom(
    const ResolvedSubqueryExprProto& proto,
    const ResolvedNode::RestoreParams& params) {
  SubqueryType subquery_type =
      proto.subquery_type();
  std::vector<std::unique_ptr<const ResolvedColumnRef>> parameter_list;
  for (const auto& elem : proto.parameter_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedColumnRef> elem_restored,
                     ResolvedColumnRef::RestoreFrom(elem, params));
    parameter_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedExpr> in_expr;
  if (proto.
  has_in_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(in_expr,
                     ResolvedExpr::RestoreFrom(
                         proto.in_expr(), params));
  }
  ZETASQL_ASSIGN_OR_RETURN(auto in_collation,
                   RestoreFromImpl<ResolvedCollation>(
                       proto.in_collation(),
                       params));
  std::unique_ptr<const ResolvedScan> subquery;
  if (proto.
  has_subquery()) {
    ZETASQL_ASSIGN_OR_RETURN(subquery,
                     ResolvedScan::RestoreFrom(
                         proto.subquery(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedSubqueryExpr(
      std::move(type),
      std::move(subquery_type),
      std::move(parameter_list),
      std::move(in_expr),
      std::move(subquery));

  node->set_type_annotation_map(std::move(type_annotation_map));
  node->set_in_collation(std::move(in_collation));
  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedSubqueryExpr::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : parameter_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (in_expr_ != nullptr) {
    child_nodes->emplace_back(in_expr_.get());
  }
  if (subquery_ != nullptr) {
    child_nodes->emplace_back(subquery_.get());
  }
  for (const auto& elem : hint_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedSubqueryExpr::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : parameter_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (in_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &in_expr_));
    static_assert(sizeof(in_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (subquery_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &subquery_));
    static_assert(sizeof(subquery_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : hint_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedSubqueryExpr::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedSubqueryExpr(this);
}

absl::Status ResolvedSubqueryExpr::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : parameter_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (in_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(in_expr_.get()->Accept(visitor));
  }
  if (subquery_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(subquery_.get()->Accept(visitor));
  }
  for (const auto& elem : hint_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedSubqueryExpr::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("subquery_type", ToStringImpl(subquery_type_));
  }
  if (!parameter_list_.empty()) {
    fields->emplace_back("parameter_list", parameter_list_);
  }
  if (in_expr_ != nullptr) {
    fields->emplace_back("in_expr", in_expr_.get());
  }
  if (!IsDefaultValue(in_collation_)) {
    fields->emplace_back("in_collation", ToStringImpl(in_collation_));
  }
  if (subquery_ != nullptr) {
    fields->emplace_back("subquery", subquery_.get());
  }
  if (!hint_list_.empty()) {
    fields->emplace_back("hint_list", hint_list_);
  }
}

absl::Status ResolvedSubqueryExpr::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSubqueryExpr::subquery_type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(parameter_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSubqueryExpr::parameter_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(in_expr_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSubqueryExpr::in_expr not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(in_collation_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSubqueryExpr::in_collation not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSubqueryExpr::subquery not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : parameter_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (in_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          in_expr_.get(), root));
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (subquery_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          subquery_.get(), root));
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : hint_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedSubqueryExpr::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSubqueryExpr::subquery_type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSubqueryExpr::parameter_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSubqueryExpr::in_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSubqueryExpr::in_collation is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSubqueryExpr::subquery is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : parameter_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (in_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(in_expr_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (subquery_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(subquery_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : hint_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedSubqueryExpr::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : parameter_list_) it->ClearFieldsAccessed();
  if (in_expr_ != nullptr) in_expr_->ClearFieldsAccessed();
  if (subquery_ != nullptr) subquery_->ClearFieldsAccessed();
  for (const auto& it : hint_list_) it->ClearFieldsAccessed();
}

void ResolvedSubqueryExpr::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : parameter_list_) it->MarkFieldsAccessed();
  if (in_expr_ != nullptr) in_expr_->MarkFieldsAccessed();
  if (subquery_ != nullptr) subquery_->MarkFieldsAccessed();
  for (const auto& it : hint_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedLetExpr::TYPE;

ResolvedLetExpr::~ResolvedLetExpr() {
}

absl::Status ResolvedLetExpr::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_let_expr_node());
}

absl::Status ResolvedLetExpr::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedLetExprProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : assignment_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_assignment_list()));
  }
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_expr()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedLetExpr>> ResolvedLetExpr::RestoreFrom(
    const ResolvedLetExprProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedComputedColumn>> assignment_list;
  for (const auto& elem : proto.assignment_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedComputedColumn> elem_restored,
                     ResolvedComputedColumn::RestoreFrom(elem, params));
    assignment_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedExpr> expr;
  if (proto.
  has_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(expr,
                     ResolvedExpr::RestoreFrom(
                         proto.expr(), params));
  }
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedLetExpr(
      std::move(type),
      std::move(assignment_list),
      std::move(expr));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

void ResolvedLetExpr::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : assignment_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (expr_ != nullptr) {
    child_nodes->emplace_back(expr_.get());
  }
}

void ResolvedLetExpr::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : assignment_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expr_));
    static_assert(sizeof(expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedLetExpr::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedLetExpr(this);
}

absl::Status ResolvedLetExpr::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : assignment_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedLetExpr::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!assignment_list_.empty()) {
    fields->emplace_back("assignment_list", assignment_list_);
  }
  if (expr_ != nullptr) {
    fields->emplace_back("expr", expr_.get());
  }
}

absl::Status ResolvedLetExpr::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedLetExpr::assignment_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedLetExpr::expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : assignment_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedLetExpr::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedLetExpr::assignment_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedLetExpr::expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : assignment_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedLetExpr::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : assignment_list_) it->ClearFieldsAccessed();
  if (expr_ != nullptr) expr_->ClearFieldsAccessed();
}

void ResolvedLetExpr::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : assignment_list_) it->MarkFieldsAccessed();
  if (expr_ != nullptr) expr_->MarkFieldsAccessed();
}

ResolvedScan::~ResolvedScan() {
}

absl::Status ResolvedScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedNodeProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_scan_node());
}

absl::Status ResolvedScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : column_list_) {
    ZETASQL_RETURN_IF_ERROR(SaveToImpl(
        elem, file_descriptor_set_map, proto->add_column_list()));
  }
  for (const auto& elem : hint_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_hint_list()));
  }
  proto->set_is_ordered(is_ordered_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedScan>> ResolvedScan::RestoreFrom(
    const AnyResolvedScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  switch (proto.node_case()) {
    case AnyResolvedScanProto::kResolvedSingleRowScanNode:
      return ResolvedSingleRowScan::RestoreFrom(
          proto.resolved_single_row_scan_node(), params);
    case AnyResolvedScanProto::kResolvedTableScanNode:
      return ResolvedTableScan::RestoreFrom(
          proto.resolved_table_scan_node(), params);
    case AnyResolvedScanProto::kResolvedJoinScanNode:
      return ResolvedJoinScan::RestoreFrom(
          proto.resolved_join_scan_node(), params);
    case AnyResolvedScanProto::kResolvedArrayScanNode:
      return ResolvedArrayScan::RestoreFrom(
          proto.resolved_array_scan_node(), params);
    case AnyResolvedScanProto::kResolvedFilterScanNode:
      return ResolvedFilterScan::RestoreFrom(
          proto.resolved_filter_scan_node(), params);
    case AnyResolvedScanProto::kResolvedSetOperationScanNode:
      return ResolvedSetOperationScan::RestoreFrom(
          proto.resolved_set_operation_scan_node(), params);
    case AnyResolvedScanProto::kResolvedOrderByScanNode:
      return ResolvedOrderByScan::RestoreFrom(
          proto.resolved_order_by_scan_node(), params);
    case AnyResolvedScanProto::kResolvedLimitOffsetScanNode:
      return ResolvedLimitOffsetScan::RestoreFrom(
          proto.resolved_limit_offset_scan_node(), params);
    case AnyResolvedScanProto::kResolvedWithRefScanNode:
      return ResolvedWithRefScan::RestoreFrom(
          proto.resolved_with_ref_scan_node(), params);
    case AnyResolvedScanProto::kResolvedAnalyticScanNode:
      return ResolvedAnalyticScan::RestoreFrom(
          proto.resolved_analytic_scan_node(), params);
    case AnyResolvedScanProto::kResolvedSampleScanNode:
      return ResolvedSampleScan::RestoreFrom(
          proto.resolved_sample_scan_node(), params);
    case AnyResolvedScanProto::kResolvedProjectScanNode:
      return ResolvedProjectScan::RestoreFrom(
          proto.resolved_project_scan_node(), params);
    case AnyResolvedScanProto::kResolvedWithScanNode:
      return ResolvedWithScan::RestoreFrom(
          proto.resolved_with_scan_node(), params);
    case AnyResolvedScanProto::kResolvedTvfscanNode:
      return ResolvedTVFScan::RestoreFrom(
          proto.resolved_tvfscan_node(), params);
    case AnyResolvedScanProto::kResolvedRelationArgumentScanNode:
      return ResolvedRelationArgumentScan::RestoreFrom(
          proto.resolved_relation_argument_scan_node(), params);
    case AnyResolvedScanProto::kResolvedAggregateScanBaseNode:
      return ResolvedAggregateScanBase::RestoreFrom(
          proto.resolved_aggregate_scan_base_node(), params);
    case AnyResolvedScanProto::kResolvedRecursiveRefScanNode:
      return ResolvedRecursiveRefScan::RestoreFrom(
          proto.resolved_recursive_ref_scan_node(), params);
    case AnyResolvedScanProto::kResolvedRecursiveScanNode:
      return ResolvedRecursiveScan::RestoreFrom(
          proto.resolved_recursive_scan_node(), params);
    case AnyResolvedScanProto::kResolvedPivotScanNode:
      return ResolvedPivotScan::RestoreFrom(
          proto.resolved_pivot_scan_node(), params);
    case AnyResolvedScanProto::kResolvedUnpivotScanNode:
      return ResolvedUnpivotScan::RestoreFrom(
          proto.resolved_unpivot_scan_node(), params);
    case AnyResolvedScanProto::kResolvedGroupRowsScanNode:
      return ResolvedGroupRowsScan::RestoreFrom(
          proto.resolved_group_rows_scan_node(), params);
  case AnyResolvedScanProto::NODE_NOT_SET:
    return ::zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
        << "No subnode types set in ResolvedScanProto";
  }
}

void ResolvedScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : hint_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : hint_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedScan(this);
}

absl::Status ResolvedScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : hint_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(column_list_)) {
    fields->emplace_back("column_list", ToStringImpl(column_list_));
  }
  if (!hint_list_.empty()) {
    fields->emplace_back("hint_list", hint_list_);
  }
  if (!IsDefaultValue(is_ordered_)) {
    fields->emplace_back("is_ordered", ToStringImpl(is_ordered_));
  }
}

absl::Status ResolvedScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : hint_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : hint_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : hint_list_) it->ClearFieldsAccessed();
}

void ResolvedScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : hint_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedModel::TYPE;

ResolvedModel::~ResolvedModel() {
}

absl::Status ResolvedModel::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_model_node());
}

absl::Status ResolvedModel::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedModelProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      model_, file_descriptor_set_map,
      proto->mutable_model()));
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedModel>> ResolvedModel::RestoreFrom(
    const ResolvedModelProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto model,
                   RestoreFromImpl<const Model*>(
                       proto.model(),
                       params));
  auto node = MakeResolvedModel(
      std::move(model));

  return node;
}

void ResolvedModel::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedModel::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedModel::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedModel(this);
}

absl::Status ResolvedModel::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedModel::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("model", ToStringImpl(model_));
  }
}

absl::Status ResolvedModel::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedModel::model not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedModel::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedModel::model is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedModel::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedModel::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedConnection::TYPE;

ResolvedConnection::~ResolvedConnection() {
}

absl::Status ResolvedConnection::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_connection_node());
}

absl::Status ResolvedConnection::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedConnectionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      connection_, file_descriptor_set_map,
      proto->mutable_connection()));
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedConnection>> ResolvedConnection::RestoreFrom(
    const ResolvedConnectionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto connection,
                   RestoreFromImpl<const Connection*>(
                       proto.connection(),
                       params));
  auto node = MakeResolvedConnection(
      std::move(connection));

  return node;
}

void ResolvedConnection::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedConnection::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedConnection::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedConnection(this);
}

absl::Status ResolvedConnection::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedConnection::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("connection", ToStringImpl(connection_));
  }
}

absl::Status ResolvedConnection::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedConnection::connection not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedConnection::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedConnection::connection is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedConnection::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedConnection::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedDescriptor::TYPE;

ResolvedDescriptor::~ResolvedDescriptor() {
}

absl::Status ResolvedDescriptor::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_descriptor_node());
}

absl::Status ResolvedDescriptor::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedDescriptorProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : descriptor_column_list_) {
    ZETASQL_RETURN_IF_ERROR(SaveToImpl(
        elem, file_descriptor_set_map, proto->add_descriptor_column_list()));
  }
  for (const auto& elem : descriptor_column_name_list_) {
    proto->add_descriptor_column_name_list(elem);
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedDescriptor>> ResolvedDescriptor::RestoreFrom(
    const ResolvedDescriptorProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<ResolvedColumn> descriptor_column_list;
  for (const auto& elem : proto.descriptor_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    descriptor_column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> descriptor_column_name_list;
  for (const auto& elem : proto.descriptor_column_name_list()) {
    descriptor_column_name_list.push_back(elem);
  }
  auto node = MakeResolvedDescriptor(
      std::move(descriptor_column_list),
      std::move(descriptor_column_name_list));

  return node;
}

void ResolvedDescriptor::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedDescriptor::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedDescriptor::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedDescriptor(this);
}

absl::Status ResolvedDescriptor::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedDescriptor::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(descriptor_column_list_)) {
    fields->emplace_back("descriptor_column_list", ToStringImpl(descriptor_column_list_));
  }
  if (!IsDefaultValue(descriptor_column_name_list_)) {
    fields->emplace_back("descriptor_column_name_list", ToStringCommaSeparated(descriptor_column_name_list_));
  }
}

absl::Status ResolvedDescriptor::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(descriptor_column_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDescriptor::descriptor_column_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(descriptor_column_name_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDescriptor::descriptor_column_name_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedDescriptor::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDescriptor::descriptor_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDescriptor::descriptor_column_name_list is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedDescriptor::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedDescriptor::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedSingleRowScan::TYPE;

ResolvedSingleRowScan::~ResolvedSingleRowScan() {
}

absl::Status ResolvedSingleRowScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_single_row_scan_node());
}

absl::Status ResolvedSingleRowScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedSingleRowScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedSingleRowScan>> ResolvedSingleRowScan::RestoreFrom(
    const ResolvedSingleRowScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedSingleRowScan(
      std::move(column_list));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

absl::Status ResolvedSingleRowScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedSingleRowScan(this);
}

absl::Status ResolvedSingleRowScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

const ResolvedNodeKind ResolvedTableScan::TYPE;

ResolvedTableScan::~ResolvedTableScan() {
}

absl::Status ResolvedTableScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_table_scan_node());
}

absl::Status ResolvedTableScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedTableScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      table_, file_descriptor_set_map,
      proto->mutable_table()));
  if (for_system_time_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(for_system_time_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_for_system_time_expr()));
  }
  for (const auto& elem : column_index_list_) {
    proto->add_column_index_list(elem);
  }
  proto->set_alias(alias_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedTableScan>> ResolvedTableScan::RestoreFrom(
    const ResolvedTableScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto table,
                   RestoreFromImpl<const Table*>(
                       proto.table(),
                       params));
  std::unique_ptr<const ResolvedExpr> for_system_time_expr;
  if (proto.
  has_for_system_time_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(for_system_time_expr,
                     ResolvedExpr::RestoreFrom(
                         proto.for_system_time_expr(), params));
  }
  std::vector<int> column_index_list;
  for (const auto& elem : proto.column_index_list()) {
    column_index_list.push_back(elem);
  }
  std::string alias =
      proto.alias();
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedTableScan(
      std::move(column_list),
      std::move(table),
      std::move(for_system_time_expr),
      std::move(alias));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  node->set_column_index_list(std::move(column_index_list));
  return node;
}

void ResolvedTableScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (for_system_time_expr_ != nullptr) {
    child_nodes->emplace_back(for_system_time_expr_.get());
  }
}

void ResolvedTableScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (for_system_time_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &for_system_time_expr_));
    static_assert(sizeof(for_system_time_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedTableScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedTableScan(this);
}

absl::Status ResolvedTableScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (for_system_time_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(for_system_time_expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedTableScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("table", ToStringImpl(table_));
  }
  if (for_system_time_expr_ != nullptr) {
    fields->emplace_back("for_system_time_expr", for_system_time_expr_.get());
  }
  if (!IsDefaultValue(column_index_list_)) {
    fields->emplace_back("column_index_list", ToStringCommaSeparated(column_index_list_));
  }
  if (!IsDefaultValue(alias_)) {
    fields->emplace_back("alias", ToStringImpl(alias_));
  }
}

absl::Status ResolvedTableScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedTableScan::table not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(for_system_time_expr_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedTableScan::for_system_time_expr not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (for_system_time_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          for_system_time_expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedTableScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedTableScan::table is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedTableScan::for_system_time_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (for_system_time_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(for_system_time_expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedTableScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (for_system_time_expr_ != nullptr) for_system_time_expr_->ClearFieldsAccessed();
}

void ResolvedTableScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (for_system_time_expr_ != nullptr) for_system_time_expr_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedJoinScan::TYPE;

const ResolvedJoinScan::JoinType ResolvedJoinScan::INNER;
const ResolvedJoinScan::JoinType ResolvedJoinScan::LEFT;
const ResolvedJoinScan::JoinType ResolvedJoinScan::RIGHT;
const ResolvedJoinScan::JoinType ResolvedJoinScan::FULL;

ResolvedJoinScan::~ResolvedJoinScan() {
}

absl::Status ResolvedJoinScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_join_scan_node());
}

absl::Status ResolvedJoinScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedJoinScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_join_type(join_type_);
  if (left_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(left_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_left_scan()));
  }
  if (right_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(right_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_right_scan()));
  }
  if (join_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(join_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_join_expr()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedJoinScan>> ResolvedJoinScan::RestoreFrom(
    const ResolvedJoinScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  JoinType join_type =
      proto.join_type();
  std::unique_ptr<const ResolvedScan> left_scan;
  if (proto.
  has_left_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(left_scan,
                     ResolvedScan::RestoreFrom(
                         proto.left_scan(), params));
  }
  std::unique_ptr<const ResolvedScan> right_scan;
  if (proto.
  has_right_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(right_scan,
                     ResolvedScan::RestoreFrom(
                         proto.right_scan(), params));
  }
  std::unique_ptr<const ResolvedExpr> join_expr;
  if (proto.
  has_join_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(join_expr,
                     ResolvedExpr::RestoreFrom(
                         proto.join_expr(), params));
  }
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedJoinScan(
      std::move(column_list),
      std::move(join_type),
      std::move(left_scan),
      std::move(right_scan),
      std::move(join_expr));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

void ResolvedJoinScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (left_scan_ != nullptr) {
    child_nodes->emplace_back(left_scan_.get());
  }
  if (right_scan_ != nullptr) {
    child_nodes->emplace_back(right_scan_.get());
  }
  if (join_expr_ != nullptr) {
    child_nodes->emplace_back(join_expr_.get());
  }
}

void ResolvedJoinScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (left_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &left_scan_));
    static_assert(sizeof(left_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (right_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &right_scan_));
    static_assert(sizeof(right_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (join_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &join_expr_));
    static_assert(sizeof(join_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedJoinScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedJoinScan(this);
}

absl::Status ResolvedJoinScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (left_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(left_scan_.get()->Accept(visitor));
  }
  if (right_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(right_scan_.get()->Accept(visitor));
  }
  if (join_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(join_expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedJoinScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(join_type_)) {
    fields->emplace_back("join_type", ToStringImpl(join_type_));
  }
  if (left_scan_ != nullptr) {
    fields->emplace_back("left_scan", left_scan_.get());
  }
  if (right_scan_ != nullptr) {
    fields->emplace_back("right_scan", right_scan_.get());
  }
  if (join_expr_ != nullptr) {
    fields->emplace_back("join_expr", join_expr_.get());
  }
}

absl::Status ResolvedJoinScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(join_type_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedJoinScan::join_type not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedJoinScan::left_scan not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedJoinScan::right_scan not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(join_expr_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedJoinScan::join_expr not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (left_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          left_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (right_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          right_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (join_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          join_expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedJoinScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedJoinScan::join_type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedJoinScan::left_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedJoinScan::right_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedJoinScan::join_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (left_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(left_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (right_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(right_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (join_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(join_expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedJoinScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (left_scan_ != nullptr) left_scan_->ClearFieldsAccessed();
  if (right_scan_ != nullptr) right_scan_->ClearFieldsAccessed();
  if (join_expr_ != nullptr) join_expr_->ClearFieldsAccessed();
}

void ResolvedJoinScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (left_scan_ != nullptr) left_scan_->MarkFieldsAccessed();
  if (right_scan_ != nullptr) right_scan_->MarkFieldsAccessed();
  if (join_expr_ != nullptr) join_expr_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedArrayScan::TYPE;

ResolvedArrayScan::~ResolvedArrayScan() {
}

absl::Status ResolvedArrayScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_array_scan_node());
}

absl::Status ResolvedArrayScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedArrayScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_input_scan()));
  }
  if (array_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(array_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_array_expr()));
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      element_column_, file_descriptor_set_map,
      proto->mutable_element_column()));
  if (array_offset_column_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(array_offset_column_->SaveTo(
        file_descriptor_set_map, proto->mutable_array_offset_column()));
  }
  if (join_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(join_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_join_expr()));
  }
  proto->set_is_outer(is_outer_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedArrayScan>> ResolvedArrayScan::RestoreFrom(
    const ResolvedArrayScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedScan> input_scan;
  if (proto.
  has_input_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(input_scan,
                     ResolvedScan::RestoreFrom(
                         proto.input_scan(), params));
  }
  std::unique_ptr<const ResolvedExpr> array_expr;
  if (proto.
  has_array_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(array_expr,
                     ResolvedExpr::RestoreFrom(
                         proto.array_expr(), params));
  }
  ZETASQL_ASSIGN_OR_RETURN(auto element_column,
                   RestoreFromImpl<ResolvedColumn>(
                       proto.element_column(),
                       params));
  std::unique_ptr<const ResolvedColumnHolder> array_offset_column;
  if (proto.
  has_array_offset_column()) {
    ZETASQL_ASSIGN_OR_RETURN(array_offset_column,
                     ResolvedColumnHolder::RestoreFrom(
                         proto.array_offset_column(), params));
  }
  std::unique_ptr<const ResolvedExpr> join_expr;
  if (proto.
  has_join_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(join_expr,
                     ResolvedExpr::RestoreFrom(
                         proto.join_expr(), params));
  }
  bool is_outer =
      proto.is_outer();
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedArrayScan(
      std::move(column_list),
      std::move(input_scan),
      std::move(array_expr),
      std::move(element_column),
      std::move(array_offset_column),
      std::move(join_expr),
      std::move(is_outer));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

void ResolvedArrayScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (input_scan_ != nullptr) {
    child_nodes->emplace_back(input_scan_.get());
  }
  if (array_expr_ != nullptr) {
    child_nodes->emplace_back(array_expr_.get());
  }
  if (array_offset_column_ != nullptr) {
    child_nodes->emplace_back(array_offset_column_.get());
  }
  if (join_expr_ != nullptr) {
    child_nodes->emplace_back(join_expr_.get());
  }
}

void ResolvedArrayScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (input_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &input_scan_));
    static_assert(sizeof(input_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (array_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &array_expr_));
    static_assert(sizeof(array_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (array_offset_column_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &array_offset_column_));
    static_assert(sizeof(array_offset_column_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (join_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &join_expr_));
    static_assert(sizeof(join_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedArrayScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedArrayScan(this);
}

absl::Status ResolvedArrayScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_.get()->Accept(visitor));
  }
  if (array_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(array_expr_.get()->Accept(visitor));
  }
  if (array_offset_column_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(array_offset_column_.get()->Accept(visitor));
  }
  if (join_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(join_expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedArrayScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (input_scan_ != nullptr) {
    fields->emplace_back("input_scan", input_scan_.get());
  }
  if (array_expr_ != nullptr) {
    fields->emplace_back("array_expr", array_expr_.get());
  }
  {
    fields->emplace_back("element_column", ToStringImpl(element_column_));
  }
  if (array_offset_column_ != nullptr) {
    fields->emplace_back("array_offset_column", array_offset_column_.get());
  }
  if (join_expr_ != nullptr) {
    fields->emplace_back("join_expr", join_expr_.get());
  }
  if (!IsDefaultValue(is_outer_)) {
    fields->emplace_back("is_outer", ToStringImpl(is_outer_));
  }
}

absl::Status ResolvedArrayScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(input_scan_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedArrayScan::input_scan not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedArrayScan::array_expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedArrayScan::element_column not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(array_offset_column_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedArrayScan::array_offset_column not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(join_expr_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedArrayScan::join_expr not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0 &&
      !IsDefaultValue(is_outer_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedArrayScan::is_outer not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          input_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (array_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          array_expr_.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (array_offset_column_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          array_offset_column_.get(), root));
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (join_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          join_expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedArrayScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedArrayScan::input_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedArrayScan::array_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedArrayScan::element_column is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedArrayScan::array_offset_column is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedArrayScan::join_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedArrayScan::is_outer is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(input_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (array_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(array_expr_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (array_offset_column_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(array_offset_column_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (join_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(join_expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedArrayScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (input_scan_ != nullptr) input_scan_->ClearFieldsAccessed();
  if (array_expr_ != nullptr) array_expr_->ClearFieldsAccessed();
  if (array_offset_column_ != nullptr) array_offset_column_->ClearFieldsAccessed();
  if (join_expr_ != nullptr) join_expr_->ClearFieldsAccessed();
}

void ResolvedArrayScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (input_scan_ != nullptr) input_scan_->MarkFieldsAccessed();
  if (array_expr_ != nullptr) array_expr_->MarkFieldsAccessed();
  if (array_offset_column_ != nullptr) array_offset_column_->MarkFieldsAccessed();
  if (join_expr_ != nullptr) join_expr_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedColumnHolder::TYPE;

ResolvedColumnHolder::~ResolvedColumnHolder() {
}

absl::Status ResolvedColumnHolder::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_column_holder_node());
}

absl::Status ResolvedColumnHolder::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedColumnHolderProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      column_, file_descriptor_set_map,
      proto->mutable_column()));
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedColumnHolder>> ResolvedColumnHolder::RestoreFrom(
    const ResolvedColumnHolderProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto column,
                   RestoreFromImpl<ResolvedColumn>(
                       proto.column(),
                       params));
  auto node = MakeResolvedColumnHolder(
      std::move(column));

  return node;
}

void ResolvedColumnHolder::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedColumnHolder::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedColumnHolder::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedColumnHolder(this);
}

absl::Status ResolvedColumnHolder::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedColumnHolder::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("column", ToStringImpl(column_));
  }
}

absl::Status ResolvedColumnHolder::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedColumnHolder::column not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedColumnHolder::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedColumnHolder::column is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedColumnHolder::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedColumnHolder::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedFilterScan::TYPE;

ResolvedFilterScan::~ResolvedFilterScan() {
}

absl::Status ResolvedFilterScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_filter_scan_node());
}

absl::Status ResolvedFilterScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedFilterScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_input_scan()));
  }
  if (filter_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(filter_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_filter_expr()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedFilterScan>> ResolvedFilterScan::RestoreFrom(
    const ResolvedFilterScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedScan> input_scan;
  if (proto.
  has_input_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(input_scan,
                     ResolvedScan::RestoreFrom(
                         proto.input_scan(), params));
  }
  std::unique_ptr<const ResolvedExpr> filter_expr;
  if (proto.
  has_filter_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(filter_expr,
                     ResolvedExpr::RestoreFrom(
                         proto.filter_expr(), params));
  }
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedFilterScan(
      std::move(column_list),
      std::move(input_scan),
      std::move(filter_expr));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

void ResolvedFilterScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (input_scan_ != nullptr) {
    child_nodes->emplace_back(input_scan_.get());
  }
  if (filter_expr_ != nullptr) {
    child_nodes->emplace_back(filter_expr_.get());
  }
}

void ResolvedFilterScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (input_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &input_scan_));
    static_assert(sizeof(input_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (filter_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &filter_expr_));
    static_assert(sizeof(filter_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedFilterScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedFilterScan(this);
}

absl::Status ResolvedFilterScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_.get()->Accept(visitor));
  }
  if (filter_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(filter_expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedFilterScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (input_scan_ != nullptr) {
    fields->emplace_back("input_scan", input_scan_.get());
  }
  if (filter_expr_ != nullptr) {
    fields->emplace_back("filter_expr", filter_expr_.get());
  }
}

absl::Status ResolvedFilterScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFilterScan::input_scan not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFilterScan::filter_expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          input_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (filter_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          filter_expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedFilterScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFilterScan::input_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFilterScan::filter_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(input_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (filter_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(filter_expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedFilterScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (input_scan_ != nullptr) input_scan_->ClearFieldsAccessed();
  if (filter_expr_ != nullptr) filter_expr_->ClearFieldsAccessed();
}

void ResolvedFilterScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (input_scan_ != nullptr) input_scan_->MarkFieldsAccessed();
  if (filter_expr_ != nullptr) filter_expr_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedGroupingSet::TYPE;

ResolvedGroupingSet::~ResolvedGroupingSet() {
}

absl::Status ResolvedGroupingSet::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_grouping_set_node());
}

absl::Status ResolvedGroupingSet::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedGroupingSetProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : group_by_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_group_by_column_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedGroupingSet>> ResolvedGroupingSet::RestoreFrom(
    const ResolvedGroupingSetProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedColumnRef>> group_by_column_list;
  for (const auto& elem : proto.group_by_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedColumnRef> elem_restored,
                     ResolvedColumnRef::RestoreFrom(elem, params));
    group_by_column_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedGroupingSet(
      std::move(group_by_column_list));

  return node;
}

void ResolvedGroupingSet::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : group_by_column_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedGroupingSet::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : group_by_column_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedGroupingSet::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedGroupingSet(this);
}

absl::Status ResolvedGroupingSet::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : group_by_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedGroupingSet::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!group_by_column_list_.empty()) {
    fields->emplace_back("group_by_column_list", group_by_column_list_);
  }
}

absl::Status ResolvedGroupingSet::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGroupingSet::group_by_column_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : group_by_column_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedGroupingSet::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGroupingSet::group_by_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : group_by_column_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedGroupingSet::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : group_by_column_list_) it->ClearFieldsAccessed();
}

void ResolvedGroupingSet::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : group_by_column_list_) it->MarkFieldsAccessed();
}

ResolvedAggregateScanBase::~ResolvedAggregateScanBase() {
}

absl::Status ResolvedAggregateScanBase::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_aggregate_scan_base_node());
}

absl::Status ResolvedAggregateScanBase::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAggregateScanBaseProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_input_scan()));
  }
  for (const auto& elem : group_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_group_by_list()));
  }
  for (const auto& elem : collation_list_) {
    ZETASQL_RETURN_IF_ERROR(SaveToImpl(
        elem, file_descriptor_set_map, proto->add_collation_list()));
  }
  for (const auto& elem : aggregate_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_aggregate_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAggregateScanBase>> ResolvedAggregateScanBase::RestoreFrom(
    const AnyResolvedAggregateScanBaseProto& proto,
    const ResolvedNode::RestoreParams& params) {
  switch (proto.node_case()) {
    case AnyResolvedAggregateScanBaseProto::kResolvedAggregateScanNode:
      return ResolvedAggregateScan::RestoreFrom(
          proto.resolved_aggregate_scan_node(), params);
    case AnyResolvedAggregateScanBaseProto::kResolvedAnonymizedAggregateScanNode:
      return ResolvedAnonymizedAggregateScan::RestoreFrom(
          proto.resolved_anonymized_aggregate_scan_node(), params);
  case AnyResolvedAggregateScanBaseProto::NODE_NOT_SET:
    return ::zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
        << "No subnode types set in ResolvedAggregateScanBaseProto";
  }
}

void ResolvedAggregateScanBase::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (input_scan_ != nullptr) {
    child_nodes->emplace_back(input_scan_.get());
  }
  for (const auto& elem : group_by_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : aggregate_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedAggregateScanBase::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (input_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &input_scan_));
    static_assert(sizeof(input_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : group_by_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : aggregate_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedAggregateScanBase::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAggregateScanBase(this);
}

absl::Status ResolvedAggregateScanBase::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_.get()->Accept(visitor));
  }
  for (const auto& elem : group_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : aggregate_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAggregateScanBase::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (input_scan_ != nullptr) {
    fields->emplace_back("input_scan", input_scan_.get());
  }
  if (!group_by_list_.empty()) {
    fields->emplace_back("group_by_list", group_by_list_);
  }
  if (!IsDefaultValue(collation_list_)) {
    fields->emplace_back("collation_list", ToStringImpl(collation_list_));
  }
  if (!aggregate_list_.empty()) {
    fields->emplace_back("aggregate_list", aggregate_list_);
  }
}

absl::Status ResolvedAggregateScanBase::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAggregateScanBase::input_scan not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAggregateScanBase::group_by_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(collation_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAggregateScanBase::collation_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAggregateScanBase::aggregate_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          input_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : group_by_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : aggregate_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAggregateScanBase::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAggregateScanBase::input_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAggregateScanBase::group_by_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAggregateScanBase::collation_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAggregateScanBase::aggregate_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(input_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : group_by_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : aggregate_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAggregateScanBase::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (input_scan_ != nullptr) input_scan_->ClearFieldsAccessed();
  for (const auto& it : group_by_list_) it->ClearFieldsAccessed();
  for (const auto& it : aggregate_list_) it->ClearFieldsAccessed();
}

void ResolvedAggregateScanBase::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (input_scan_ != nullptr) input_scan_->MarkFieldsAccessed();
  for (const auto& it : group_by_list_) it->MarkFieldsAccessed();
  for (const auto& it : aggregate_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAggregateScan::TYPE;

ResolvedAggregateScan::~ResolvedAggregateScan() {
}

absl::Status ResolvedAggregateScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAggregateScanBaseProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_aggregate_scan_node());
}

absl::Status ResolvedAggregateScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAggregateScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : grouping_set_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_grouping_set_list()));
  }
  for (const auto& elem : rollup_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_rollup_column_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAggregateScan>> ResolvedAggregateScan::RestoreFrom(
    const ResolvedAggregateScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedGroupingSet>> grouping_set_list;
  for (const auto& elem : proto.grouping_set_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedGroupingSet> elem_restored,
                     ResolvedGroupingSet::RestoreFrom(elem, params));
    grouping_set_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedColumnRef>> rollup_column_list;
  for (const auto& elem : proto.rollup_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedColumnRef> elem_restored,
                     ResolvedColumnRef::RestoreFrom(elem, params));
    rollup_column_list.push_back(std::move(elem_restored));
  }
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().parent().is_ordered();
  std::unique_ptr<const ResolvedScan> input_scan;
  if (proto.parent().
  has_input_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(input_scan,
                     ResolvedScan::RestoreFrom(
                         proto.parent().input_scan(), params));
  }
  std::vector<std::unique_ptr<const ResolvedComputedColumn>> group_by_list;
  for (const auto& elem : proto.parent().group_by_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedComputedColumn> elem_restored,
                     ResolvedComputedColumn::RestoreFrom(elem, params));
    group_by_list.push_back(std::move(elem_restored));
  }
  std::vector<ResolvedCollation> collation_list;
  for (const auto& elem : proto.parent().collation_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedCollation>::value_type>(elem, params));
    collation_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedComputedColumn>> aggregate_list;
  for (const auto& elem : proto.parent().aggregate_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedComputedColumn> elem_restored,
                     ResolvedComputedColumn::RestoreFrom(elem, params));
    aggregate_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedAggregateScan(
      std::move(column_list),
      std::move(input_scan),
      std::move(group_by_list),
      std::move(aggregate_list),
      std::move(grouping_set_list),
      std::move(rollup_column_list));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  node->set_collation_list(std::move(collation_list));
  return node;
}

void ResolvedAggregateScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : grouping_set_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : rollup_column_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedAggregateScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : grouping_set_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : rollup_column_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedAggregateScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAggregateScan(this);
}

absl::Status ResolvedAggregateScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : grouping_set_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : rollup_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAggregateScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!grouping_set_list_.empty()) {
    fields->emplace_back("grouping_set_list", grouping_set_list_);
  }
  if (!rollup_column_list_.empty()) {
    fields->emplace_back("rollup_column_list", rollup_column_list_);
  }
}

absl::Status ResolvedAggregateScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(grouping_set_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAggregateScan::grouping_set_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(rollup_column_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAggregateScan::rollup_column_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : grouping_set_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : rollup_column_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAggregateScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAggregateScan::grouping_set_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAggregateScan::rollup_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : grouping_set_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : rollup_column_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAggregateScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : grouping_set_list_) it->ClearFieldsAccessed();
  for (const auto& it : rollup_column_list_) it->ClearFieldsAccessed();
}

void ResolvedAggregateScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : grouping_set_list_) it->MarkFieldsAccessed();
  for (const auto& it : rollup_column_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAnonymizedAggregateScan::TYPE;

ResolvedAnonymizedAggregateScan::~ResolvedAnonymizedAggregateScan() {
}

absl::Status ResolvedAnonymizedAggregateScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAggregateScanBaseProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_anonymized_aggregate_scan_node());
}

absl::Status ResolvedAnonymizedAggregateScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAnonymizedAggregateScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (k_threshold_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(k_threshold_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_k_threshold_expr()));
  }
  for (const auto& elem : anonymization_option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_anonymization_option_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAnonymizedAggregateScan>> ResolvedAnonymizedAggregateScan::RestoreFrom(
    const ResolvedAnonymizedAggregateScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedColumnRef> k_threshold_expr;
  if (proto.
  has_k_threshold_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(k_threshold_expr,
                     ResolvedColumnRef::RestoreFrom(
                         proto.k_threshold_expr(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> anonymization_option_list;
  for (const auto& elem : proto.anonymization_option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    anonymization_option_list.push_back(std::move(elem_restored));
  }
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().parent().is_ordered();
  std::unique_ptr<const ResolvedScan> input_scan;
  if (proto.parent().
  has_input_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(input_scan,
                     ResolvedScan::RestoreFrom(
                         proto.parent().input_scan(), params));
  }
  std::vector<std::unique_ptr<const ResolvedComputedColumn>> group_by_list;
  for (const auto& elem : proto.parent().group_by_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedComputedColumn> elem_restored,
                     ResolvedComputedColumn::RestoreFrom(elem, params));
    group_by_list.push_back(std::move(elem_restored));
  }
  std::vector<ResolvedCollation> collation_list;
  for (const auto& elem : proto.parent().collation_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedCollation>::value_type>(elem, params));
    collation_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedComputedColumn>> aggregate_list;
  for (const auto& elem : proto.parent().aggregate_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedComputedColumn> elem_restored,
                     ResolvedComputedColumn::RestoreFrom(elem, params));
    aggregate_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedAnonymizedAggregateScan(
      std::move(column_list),
      std::move(input_scan),
      std::move(group_by_list),
      std::move(aggregate_list),
      std::move(k_threshold_expr),
      std::move(anonymization_option_list));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  node->set_collation_list(std::move(collation_list));
  return node;
}

void ResolvedAnonymizedAggregateScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (k_threshold_expr_ != nullptr) {
    child_nodes->emplace_back(k_threshold_expr_.get());
  }
  for (const auto& elem : anonymization_option_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedAnonymizedAggregateScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (k_threshold_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &k_threshold_expr_));
    static_assert(sizeof(k_threshold_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : anonymization_option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedAnonymizedAggregateScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAnonymizedAggregateScan(this);
}

absl::Status ResolvedAnonymizedAggregateScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (k_threshold_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(k_threshold_expr_.get()->Accept(visitor));
  }
  for (const auto& elem : anonymization_option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAnonymizedAggregateScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (k_threshold_expr_ != nullptr) {
    fields->emplace_back("k_threshold_expr", k_threshold_expr_.get());
  }
  if (!anonymization_option_list_.empty()) {
    fields->emplace_back("anonymization_option_list", anonymization_option_list_);
  }
}

absl::Status ResolvedAnonymizedAggregateScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAnonymizedAggregateScan::k_threshold_expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(anonymization_option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAnonymizedAggregateScan::anonymization_option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (k_threshold_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          k_threshold_expr_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : anonymization_option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAnonymizedAggregateScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAnonymizedAggregateScan::k_threshold_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAnonymizedAggregateScan::anonymization_option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (k_threshold_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(k_threshold_expr_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : anonymization_option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAnonymizedAggregateScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (k_threshold_expr_ != nullptr) k_threshold_expr_->ClearFieldsAccessed();
  for (const auto& it : anonymization_option_list_) it->ClearFieldsAccessed();
}

void ResolvedAnonymizedAggregateScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (k_threshold_expr_ != nullptr) k_threshold_expr_->MarkFieldsAccessed();
  for (const auto& it : anonymization_option_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedSetOperationItem::TYPE;

ResolvedSetOperationItem::~ResolvedSetOperationItem() {
}

absl::Status ResolvedSetOperationItem::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_set_operation_item_node());
}

absl::Status ResolvedSetOperationItem::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedSetOperationItemProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_scan()));
  }
  for (const auto& elem : output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(SaveToImpl(
        elem, file_descriptor_set_map, proto->add_output_column_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedSetOperationItem>> ResolvedSetOperationItem::RestoreFrom(
    const ResolvedSetOperationItemProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedScan> scan;
  if (proto.
  has_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(scan,
                     ResolvedScan::RestoreFrom(
                         proto.scan(), params));
  }
  std::vector<ResolvedColumn> output_column_list;
  for (const auto& elem : proto.output_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    output_column_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedSetOperationItem(
      std::move(scan),
      std::move(output_column_list));

  return node;
}

void ResolvedSetOperationItem::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (scan_ != nullptr) {
    child_nodes->emplace_back(scan_.get());
  }
}

void ResolvedSetOperationItem::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &scan_));
    static_assert(sizeof(scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedSetOperationItem::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedSetOperationItem(this);
}

absl::Status ResolvedSetOperationItem::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(scan_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedSetOperationItem::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (scan_ != nullptr) {
    fields->emplace_back("scan", scan_.get());
  }
  {
    fields->emplace_back("output_column_list", ToStringImpl(output_column_list_));
  }
}

absl::Status ResolvedSetOperationItem::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSetOperationItem::scan not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSetOperationItem::output_column_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          scan_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedSetOperationItem::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSetOperationItem::scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSetOperationItem::output_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(scan_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedSetOperationItem::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (scan_ != nullptr) scan_->ClearFieldsAccessed();
}

void ResolvedSetOperationItem::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (scan_ != nullptr) scan_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedSetOperationScan::TYPE;

const ResolvedSetOperationScan::SetOperationType ResolvedSetOperationScan::UNION_ALL;
const ResolvedSetOperationScan::SetOperationType ResolvedSetOperationScan::UNION_DISTINCT;
const ResolvedSetOperationScan::SetOperationType ResolvedSetOperationScan::INTERSECT_ALL;
const ResolvedSetOperationScan::SetOperationType ResolvedSetOperationScan::INTERSECT_DISTINCT;
const ResolvedSetOperationScan::SetOperationType ResolvedSetOperationScan::EXCEPT_ALL;
const ResolvedSetOperationScan::SetOperationType ResolvedSetOperationScan::EXCEPT_DISTINCT;

ResolvedSetOperationScan::~ResolvedSetOperationScan() {
}

absl::Status ResolvedSetOperationScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_set_operation_scan_node());
}

absl::Status ResolvedSetOperationScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedSetOperationScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_op_type(op_type_);
  for (const auto& elem : input_item_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_input_item_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedSetOperationScan>> ResolvedSetOperationScan::RestoreFrom(
    const ResolvedSetOperationScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  SetOperationType op_type =
      proto.op_type();
  std::vector<std::unique_ptr<const ResolvedSetOperationItem>> input_item_list;
  for (const auto& elem : proto.input_item_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedSetOperationItem> elem_restored,
                     ResolvedSetOperationItem::RestoreFrom(elem, params));
    input_item_list.push_back(std::move(elem_restored));
  }
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedSetOperationScan(
      std::move(column_list),
      std::move(op_type),
      std::move(input_item_list));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

void ResolvedSetOperationScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : input_item_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedSetOperationScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : input_item_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedSetOperationScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedSetOperationScan(this);
}

absl::Status ResolvedSetOperationScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : input_item_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedSetOperationScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("op_type", ToStringImpl(op_type_));
  }
  if (!input_item_list_.empty()) {
    fields->emplace_back("input_item_list", input_item_list_);
  }
}

absl::Status ResolvedSetOperationScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSetOperationScan::op_type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSetOperationScan::input_item_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : input_item_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedSetOperationScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSetOperationScan::op_type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSetOperationScan::input_item_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : input_item_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedSetOperationScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : input_item_list_) it->ClearFieldsAccessed();
}

void ResolvedSetOperationScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : input_item_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedOrderByScan::TYPE;

ResolvedOrderByScan::~ResolvedOrderByScan() {
}

absl::Status ResolvedOrderByScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_order_by_scan_node());
}

absl::Status ResolvedOrderByScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedOrderByScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_input_scan()));
  }
  for (const auto& elem : order_by_item_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_order_by_item_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedOrderByScan>> ResolvedOrderByScan::RestoreFrom(
    const ResolvedOrderByScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedScan> input_scan;
  if (proto.
  has_input_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(input_scan,
                     ResolvedScan::RestoreFrom(
                         proto.input_scan(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOrderByItem>> order_by_item_list;
  for (const auto& elem : proto.order_by_item_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOrderByItem> elem_restored,
                     ResolvedOrderByItem::RestoreFrom(elem, params));
    order_by_item_list.push_back(std::move(elem_restored));
  }
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedOrderByScan(
      std::move(column_list),
      std::move(input_scan),
      std::move(order_by_item_list));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

void ResolvedOrderByScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (input_scan_ != nullptr) {
    child_nodes->emplace_back(input_scan_.get());
  }
  for (const auto& elem : order_by_item_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedOrderByScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (input_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &input_scan_));
    static_assert(sizeof(input_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : order_by_item_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedOrderByScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedOrderByScan(this);
}

absl::Status ResolvedOrderByScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_.get()->Accept(visitor));
  }
  for (const auto& elem : order_by_item_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedOrderByScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (input_scan_ != nullptr) {
    fields->emplace_back("input_scan", input_scan_.get());
  }
  if (!order_by_item_list_.empty()) {
    fields->emplace_back("order_by_item_list", order_by_item_list_);
  }
}

absl::Status ResolvedOrderByScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedOrderByScan::input_scan not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedOrderByScan::order_by_item_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          input_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : order_by_item_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedOrderByScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedOrderByScan::input_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedOrderByScan::order_by_item_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(input_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : order_by_item_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedOrderByScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (input_scan_ != nullptr) input_scan_->ClearFieldsAccessed();
  for (const auto& it : order_by_item_list_) it->ClearFieldsAccessed();
}

void ResolvedOrderByScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (input_scan_ != nullptr) input_scan_->MarkFieldsAccessed();
  for (const auto& it : order_by_item_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedLimitOffsetScan::TYPE;

ResolvedLimitOffsetScan::~ResolvedLimitOffsetScan() {
}

absl::Status ResolvedLimitOffsetScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_limit_offset_scan_node());
}

absl::Status ResolvedLimitOffsetScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedLimitOffsetScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_input_scan()));
  }
  if (limit_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(limit_->SaveTo(
        file_descriptor_set_map, proto->mutable_limit()));
  }
  if (offset_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(offset_->SaveTo(
        file_descriptor_set_map, proto->mutable_offset()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedLimitOffsetScan>> ResolvedLimitOffsetScan::RestoreFrom(
    const ResolvedLimitOffsetScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedScan> input_scan;
  if (proto.
  has_input_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(input_scan,
                     ResolvedScan::RestoreFrom(
                         proto.input_scan(), params));
  }
  std::unique_ptr<const ResolvedExpr> limit;
  if (proto.
  has_limit()) {
    ZETASQL_ASSIGN_OR_RETURN(limit,
                     ResolvedExpr::RestoreFrom(
                         proto.limit(), params));
  }
  std::unique_ptr<const ResolvedExpr> offset;
  if (proto.
  has_offset()) {
    ZETASQL_ASSIGN_OR_RETURN(offset,
                     ResolvedExpr::RestoreFrom(
                         proto.offset(), params));
  }
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedLimitOffsetScan(
      std::move(column_list),
      std::move(input_scan),
      std::move(limit),
      std::move(offset));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

void ResolvedLimitOffsetScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (input_scan_ != nullptr) {
    child_nodes->emplace_back(input_scan_.get());
  }
  if (limit_ != nullptr) {
    child_nodes->emplace_back(limit_.get());
  }
  if (offset_ != nullptr) {
    child_nodes->emplace_back(offset_.get());
  }
}

void ResolvedLimitOffsetScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (input_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &input_scan_));
    static_assert(sizeof(input_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (limit_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &limit_));
    static_assert(sizeof(limit_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (offset_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &offset_));
    static_assert(sizeof(offset_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedLimitOffsetScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedLimitOffsetScan(this);
}

absl::Status ResolvedLimitOffsetScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_.get()->Accept(visitor));
  }
  if (limit_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(limit_.get()->Accept(visitor));
  }
  if (offset_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(offset_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedLimitOffsetScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (input_scan_ != nullptr) {
    fields->emplace_back("input_scan", input_scan_.get());
  }
  if (limit_ != nullptr) {
    fields->emplace_back("limit", limit_.get());
  }
  if (offset_ != nullptr) {
    fields->emplace_back("offset", offset_.get());
  }
}

absl::Status ResolvedLimitOffsetScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedLimitOffsetScan::input_scan not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedLimitOffsetScan::limit not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedLimitOffsetScan::offset not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          input_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (limit_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          limit_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (offset_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          offset_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedLimitOffsetScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedLimitOffsetScan::input_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedLimitOffsetScan::limit is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedLimitOffsetScan::offset is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(input_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (limit_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(limit_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (offset_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(offset_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedLimitOffsetScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (input_scan_ != nullptr) input_scan_->ClearFieldsAccessed();
  if (limit_ != nullptr) limit_->ClearFieldsAccessed();
  if (offset_ != nullptr) offset_->ClearFieldsAccessed();
}

void ResolvedLimitOffsetScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (input_scan_ != nullptr) input_scan_->MarkFieldsAccessed();
  if (limit_ != nullptr) limit_->MarkFieldsAccessed();
  if (offset_ != nullptr) offset_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedWithRefScan::TYPE;

ResolvedWithRefScan::~ResolvedWithRefScan() {
}

absl::Status ResolvedWithRefScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_with_ref_scan_node());
}

absl::Status ResolvedWithRefScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedWithRefScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_with_query_name(with_query_name_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedWithRefScan>> ResolvedWithRefScan::RestoreFrom(
    const ResolvedWithRefScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string with_query_name =
      proto.with_query_name();
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedWithRefScan(
      std::move(column_list),
      std::move(with_query_name));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

void ResolvedWithRefScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedWithRefScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedWithRefScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedWithRefScan(this);
}

absl::Status ResolvedWithRefScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedWithRefScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("with_query_name", ToStringImpl(with_query_name_));
  }
}

absl::Status ResolvedWithRefScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedWithRefScan::with_query_name not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedWithRefScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedWithRefScan::with_query_name is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedWithRefScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedWithRefScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedAnalyticScan::TYPE;

ResolvedAnalyticScan::~ResolvedAnalyticScan() {
}

absl::Status ResolvedAnalyticScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_analytic_scan_node());
}

absl::Status ResolvedAnalyticScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAnalyticScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_input_scan()));
  }
  for (const auto& elem : function_group_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_function_group_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAnalyticScan>> ResolvedAnalyticScan::RestoreFrom(
    const ResolvedAnalyticScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedScan> input_scan;
  if (proto.
  has_input_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(input_scan,
                     ResolvedScan::RestoreFrom(
                         proto.input_scan(), params));
  }
  std::vector<std::unique_ptr<const ResolvedAnalyticFunctionGroup>> function_group_list;
  for (const auto& elem : proto.function_group_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedAnalyticFunctionGroup> elem_restored,
                     ResolvedAnalyticFunctionGroup::RestoreFrom(elem, params));
    function_group_list.push_back(std::move(elem_restored));
  }
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedAnalyticScan(
      std::move(column_list),
      std::move(input_scan),
      std::move(function_group_list));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

void ResolvedAnalyticScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (input_scan_ != nullptr) {
    child_nodes->emplace_back(input_scan_.get());
  }
  for (const auto& elem : function_group_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedAnalyticScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (input_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &input_scan_));
    static_assert(sizeof(input_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : function_group_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedAnalyticScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAnalyticScan(this);
}

absl::Status ResolvedAnalyticScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_.get()->Accept(visitor));
  }
  for (const auto& elem : function_group_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAnalyticScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (input_scan_ != nullptr) {
    fields->emplace_back("input_scan", input_scan_.get());
  }
  if (!function_group_list_.empty()) {
    fields->emplace_back("function_group_list", function_group_list_);
  }
}

absl::Status ResolvedAnalyticScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAnalyticScan::input_scan not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAnalyticScan::function_group_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          input_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : function_group_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAnalyticScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAnalyticScan::input_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAnalyticScan::function_group_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(input_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : function_group_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAnalyticScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (input_scan_ != nullptr) input_scan_->ClearFieldsAccessed();
  for (const auto& it : function_group_list_) it->ClearFieldsAccessed();
}

void ResolvedAnalyticScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (input_scan_ != nullptr) input_scan_->MarkFieldsAccessed();
  for (const auto& it : function_group_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedSampleScan::TYPE;

const ResolvedSampleScan::SampleUnit ResolvedSampleScan::ROWS;
const ResolvedSampleScan::SampleUnit ResolvedSampleScan::PERCENT;

ResolvedSampleScan::~ResolvedSampleScan() {
}

absl::Status ResolvedSampleScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_sample_scan_node());
}

absl::Status ResolvedSampleScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedSampleScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_input_scan()));
  }
  proto->set_method(method_);
  if (size_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(size_->SaveTo(
        file_descriptor_set_map, proto->mutable_size()));
  }
  proto->set_unit(unit_);
  if (repeatable_argument_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(repeatable_argument_->SaveTo(
        file_descriptor_set_map, proto->mutable_repeatable_argument()));
  }
  if (weight_column_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(weight_column_->SaveTo(
        file_descriptor_set_map, proto->mutable_weight_column()));
  }
  for (const auto& elem : partition_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_partition_by_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedSampleScan>> ResolvedSampleScan::RestoreFrom(
    const ResolvedSampleScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedScan> input_scan;
  if (proto.
  has_input_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(input_scan,
                     ResolvedScan::RestoreFrom(
                         proto.input_scan(), params));
  }
  std::string method =
      proto.method();
  std::unique_ptr<const ResolvedExpr> size;
  if (proto.
  has_size()) {
    ZETASQL_ASSIGN_OR_RETURN(size,
                     ResolvedExpr::RestoreFrom(
                         proto.size(), params));
  }
  SampleUnit unit =
      proto.unit();
  std::unique_ptr<const ResolvedExpr> repeatable_argument;
  if (proto.
  has_repeatable_argument()) {
    ZETASQL_ASSIGN_OR_RETURN(repeatable_argument,
                     ResolvedExpr::RestoreFrom(
                         proto.repeatable_argument(), params));
  }
  std::unique_ptr<const ResolvedColumnHolder> weight_column;
  if (proto.
  has_weight_column()) {
    ZETASQL_ASSIGN_OR_RETURN(weight_column,
                     ResolvedColumnHolder::RestoreFrom(
                         proto.weight_column(), params));
  }
  std::vector<std::unique_ptr<const ResolvedExpr>> partition_by_list;
  for (const auto& elem : proto.partition_by_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    partition_by_list.push_back(std::move(elem_restored));
  }
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedSampleScan(
      std::move(column_list),
      std::move(input_scan),
      std::move(method),
      std::move(size),
      std::move(unit),
      std::move(repeatable_argument),
      std::move(weight_column),
      std::move(partition_by_list));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

void ResolvedSampleScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (input_scan_ != nullptr) {
    child_nodes->emplace_back(input_scan_.get());
  }
  if (size_ != nullptr) {
    child_nodes->emplace_back(size_.get());
  }
  if (repeatable_argument_ != nullptr) {
    child_nodes->emplace_back(repeatable_argument_.get());
  }
  if (weight_column_ != nullptr) {
    child_nodes->emplace_back(weight_column_.get());
  }
  for (const auto& elem : partition_by_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedSampleScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (input_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &input_scan_));
    static_assert(sizeof(input_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (size_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &size_));
    static_assert(sizeof(size_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (repeatable_argument_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &repeatable_argument_));
    static_assert(sizeof(repeatable_argument_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (weight_column_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &weight_column_));
    static_assert(sizeof(weight_column_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : partition_by_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedSampleScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedSampleScan(this);
}

absl::Status ResolvedSampleScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_.get()->Accept(visitor));
  }
  if (size_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(size_.get()->Accept(visitor));
  }
  if (repeatable_argument_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(repeatable_argument_.get()->Accept(visitor));
  }
  if (weight_column_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(weight_column_.get()->Accept(visitor));
  }
  for (const auto& elem : partition_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedSampleScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (input_scan_ != nullptr) {
    fields->emplace_back("input_scan", input_scan_.get());
  }
  {
    fields->emplace_back("method", ToStringImpl(method_));
  }
  if (size_ != nullptr) {
    fields->emplace_back("size", size_.get());
  }
  {
    fields->emplace_back("unit", ToStringImpl(unit_));
  }
  if (repeatable_argument_ != nullptr) {
    fields->emplace_back("repeatable_argument", repeatable_argument_.get());
  }
  if (weight_column_ != nullptr) {
    fields->emplace_back("weight_column", weight_column_.get());
  }
  if (!partition_by_list_.empty()) {
    fields->emplace_back("partition_by_list", partition_by_list_);
  }
}

absl::Status ResolvedSampleScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSampleScan::input_scan not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSampleScan::method not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSampleScan::size not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSampleScan::unit not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSampleScan::repeatable_argument not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0 &&
      !IsDefaultValue(weight_column_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSampleScan::weight_column not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<6)) == 0 &&
      !IsDefaultValue(partition_by_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSampleScan::partition_by_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          input_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (size_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          size_.get(), root));
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (repeatable_argument_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          repeatable_argument_.get(), root));
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    if (weight_column_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          weight_column_.get(), root));
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    for (const auto& it : partition_by_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedSampleScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSampleScan::input_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSampleScan::method is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSampleScan::size is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSampleScan::unit is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSampleScan::repeatable_argument is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSampleScan::weight_column is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<6)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSampleScan::partition_by_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(input_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (size_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(size_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (repeatable_argument_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(repeatable_argument_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    if (weight_column_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(weight_column_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    for (const auto& it : partition_by_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedSampleScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (input_scan_ != nullptr) input_scan_->ClearFieldsAccessed();
  if (size_ != nullptr) size_->ClearFieldsAccessed();
  if (repeatable_argument_ != nullptr) repeatable_argument_->ClearFieldsAccessed();
  if (weight_column_ != nullptr) weight_column_->ClearFieldsAccessed();
  for (const auto& it : partition_by_list_) it->ClearFieldsAccessed();
}

void ResolvedSampleScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (input_scan_ != nullptr) input_scan_->MarkFieldsAccessed();
  if (size_ != nullptr) size_->MarkFieldsAccessed();
  if (repeatable_argument_ != nullptr) repeatable_argument_->MarkFieldsAccessed();
  if (weight_column_ != nullptr) weight_column_->MarkFieldsAccessed();
  for (const auto& it : partition_by_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedComputedColumn::TYPE;

ResolvedComputedColumn::~ResolvedComputedColumn() {
}

absl::Status ResolvedComputedColumn::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_computed_column_node());
}

absl::Status ResolvedComputedColumn::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedComputedColumnProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      column_, file_descriptor_set_map,
      proto->mutable_column()));
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_expr()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedComputedColumn>> ResolvedComputedColumn::RestoreFrom(
    const ResolvedComputedColumnProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto column,
                   RestoreFromImpl<ResolvedColumn>(
                       proto.column(),
                       params));
  std::unique_ptr<const ResolvedExpr> expr;
  if (proto.
  has_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(expr,
                     ResolvedExpr::RestoreFrom(
                         proto.expr(), params));
  }
  auto node = MakeResolvedComputedColumn(
      std::move(column),
      std::move(expr));

  return node;
}

void ResolvedComputedColumn::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expr_ != nullptr) {
    child_nodes->emplace_back(expr_.get());
  }
}

void ResolvedComputedColumn::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expr_));
    static_assert(sizeof(expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedComputedColumn::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedComputedColumn(this);
}

absl::Status ResolvedComputedColumn::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

absl::Status ResolvedComputedColumn::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedComputedColumn::expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedComputedColumn::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedComputedColumn::expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedComputedColumn::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expr_ != nullptr) expr_->ClearFieldsAccessed();
}

void ResolvedComputedColumn::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expr_ != nullptr) expr_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedOrderByItem::TYPE;

const ResolvedOrderByItem::NullOrderMode ResolvedOrderByItem::ORDER_UNSPECIFIED;
const ResolvedOrderByItem::NullOrderMode ResolvedOrderByItem::NULLS_FIRST;
const ResolvedOrderByItem::NullOrderMode ResolvedOrderByItem::NULLS_LAST;

ResolvedOrderByItem::~ResolvedOrderByItem() {
}

absl::Status ResolvedOrderByItem::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_order_by_item_node());
}

absl::Status ResolvedOrderByItem::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedOrderByItemProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (column_ref_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(column_ref_->SaveTo(
        file_descriptor_set_map, proto->mutable_column_ref()));
  }
  if (collation_name_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(collation_name_->SaveTo(
        file_descriptor_set_map, proto->mutable_collation_name()));
  }
  proto->set_is_descending(is_descending_);
  proto->set_null_order(null_order_);
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      collation_, file_descriptor_set_map,
      proto->mutable_collation()));
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedOrderByItem>> ResolvedOrderByItem::RestoreFrom(
    const ResolvedOrderByItemProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedColumnRef> column_ref;
  if (proto.
  has_column_ref()) {
    ZETASQL_ASSIGN_OR_RETURN(column_ref,
                     ResolvedColumnRef::RestoreFrom(
                         proto.column_ref(), params));
  }
  std::unique_ptr<const ResolvedExpr> collation_name;
  if (proto.
  has_collation_name()) {
    ZETASQL_ASSIGN_OR_RETURN(collation_name,
                     ResolvedExpr::RestoreFrom(
                         proto.collation_name(), params));
  }
  bool is_descending =
      proto.is_descending();
  NullOrderMode null_order =
      proto.null_order();
  ZETASQL_ASSIGN_OR_RETURN(auto collation,
                   RestoreFromImpl<ResolvedCollation>(
                       proto.collation(),
                       params));
  auto node = MakeResolvedOrderByItem(
      std::move(column_ref),
      std::move(collation_name),
      std::move(is_descending),
      std::move(null_order));

  node->set_collation(std::move(collation));
  return node;
}

void ResolvedOrderByItem::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (column_ref_ != nullptr) {
    child_nodes->emplace_back(column_ref_.get());
  }
  if (collation_name_ != nullptr) {
    child_nodes->emplace_back(collation_name_.get());
  }
}

void ResolvedOrderByItem::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (column_ref_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &column_ref_));
    static_assert(sizeof(column_ref_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (collation_name_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &collation_name_));
    static_assert(sizeof(collation_name_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedOrderByItem::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedOrderByItem(this);
}

absl::Status ResolvedOrderByItem::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (column_ref_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(column_ref_.get()->Accept(visitor));
  }
  if (collation_name_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(collation_name_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedOrderByItem::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (column_ref_ != nullptr) {
    fields->emplace_back("column_ref", column_ref_.get());
  }
  if (collation_name_ != nullptr) {
    fields->emplace_back("collation_name", collation_name_.get());
  }
  if (!IsDefaultValue(is_descending_)) {
    fields->emplace_back("is_descending", ToStringImpl(is_descending_));
  }
  if (!IsDefaultValue(null_order_)) {
    fields->emplace_back("null_order", ToStringImpl(null_order_));
  }
  if (!IsDefaultValue(collation_)) {
    fields->emplace_back("collation", ToStringImpl(collation_));
  }
}

absl::Status ResolvedOrderByItem::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedOrderByItem::column_ref not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(collation_name_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedOrderByItem::collation_name not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(is_descending_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedOrderByItem::is_descending not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(null_order_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedOrderByItem::null_order not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(collation_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedOrderByItem::collation not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (column_ref_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          column_ref_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (collation_name_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          collation_name_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedOrderByItem::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedOrderByItem::column_ref is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedOrderByItem::collation_name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedOrderByItem::is_descending is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedOrderByItem::null_order is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedOrderByItem::collation is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (column_ref_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(column_ref_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (collation_name_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(collation_name_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedOrderByItem::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (column_ref_ != nullptr) column_ref_->ClearFieldsAccessed();
  if (collation_name_ != nullptr) collation_name_->ClearFieldsAccessed();
}

void ResolvedOrderByItem::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (column_ref_ != nullptr) column_ref_->MarkFieldsAccessed();
  if (collation_name_ != nullptr) collation_name_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedColumnAnnotations::TYPE;

ResolvedColumnAnnotations::~ResolvedColumnAnnotations() {
}

absl::Status ResolvedColumnAnnotations::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_column_annotations_node());
}

absl::Status ResolvedColumnAnnotations::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedColumnAnnotationsProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (collation_name_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(collation_name_->SaveTo(
        file_descriptor_set_map, proto->mutable_collation_name()));
  }
  proto->set_not_null(not_null_);
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  for (const auto& elem : child_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_child_list()));
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      type_parameters_, file_descriptor_set_map,
      proto->mutable_type_parameters()));
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedColumnAnnotations>> ResolvedColumnAnnotations::RestoreFrom(
    const ResolvedColumnAnnotationsProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> collation_name;
  if (proto.
  has_collation_name()) {
    ZETASQL_ASSIGN_OR_RETURN(collation_name,
                     ResolvedExpr::RestoreFrom(
                         proto.collation_name(), params));
  }
  bool not_null =
      proto.not_null();
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedColumnAnnotations>> child_list;
  for (const auto& elem : proto.child_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedColumnAnnotations> elem_restored,
                     ResolvedColumnAnnotations::RestoreFrom(elem, params));
    child_list.push_back(std::move(elem_restored));
  }
  ZETASQL_ASSIGN_OR_RETURN(auto type_parameters,
                   RestoreFromImpl<TypeParameters>(
                       proto.type_parameters(),
                       params));
  auto node = MakeResolvedColumnAnnotations(
      std::move(collation_name),
      std::move(not_null),
      std::move(option_list),
      std::move(child_list),
      std::move(type_parameters));

  return node;
}

void ResolvedColumnAnnotations::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (collation_name_ != nullptr) {
    child_nodes->emplace_back(collation_name_.get());
  }
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : child_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedColumnAnnotations::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (collation_name_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &collation_name_));
    static_assert(sizeof(collation_name_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : child_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedColumnAnnotations::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedColumnAnnotations(this);
}

absl::Status ResolvedColumnAnnotations::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (collation_name_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(collation_name_.get()->Accept(visitor));
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : child_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedColumnAnnotations::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (collation_name_ != nullptr) {
    fields->emplace_back("collation_name", collation_name_.get());
  }
  if (!IsDefaultValue(not_null_)) {
    fields->emplace_back("not_null", ToStringImpl(not_null_));
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
  if (!child_list_.empty()) {
    fields->emplace_back("child_list", child_list_);
  }
  if (!IsDefaultValue(type_parameters_)) {
    fields->emplace_back("type_parameters", ToStringImpl(type_parameters_));
  }
}

absl::Status ResolvedColumnAnnotations::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(collation_name_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedColumnAnnotations::collation_name not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(not_null_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedColumnAnnotations::not_null not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedColumnAnnotations::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(child_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedColumnAnnotations::child_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(type_parameters_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedColumnAnnotations::type_parameters not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (collation_name_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          collation_name_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : child_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedColumnAnnotations::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedColumnAnnotations::collation_name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedColumnAnnotations::not_null is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedColumnAnnotations::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedColumnAnnotations::child_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedColumnAnnotations::type_parameters is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (collation_name_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(collation_name_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : child_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedColumnAnnotations::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (collation_name_ != nullptr) collation_name_->ClearFieldsAccessed();
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
  for (const auto& it : child_list_) it->ClearFieldsAccessed();
}

void ResolvedColumnAnnotations::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (collation_name_ != nullptr) collation_name_->MarkFieldsAccessed();
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
  for (const auto& it : child_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedGeneratedColumnInfo::TYPE;

const ResolvedGeneratedColumnInfo::StoredMode ResolvedGeneratedColumnInfo::NON_STORED;
const ResolvedGeneratedColumnInfo::StoredMode ResolvedGeneratedColumnInfo::STORED;
const ResolvedGeneratedColumnInfo::StoredMode ResolvedGeneratedColumnInfo::STORED_VOLATILE;

ResolvedGeneratedColumnInfo::~ResolvedGeneratedColumnInfo() {
}

absl::Status ResolvedGeneratedColumnInfo::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_generated_column_info_node());
}

absl::Status ResolvedGeneratedColumnInfo::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedGeneratedColumnInfoProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (expression_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expression_->SaveTo(
        file_descriptor_set_map, proto->mutable_expression()));
  }
  proto->set_stored_mode(stored_mode_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedGeneratedColumnInfo>> ResolvedGeneratedColumnInfo::RestoreFrom(
    const ResolvedGeneratedColumnInfoProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> expression;
  if (proto.
  has_expression()) {
    ZETASQL_ASSIGN_OR_RETURN(expression,
                     ResolvedExpr::RestoreFrom(
                         proto.expression(), params));
  }
  StoredMode stored_mode =
      proto.stored_mode();
  auto node = MakeResolvedGeneratedColumnInfo(
      std::move(expression),
      std::move(stored_mode));

  return node;
}

void ResolvedGeneratedColumnInfo::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expression_ != nullptr) {
    child_nodes->emplace_back(expression_.get());
  }
}

void ResolvedGeneratedColumnInfo::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expression_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expression_));
    static_assert(sizeof(expression_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedGeneratedColumnInfo::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedGeneratedColumnInfo(this);
}

absl::Status ResolvedGeneratedColumnInfo::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expression_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expression_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedGeneratedColumnInfo::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (expression_ != nullptr) {
    fields->emplace_back("expression", expression_.get());
  }
  if (!IsDefaultValue(stored_mode_)) {
    fields->emplace_back("stored_mode", ToStringImpl(stored_mode_));
  }
}

absl::Status ResolvedGeneratedColumnInfo::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGeneratedColumnInfo::expression not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expression_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expression_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedGeneratedColumnInfo::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGeneratedColumnInfo::expression is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expression_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expression_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedGeneratedColumnInfo::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expression_ != nullptr) expression_->ClearFieldsAccessed();
}

void ResolvedGeneratedColumnInfo::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expression_ != nullptr) expression_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedColumnDefaultValue::TYPE;

ResolvedColumnDefaultValue::~ResolvedColumnDefaultValue() {
}

absl::Status ResolvedColumnDefaultValue::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_column_default_value_node());
}

absl::Status ResolvedColumnDefaultValue::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedColumnDefaultValueProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (expression_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expression_->SaveTo(
        file_descriptor_set_map, proto->mutable_expression()));
  }
  proto->set_sql(sql_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedColumnDefaultValue>> ResolvedColumnDefaultValue::RestoreFrom(
    const ResolvedColumnDefaultValueProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> expression;
  if (proto.
  has_expression()) {
    ZETASQL_ASSIGN_OR_RETURN(expression,
                     ResolvedExpr::RestoreFrom(
                         proto.expression(), params));
  }
  std::string sql =
      proto.sql();
  auto node = MakeResolvedColumnDefaultValue(
      std::move(expression),
      std::move(sql));

  return node;
}

void ResolvedColumnDefaultValue::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expression_ != nullptr) {
    child_nodes->emplace_back(expression_.get());
  }
}

void ResolvedColumnDefaultValue::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expression_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expression_));
    static_assert(sizeof(expression_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedColumnDefaultValue::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedColumnDefaultValue(this);
}

absl::Status ResolvedColumnDefaultValue::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expression_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expression_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedColumnDefaultValue::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (expression_ != nullptr) {
    fields->emplace_back("expression", expression_.get());
  }
  {
    fields->emplace_back("sql", ToStringImpl(sql_));
  }
}

absl::Status ResolvedColumnDefaultValue::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedColumnDefaultValue::expression not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedColumnDefaultValue::sql not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expression_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expression_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedColumnDefaultValue::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedColumnDefaultValue::expression is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedColumnDefaultValue::sql is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expression_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expression_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedColumnDefaultValue::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expression_ != nullptr) expression_->ClearFieldsAccessed();
}

void ResolvedColumnDefaultValue::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expression_ != nullptr) expression_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedColumnDefinition::TYPE;

ResolvedColumnDefinition::~ResolvedColumnDefinition() {
}

absl::Status ResolvedColumnDefinition::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_column_definition_node());
}

absl::Status ResolvedColumnDefinition::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedColumnDefinitionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_name(name_);
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      type_, file_descriptor_set_map,
      proto->mutable_type()));
  if (annotations_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(annotations_->SaveTo(
        file_descriptor_set_map, proto->mutable_annotations()));
  }
  proto->set_is_hidden(is_hidden_);
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      column_, file_descriptor_set_map,
      proto->mutable_column()));
  if (generated_column_info_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(generated_column_info_->SaveTo(
        file_descriptor_set_map, proto->mutable_generated_column_info()));
  }
  if (default_value_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(default_value_->SaveTo(
        file_descriptor_set_map, proto->mutable_default_value()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedColumnDefinition>> ResolvedColumnDefinition::RestoreFrom(
    const ResolvedColumnDefinitionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string name =
      proto.name();
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.type(),
                       params));
  std::unique_ptr<const ResolvedColumnAnnotations> annotations;
  if (proto.
  has_annotations()) {
    ZETASQL_ASSIGN_OR_RETURN(annotations,
                     ResolvedColumnAnnotations::RestoreFrom(
                         proto.annotations(), params));
  }
  bool is_hidden =
      proto.is_hidden();
  ZETASQL_ASSIGN_OR_RETURN(auto column,
                   RestoreFromImpl<ResolvedColumn>(
                       proto.column(),
                       params));
  std::unique_ptr<const ResolvedGeneratedColumnInfo> generated_column_info;
  if (proto.
  has_generated_column_info()) {
    ZETASQL_ASSIGN_OR_RETURN(generated_column_info,
                     ResolvedGeneratedColumnInfo::RestoreFrom(
                         proto.generated_column_info(), params));
  }
  std::unique_ptr<const ResolvedColumnDefaultValue> default_value;
  if (proto.
  has_default_value()) {
    ZETASQL_ASSIGN_OR_RETURN(default_value,
                     ResolvedColumnDefaultValue::RestoreFrom(
                         proto.default_value(), params));
  }
  auto node = MakeResolvedColumnDefinition(
      std::move(name),
      std::move(type),
      std::move(annotations),
      std::move(is_hidden),
      std::move(column),
      std::move(generated_column_info),
      std::move(default_value));

  return node;
}

void ResolvedColumnDefinition::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (annotations_ != nullptr) {
    child_nodes->emplace_back(annotations_.get());
  }
  if (generated_column_info_ != nullptr) {
    child_nodes->emplace_back(generated_column_info_.get());
  }
  if (default_value_ != nullptr) {
    child_nodes->emplace_back(default_value_.get());
  }
}

void ResolvedColumnDefinition::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (annotations_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &annotations_));
    static_assert(sizeof(annotations_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (generated_column_info_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &generated_column_info_));
    static_assert(sizeof(generated_column_info_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (default_value_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &default_value_));
    static_assert(sizeof(default_value_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedColumnDefinition::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedColumnDefinition(this);
}

absl::Status ResolvedColumnDefinition::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (annotations_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(annotations_.get()->Accept(visitor));
  }
  if (generated_column_info_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(generated_column_info_.get()->Accept(visitor));
  }
  if (default_value_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(default_value_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedColumnDefinition::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("name", ToStringImpl(name_));
  }
  {
    fields->emplace_back("type", ToStringImpl(type_));
  }
  if (annotations_ != nullptr) {
    fields->emplace_back("annotations", annotations_.get());
  }
  if (!IsDefaultValue(is_hidden_)) {
    fields->emplace_back("is_hidden", ToStringImpl(is_hidden_));
  }
  if (!IsDefaultValue(column_)) {
    fields->emplace_back("column", ToStringImpl(column_));
  }
  if (generated_column_info_ != nullptr) {
    fields->emplace_back("generated_column_info", generated_column_info_.get());
  }
  if (default_value_ != nullptr) {
    fields->emplace_back("default_value", default_value_.get());
  }
}

absl::Status ResolvedColumnDefinition::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedColumnDefinition::name not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedColumnDefinition::type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(annotations_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedColumnDefinition::annotations not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(is_hidden_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedColumnDefinition::is_hidden not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0 &&
      !IsDefaultValue(generated_column_info_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedColumnDefinition::generated_column_info not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<6)) == 0 &&
      !IsDefaultValue(default_value_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedColumnDefinition::default_value not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (annotations_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          annotations_.get(), root));
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    if (generated_column_info_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          generated_column_info_.get(), root));
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    if (default_value_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          default_value_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedColumnDefinition::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedColumnDefinition::name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedColumnDefinition::type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedColumnDefinition::annotations is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedColumnDefinition::is_hidden is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedColumnDefinition::generated_column_info is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<6)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedColumnDefinition::default_value is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (annotations_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(annotations_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    if (generated_column_info_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(generated_column_info_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    if (default_value_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(default_value_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedColumnDefinition::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (annotations_ != nullptr) annotations_->ClearFieldsAccessed();
  if (generated_column_info_ != nullptr) generated_column_info_->ClearFieldsAccessed();
  if (default_value_ != nullptr) default_value_->ClearFieldsAccessed();
}

void ResolvedColumnDefinition::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (annotations_ != nullptr) annotations_->MarkFieldsAccessed();
  if (generated_column_info_ != nullptr) generated_column_info_->MarkFieldsAccessed();
  if (default_value_ != nullptr) default_value_->MarkFieldsAccessed();
}

ResolvedConstraint::~ResolvedConstraint() {
}

absl::Status ResolvedConstraint::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_constraint_node());
}

absl::Status ResolvedConstraint::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedConstraintProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedConstraint>> ResolvedConstraint::RestoreFrom(
    const AnyResolvedConstraintProto& proto,
    const ResolvedNode::RestoreParams& params) {
  switch (proto.node_case()) {
    case AnyResolvedConstraintProto::kResolvedPrimaryKeyNode:
      return ResolvedPrimaryKey::RestoreFrom(
          proto.resolved_primary_key_node(), params);
    case AnyResolvedConstraintProto::kResolvedForeignKeyNode:
      return ResolvedForeignKey::RestoreFrom(
          proto.resolved_foreign_key_node(), params);
    case AnyResolvedConstraintProto::kResolvedCheckConstraintNode:
      return ResolvedCheckConstraint::RestoreFrom(
          proto.resolved_check_constraint_node(), params);
  case AnyResolvedConstraintProto::NODE_NOT_SET:
    return ::zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
        << "No subnode types set in ResolvedConstraintProto";
  }
}

absl::Status ResolvedConstraint::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedConstraint(this);
}

absl::Status ResolvedConstraint::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

const ResolvedNodeKind ResolvedPrimaryKey::TYPE;

ResolvedPrimaryKey::~ResolvedPrimaryKey() {
}

absl::Status ResolvedPrimaryKey::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedConstraintProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_primary_key_node());
}

absl::Status ResolvedPrimaryKey::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedPrimaryKeyProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : column_offset_list_) {
    proto->add_column_offset_list(elem);
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  proto->set_unenforced(unenforced_);
  proto->set_constraint_name(constraint_name_);
  for (const auto& elem : column_name_list_) {
    proto->add_column_name_list(elem);
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedPrimaryKey>> ResolvedPrimaryKey::RestoreFrom(
    const ResolvedPrimaryKeyProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<int> column_offset_list;
  for (const auto& elem : proto.column_offset_list()) {
    column_offset_list.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  bool unenforced =
      proto.unenforced();
  std::string constraint_name =
      proto.constraint_name();
  std::vector<std::string> column_name_list;
  for (const auto& elem : proto.column_name_list()) {
    column_name_list.push_back(elem);
  }
  auto node = MakeResolvedPrimaryKey(
      std::move(column_offset_list),
      std::move(option_list),
      std::move(unenforced),
      std::move(constraint_name),
      std::move(column_name_list));

  return node;
}

void ResolvedPrimaryKey::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedPrimaryKey::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedPrimaryKey::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedPrimaryKey(this);
}

absl::Status ResolvedPrimaryKey::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedPrimaryKey::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("column_offset_list", ToStringCommaSeparated(column_offset_list_));
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
  if (!IsDefaultValue(unenforced_)) {
    fields->emplace_back("unenforced", ToStringImpl(unenforced_));
  }
  if (!IsDefaultValue(constraint_name_)) {
    fields->emplace_back("constraint_name", ToStringImpl(constraint_name_));
  }
  if (!IsDefaultValue(column_name_list_)) {
    fields->emplace_back("column_name_list", ToStringCommaSeparated(column_name_list_));
  }
}

absl::Status ResolvedPrimaryKey::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedPrimaryKey::column_offset_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedPrimaryKey::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(unenforced_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedPrimaryKey::unenforced not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(constraint_name_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedPrimaryKey::constraint_name not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedPrimaryKey::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedPrimaryKey::column_offset_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedPrimaryKey::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedPrimaryKey::unenforced is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedPrimaryKey::constraint_name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedPrimaryKey::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
}

void ResolvedPrimaryKey::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedForeignKey::TYPE;

const ResolvedForeignKey::MatchMode ResolvedForeignKey::SIMPLE;
const ResolvedForeignKey::MatchMode ResolvedForeignKey::FULL;
const ResolvedForeignKey::MatchMode ResolvedForeignKey::NOT_DISTINCT;
const ResolvedForeignKey::ActionOperation ResolvedForeignKey::NO_ACTION;
const ResolvedForeignKey::ActionOperation ResolvedForeignKey::RESTRICT;
const ResolvedForeignKey::ActionOperation ResolvedForeignKey::CASCADE;
const ResolvedForeignKey::ActionOperation ResolvedForeignKey::SET_NULL;

ResolvedForeignKey::~ResolvedForeignKey() {
}

absl::Status ResolvedForeignKey::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedConstraintProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_foreign_key_node());
}

absl::Status ResolvedForeignKey::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedForeignKeyProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_constraint_name(constraint_name_);
  for (const auto& elem : referencing_column_offset_list_) {
    proto->add_referencing_column_offset_list(elem);
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      referenced_table_, file_descriptor_set_map,
      proto->mutable_referenced_table()));
  for (const auto& elem : referenced_column_offset_list_) {
    proto->add_referenced_column_offset_list(elem);
  }
  proto->set_match_mode(match_mode_);
  proto->set_update_action(update_action_);
  proto->set_delete_action(delete_action_);
  proto->set_enforced(enforced_);
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  for (const auto& elem : referencing_column_list_) {
    proto->add_referencing_column_list(elem);
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedForeignKey>> ResolvedForeignKey::RestoreFrom(
    const ResolvedForeignKeyProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string constraint_name =
      proto.constraint_name();
  std::vector<int> referencing_column_offset_list;
  for (const auto& elem : proto.referencing_column_offset_list()) {
    referencing_column_offset_list.push_back(elem);
  }
  ZETASQL_ASSIGN_OR_RETURN(auto referenced_table,
                   RestoreFromImpl<const Table*>(
                       proto.referenced_table(),
                       params));
  std::vector<int> referenced_column_offset_list;
  for (const auto& elem : proto.referenced_column_offset_list()) {
    referenced_column_offset_list.push_back(elem);
  }
  MatchMode match_mode =
      proto.match_mode();
  ActionOperation update_action =
      proto.update_action();
  ActionOperation delete_action =
      proto.delete_action();
  bool enforced =
      proto.enforced();
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> referencing_column_list;
  for (const auto& elem : proto.referencing_column_list()) {
    referencing_column_list.push_back(elem);
  }
  auto node = MakeResolvedForeignKey(
      std::move(constraint_name),
      std::move(referencing_column_offset_list),
      std::move(referenced_table),
      std::move(referenced_column_offset_list),
      std::move(match_mode),
      std::move(update_action),
      std::move(delete_action),
      std::move(enforced),
      std::move(option_list),
      std::move(referencing_column_list));

  return node;
}

void ResolvedForeignKey::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedForeignKey::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedForeignKey::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedForeignKey(this);
}

absl::Status ResolvedForeignKey::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedForeignKey::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("constraint_name", ToStringImpl(constraint_name_));
  }
  {
    fields->emplace_back("referencing_column_offset_list", ToStringCommaSeparated(referencing_column_offset_list_));
  }
  {
    fields->emplace_back("referenced_table", ToStringImpl(referenced_table_));
  }
  {
    fields->emplace_back("referenced_column_offset_list", ToStringCommaSeparated(referenced_column_offset_list_));
  }
  {
    fields->emplace_back("match_mode", ToStringImpl(match_mode_));
  }
  {
    fields->emplace_back("update_action", ToStringImpl(update_action_));
  }
  {
    fields->emplace_back("delete_action", ToStringImpl(delete_action_));
  }
  {
    fields->emplace_back("enforced", ToStringImpl(enforced_));
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
  if (!IsDefaultValue(referencing_column_list_)) {
    fields->emplace_back("referencing_column_list", ToStringImpl(referencing_column_list_));
  }
}

absl::Status ResolvedForeignKey::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedForeignKey::constraint_name not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedForeignKey::referencing_column_offset_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedForeignKey::referenced_table not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedForeignKey::referenced_column_offset_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedForeignKey::match_mode not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedForeignKey::update_action not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<6)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedForeignKey::delete_action not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<7)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedForeignKey::enforced not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<8)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedForeignKey::option_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<8)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedForeignKey::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedForeignKey::constraint_name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedForeignKey::referencing_column_offset_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedForeignKey::referenced_table is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedForeignKey::referenced_column_offset_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedForeignKey::match_mode is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedForeignKey::update_action is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<6)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedForeignKey::delete_action is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<7)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedForeignKey::enforced is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<8)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedForeignKey::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<8)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedForeignKey::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
}

void ResolvedForeignKey::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCheckConstraint::TYPE;

ResolvedCheckConstraint::~ResolvedCheckConstraint() {
}

absl::Status ResolvedCheckConstraint::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedConstraintProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_check_constraint_node());
}

absl::Status ResolvedCheckConstraint::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCheckConstraintProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_constraint_name(constraint_name_);
  if (expression_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expression_->SaveTo(
        file_descriptor_set_map, proto->mutable_expression()));
  }
  proto->set_enforced(enforced_);
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCheckConstraint>> ResolvedCheckConstraint::RestoreFrom(
    const ResolvedCheckConstraintProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string constraint_name =
      proto.constraint_name();
  std::unique_ptr<const ResolvedExpr> expression;
  if (proto.
  has_expression()) {
    ZETASQL_ASSIGN_OR_RETURN(expression,
                     ResolvedExpr::RestoreFrom(
                         proto.expression(), params));
  }
  bool enforced =
      proto.enforced();
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedCheckConstraint(
      std::move(constraint_name),
      std::move(expression),
      std::move(enforced),
      std::move(option_list));

  return node;
}

void ResolvedCheckConstraint::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expression_ != nullptr) {
    child_nodes->emplace_back(expression_.get());
  }
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedCheckConstraint::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expression_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expression_));
    static_assert(sizeof(expression_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedCheckConstraint::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCheckConstraint(this);
}

absl::Status ResolvedCheckConstraint::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expression_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expression_.get()->Accept(visitor));
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCheckConstraint::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("constraint_name", ToStringImpl(constraint_name_));
  }
  if (expression_ != nullptr) {
    fields->emplace_back("expression", expression_.get());
  }
  {
    fields->emplace_back("enforced", ToStringImpl(enforced_));
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
}

absl::Status ResolvedCheckConstraint::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCheckConstraint::constraint_name not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCheckConstraint::expression not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCheckConstraint::enforced not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCheckConstraint::option_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (expression_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expression_.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCheckConstraint::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCheckConstraint::constraint_name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCheckConstraint::expression is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCheckConstraint::enforced is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCheckConstraint::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (expression_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expression_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCheckConstraint::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expression_ != nullptr) expression_->ClearFieldsAccessed();
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
}

void ResolvedCheckConstraint::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expression_ != nullptr) expression_->MarkFieldsAccessed();
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedOutputColumn::TYPE;

ResolvedOutputColumn::~ResolvedOutputColumn() {
}

absl::Status ResolvedOutputColumn::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_output_column_node());
}

absl::Status ResolvedOutputColumn::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedOutputColumnProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_name(name_);
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      column_, file_descriptor_set_map,
      proto->mutable_column()));
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedOutputColumn>> ResolvedOutputColumn::RestoreFrom(
    const ResolvedOutputColumnProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string name =
      proto.name();
  ZETASQL_ASSIGN_OR_RETURN(auto column,
                   RestoreFromImpl<ResolvedColumn>(
                       proto.column(),
                       params));
  auto node = MakeResolvedOutputColumn(
      std::move(name),
      std::move(column));

  return node;
}

void ResolvedOutputColumn::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedOutputColumn::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedOutputColumn::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedOutputColumn(this);
}

absl::Status ResolvedOutputColumn::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

absl::Status ResolvedOutputColumn::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedOutputColumn::column not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedOutputColumn::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedOutputColumn::column is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedOutputColumn::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedOutputColumn::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedProjectScan::TYPE;

ResolvedProjectScan::~ResolvedProjectScan() {
}

absl::Status ResolvedProjectScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_project_scan_node());
}

absl::Status ResolvedProjectScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedProjectScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : expr_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_expr_list()));
  }
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_input_scan()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedProjectScan>> ResolvedProjectScan::RestoreFrom(
    const ResolvedProjectScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedComputedColumn>> expr_list;
  for (const auto& elem : proto.expr_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedComputedColumn> elem_restored,
                     ResolvedComputedColumn::RestoreFrom(elem, params));
    expr_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedScan> input_scan;
  if (proto.
  has_input_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(input_scan,
                     ResolvedScan::RestoreFrom(
                         proto.input_scan(), params));
  }
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedProjectScan(
      std::move(column_list),
      std::move(expr_list),
      std::move(input_scan));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

void ResolvedProjectScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : expr_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (input_scan_ != nullptr) {
    child_nodes->emplace_back(input_scan_.get());
  }
}

void ResolvedProjectScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : expr_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (input_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &input_scan_));
    static_assert(sizeof(input_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedProjectScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedProjectScan(this);
}

absl::Status ResolvedProjectScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : expr_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedProjectScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!expr_list_.empty()) {
    fields->emplace_back("expr_list", expr_list_);
  }
  if (input_scan_ != nullptr) {
    fields->emplace_back("input_scan", input_scan_.get());
  }
}

absl::Status ResolvedProjectScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedProjectScan::expr_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedProjectScan::input_scan not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : expr_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          input_scan_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedProjectScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedProjectScan::expr_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedProjectScan::input_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : expr_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(input_scan_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedProjectScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : expr_list_) it->ClearFieldsAccessed();
  if (input_scan_ != nullptr) input_scan_->ClearFieldsAccessed();
}

void ResolvedProjectScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : expr_list_) it->MarkFieldsAccessed();
  if (input_scan_ != nullptr) input_scan_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedTVFScan::TYPE;

ResolvedTVFScan::~ResolvedTVFScan() {
}

absl::Status ResolvedTVFScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_tvfscan_node());
}

absl::Status ResolvedTVFScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedTVFScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      tvf_, file_descriptor_set_map,
      proto->mutable_tvf()));
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      signature_, file_descriptor_set_map,
      proto->mutable_signature()));
  for (const auto& elem : argument_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_argument_list()));
  }
  for (const auto& elem : column_index_list_) {
    proto->add_column_index_list(elem);
  }
  proto->set_alias(alias_);
    if (!IsDefaultValue(function_call_signature_)) {
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      function_call_signature_, file_descriptor_set_map,
      proto->mutable_function_call_signature()));
    }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedTVFScan>> ResolvedTVFScan::RestoreFrom(
    const ResolvedTVFScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto tvf,
                   RestoreFromImpl<const TableValuedFunction*>(
                       proto.tvf(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto signature,
                   RestoreFromImpl<std::shared_ptr<TVFSignature>>(
                       proto.signature(),
                       params));
  std::vector<std::unique_ptr<const ResolvedFunctionArgument>> argument_list;
  for (const auto& elem : proto.argument_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedFunctionArgument> elem_restored,
                     ResolvedFunctionArgument::RestoreFrom(elem, params));
    argument_list.push_back(std::move(elem_restored));
  }
  std::vector<int> column_index_list;
  for (const auto& elem : proto.column_index_list()) {
    column_index_list.push_back(elem);
  }
  std::string alias =
      proto.alias();
  std::shared_ptr<FunctionSignature> function_call_signature;
  if (!proto.
  has_function_call_signature()) {
    function_call_signature = nullptr;
  } else {
    ZETASQL_ASSIGN_OR_RETURN(function_call_signature,
                     RestoreFromImpl<std::shared_ptr<FunctionSignature>>(
                         proto.function_call_signature(),
                         params));
  }
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedTVFScan(
      std::move(column_list),
      std::move(tvf),
      std::move(signature),
      std::move(argument_list),
      std::move(column_index_list),
      std::move(alias),
      std::move(function_call_signature));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

void ResolvedTVFScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : argument_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedTVFScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : argument_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedTVFScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedTVFScan(this);
}

absl::Status ResolvedTVFScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : argument_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedTVFScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("tvf", ToStringImpl(tvf_));
  }
  {
    fields->emplace_back("signature", ToStringImpl(signature_));
  }
  if (!argument_list_.empty()) {
    fields->emplace_back("argument_list", argument_list_);
  }
  if (!IsDefaultValue(column_index_list_)) {
    fields->emplace_back("column_index_list", ToStringCommaSeparated(column_index_list_));
  }
  if (!IsDefaultValue(alias_)) {
    fields->emplace_back("alias", ToStringImpl(alias_));
  }
  if (!IsDefaultValue(function_call_signature_)) {
    fields->emplace_back("function_call_signature", ToStringImpl(function_call_signature_));
  }
}

absl::Status ResolvedTVFScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedTVFScan::tvf not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedTVFScan::signature not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedTVFScan::argument_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0 &&
      !IsDefaultValue(function_call_signature_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedTVFScan::function_call_signature not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : argument_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedTVFScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedTVFScan::tvf is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedTVFScan::signature is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedTVFScan::argument_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedTVFScan::function_call_signature is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : argument_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedTVFScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : argument_list_) it->ClearFieldsAccessed();
}

void ResolvedTVFScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : argument_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedGroupRowsScan::TYPE;

ResolvedGroupRowsScan::~ResolvedGroupRowsScan() {
}

absl::Status ResolvedGroupRowsScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_group_rows_scan_node());
}

absl::Status ResolvedGroupRowsScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedGroupRowsScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : input_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_input_column_list()));
  }
  proto->set_alias(alias_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedGroupRowsScan>> ResolvedGroupRowsScan::RestoreFrom(
    const ResolvedGroupRowsScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedComputedColumn>> input_column_list;
  for (const auto& elem : proto.input_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedComputedColumn> elem_restored,
                     ResolvedComputedColumn::RestoreFrom(elem, params));
    input_column_list.push_back(std::move(elem_restored));
  }
  std::string alias =
      proto.alias();
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedGroupRowsScan(
      std::move(column_list),
      std::move(input_column_list),
      std::move(alias));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

void ResolvedGroupRowsScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : input_column_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedGroupRowsScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : input_column_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedGroupRowsScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedGroupRowsScan(this);
}

absl::Status ResolvedGroupRowsScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : input_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedGroupRowsScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!input_column_list_.empty()) {
    fields->emplace_back("input_column_list", input_column_list_);
  }
  if (!IsDefaultValue(alias_)) {
    fields->emplace_back("alias", ToStringImpl(alias_));
  }
}

absl::Status ResolvedGroupRowsScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGroupRowsScan::input_column_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : input_column_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedGroupRowsScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGroupRowsScan::input_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : input_column_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedGroupRowsScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : input_column_list_) it->ClearFieldsAccessed();
}

void ResolvedGroupRowsScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : input_column_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedFunctionArgument::TYPE;

ResolvedFunctionArgument::~ResolvedFunctionArgument() {
}

absl::Status ResolvedFunctionArgument::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_function_argument_node());
}

absl::Status ResolvedFunctionArgument::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedFunctionArgumentProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_expr()));
  }
  if (scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_scan()));
  }
  if (model_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(model_->SaveTo(
        file_descriptor_set_map, proto->mutable_model()));
  }
  if (connection_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(connection_->SaveTo(
        file_descriptor_set_map, proto->mutable_connection()));
  }
  if (descriptor_arg_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(descriptor_arg_->SaveTo(
        file_descriptor_set_map, proto->mutable_descriptor_arg()));
  }
  for (const auto& elem : argument_column_list_) {
    ZETASQL_RETURN_IF_ERROR(SaveToImpl(
        elem, file_descriptor_set_map, proto->add_argument_column_list()));
  }
  if (inline_lambda_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(inline_lambda_->SaveTo(
        file_descriptor_set_map, proto->mutable_inline_lambda()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedFunctionArgument>> ResolvedFunctionArgument::RestoreFrom(
    const ResolvedFunctionArgumentProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> expr;
  if (proto.
  has_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(expr,
                     ResolvedExpr::RestoreFrom(
                         proto.expr(), params));
  }
  std::unique_ptr<const ResolvedScan> scan;
  if (proto.
  has_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(scan,
                     ResolvedScan::RestoreFrom(
                         proto.scan(), params));
  }
  std::unique_ptr<const ResolvedModel> model;
  if (proto.
  has_model()) {
    ZETASQL_ASSIGN_OR_RETURN(model,
                     ResolvedModel::RestoreFrom(
                         proto.model(), params));
  }
  std::unique_ptr<const ResolvedConnection> connection;
  if (proto.
  has_connection()) {
    ZETASQL_ASSIGN_OR_RETURN(connection,
                     ResolvedConnection::RestoreFrom(
                         proto.connection(), params));
  }
  std::unique_ptr<const ResolvedDescriptor> descriptor_arg;
  if (proto.
  has_descriptor_arg()) {
    ZETASQL_ASSIGN_OR_RETURN(descriptor_arg,
                     ResolvedDescriptor::RestoreFrom(
                         proto.descriptor_arg(), params));
  }
  std::vector<ResolvedColumn> argument_column_list;
  for (const auto& elem : proto.argument_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    argument_column_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedInlineLambda> inline_lambda;
  if (proto.
  has_inline_lambda()) {
    ZETASQL_ASSIGN_OR_RETURN(inline_lambda,
                     ResolvedInlineLambda::RestoreFrom(
                         proto.inline_lambda(), params));
  }
  auto node = MakeResolvedFunctionArgument(
      std::move(expr),
      std::move(scan),
      std::move(model),
      std::move(connection),
      std::move(descriptor_arg),
      std::move(argument_column_list),
      std::move(inline_lambda));

  return node;
}

void ResolvedFunctionArgument::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expr_ != nullptr) {
    child_nodes->emplace_back(expr_.get());
  }
  if (scan_ != nullptr) {
    child_nodes->emplace_back(scan_.get());
  }
  if (model_ != nullptr) {
    child_nodes->emplace_back(model_.get());
  }
  if (connection_ != nullptr) {
    child_nodes->emplace_back(connection_.get());
  }
  if (descriptor_arg_ != nullptr) {
    child_nodes->emplace_back(descriptor_arg_.get());
  }
  if (inline_lambda_ != nullptr) {
    child_nodes->emplace_back(inline_lambda_.get());
  }
}

void ResolvedFunctionArgument::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expr_));
    static_assert(sizeof(expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &scan_));
    static_assert(sizeof(scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (model_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &model_));
    static_assert(sizeof(model_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (connection_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &connection_));
    static_assert(sizeof(connection_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (descriptor_arg_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &descriptor_arg_));
    static_assert(sizeof(descriptor_arg_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (inline_lambda_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &inline_lambda_));
    static_assert(sizeof(inline_lambda_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedFunctionArgument::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedFunctionArgument(this);
}

absl::Status ResolvedFunctionArgument::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_.get()->Accept(visitor));
  }
  if (scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(scan_.get()->Accept(visitor));
  }
  if (model_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(model_.get()->Accept(visitor));
  }
  if (connection_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(connection_.get()->Accept(visitor));
  }
  if (descriptor_arg_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(descriptor_arg_.get()->Accept(visitor));
  }
  if (inline_lambda_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(inline_lambda_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedFunctionArgument::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (expr_ != nullptr) {
    fields->emplace_back("expr", expr_.get());
  }
  if (scan_ != nullptr) {
    fields->emplace_back("scan", scan_.get());
  }
  if (model_ != nullptr) {
    fields->emplace_back("model", model_.get());
  }
  if (connection_ != nullptr) {
    fields->emplace_back("connection", connection_.get());
  }
  if (descriptor_arg_ != nullptr) {
    fields->emplace_back("descriptor_arg", descriptor_arg_.get());
  }
  if (!IsDefaultValue(argument_column_list_)) {
    fields->emplace_back("argument_column_list", ToStringImpl(argument_column_list_));
  }
  if (inline_lambda_ != nullptr) {
    fields->emplace_back("inline_lambda", inline_lambda_.get());
  }
}

absl::Status ResolvedFunctionArgument::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(expr_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFunctionArgument::expr not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(scan_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFunctionArgument::scan not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(model_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFunctionArgument::model not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(connection_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFunctionArgument::connection not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(descriptor_arg_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFunctionArgument::descriptor_arg not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0 &&
      !IsDefaultValue(argument_column_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFunctionArgument::argument_column_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<6)) == 0 &&
      !IsDefaultValue(inline_lambda_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFunctionArgument::inline_lambda not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expr_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (model_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          model_.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (connection_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          connection_.get(), root));
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (descriptor_arg_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          descriptor_arg_.get(), root));
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    if (inline_lambda_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          inline_lambda_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedFunctionArgument::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFunctionArgument::expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFunctionArgument::scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFunctionArgument::model is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFunctionArgument::connection is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFunctionArgument::descriptor_arg is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFunctionArgument::argument_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<6)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFunctionArgument::inline_lambda is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expr_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (model_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(model_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (connection_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(connection_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (descriptor_arg_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(descriptor_arg_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    if (inline_lambda_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(inline_lambda_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedFunctionArgument::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expr_ != nullptr) expr_->ClearFieldsAccessed();
  if (scan_ != nullptr) scan_->ClearFieldsAccessed();
  if (model_ != nullptr) model_->ClearFieldsAccessed();
  if (connection_ != nullptr) connection_->ClearFieldsAccessed();
  if (descriptor_arg_ != nullptr) descriptor_arg_->ClearFieldsAccessed();
  if (inline_lambda_ != nullptr) inline_lambda_->ClearFieldsAccessed();
}

void ResolvedFunctionArgument::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expr_ != nullptr) expr_->MarkFieldsAccessed();
  if (scan_ != nullptr) scan_->MarkFieldsAccessed();
  if (model_ != nullptr) model_->MarkFieldsAccessed();
  if (connection_ != nullptr) connection_->MarkFieldsAccessed();
  if (descriptor_arg_ != nullptr) descriptor_arg_->MarkFieldsAccessed();
  if (inline_lambda_ != nullptr) inline_lambda_->MarkFieldsAccessed();
}

const ResolvedStatement::ObjectAccess ResolvedStatement::NONE;
const ResolvedStatement::ObjectAccess ResolvedStatement::READ;
const ResolvedStatement::ObjectAccess ResolvedStatement::WRITE;
const ResolvedStatement::ObjectAccess ResolvedStatement::READ_WRITE;

ResolvedStatement::~ResolvedStatement() {
}

absl::Status ResolvedStatement::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedNodeProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_statement_node());
}

absl::Status ResolvedStatement::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedStatementProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : hint_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_hint_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedStatement>> ResolvedStatement::RestoreFrom(
    const AnyResolvedStatementProto& proto,
    const ResolvedNode::RestoreParams& params) {
  switch (proto.node_case()) {
    case AnyResolvedStatementProto::kResolvedExplainStmtNode:
      return ResolvedExplainStmt::RestoreFrom(
          proto.resolved_explain_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedQueryStmtNode:
      return ResolvedQueryStmt::RestoreFrom(
          proto.resolved_query_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedCreateStatementNode:
      return ResolvedCreateStatement::RestoreFrom(
          proto.resolved_create_statement_node(), params);
    case AnyResolvedStatementProto::kResolvedExportDataStmtNode:
      return ResolvedExportDataStmt::RestoreFrom(
          proto.resolved_export_data_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedDefineTableStmtNode:
      return ResolvedDefineTableStmt::RestoreFrom(
          proto.resolved_define_table_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedDescribeStmtNode:
      return ResolvedDescribeStmt::RestoreFrom(
          proto.resolved_describe_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedShowStmtNode:
      return ResolvedShowStmt::RestoreFrom(
          proto.resolved_show_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedBeginStmtNode:
      return ResolvedBeginStmt::RestoreFrom(
          proto.resolved_begin_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedCommitStmtNode:
      return ResolvedCommitStmt::RestoreFrom(
          proto.resolved_commit_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedRollbackStmtNode:
      return ResolvedRollbackStmt::RestoreFrom(
          proto.resolved_rollback_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedDropStmtNode:
      return ResolvedDropStmt::RestoreFrom(
          proto.resolved_drop_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedInsertStmtNode:
      return ResolvedInsertStmt::RestoreFrom(
          proto.resolved_insert_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedDeleteStmtNode:
      return ResolvedDeleteStmt::RestoreFrom(
          proto.resolved_delete_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedUpdateStmtNode:
      return ResolvedUpdateStmt::RestoreFrom(
          proto.resolved_update_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedGrantOrRevokeStmtNode:
      return ResolvedGrantOrRevokeStmt::RestoreFrom(
          proto.resolved_grant_or_revoke_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedAlterTableSetOptionsStmtNode:
      return ResolvedAlterTableSetOptionsStmt::RestoreFrom(
          proto.resolved_alter_table_set_options_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedRenameStmtNode:
      return ResolvedRenameStmt::RestoreFrom(
          proto.resolved_rename_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedCreateRowAccessPolicyStmtNode:
      return ResolvedCreateRowAccessPolicyStmt::RestoreFrom(
          proto.resolved_create_row_access_policy_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedDropRowAccessPolicyStmtNode:
      return ResolvedDropRowAccessPolicyStmt::RestoreFrom(
          proto.resolved_drop_row_access_policy_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedDropFunctionStmtNode:
      return ResolvedDropFunctionStmt::RestoreFrom(
          proto.resolved_drop_function_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedCallStmtNode:
      return ResolvedCallStmt::RestoreFrom(
          proto.resolved_call_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedImportStmtNode:
      return ResolvedImportStmt::RestoreFrom(
          proto.resolved_import_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedModuleStmtNode:
      return ResolvedModuleStmt::RestoreFrom(
          proto.resolved_module_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedCreateDatabaseStmtNode:
      return ResolvedCreateDatabaseStmt::RestoreFrom(
          proto.resolved_create_database_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedAssertStmtNode:
      return ResolvedAssertStmt::RestoreFrom(
          proto.resolved_assert_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedMergeStmtNode:
      return ResolvedMergeStmt::RestoreFrom(
          proto.resolved_merge_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedAlterObjectStmtNode:
      return ResolvedAlterObjectStmt::RestoreFrom(
          proto.resolved_alter_object_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedSetTransactionStmtNode:
      return ResolvedSetTransactionStmt::RestoreFrom(
          proto.resolved_set_transaction_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedDropMaterializedViewStmtNode:
      return ResolvedDropMaterializedViewStmt::RestoreFrom(
          proto.resolved_drop_materialized_view_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedStartBatchStmtNode:
      return ResolvedStartBatchStmt::RestoreFrom(
          proto.resolved_start_batch_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedRunBatchStmtNode:
      return ResolvedRunBatchStmt::RestoreFrom(
          proto.resolved_run_batch_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedAbortBatchStmtNode:
      return ResolvedAbortBatchStmt::RestoreFrom(
          proto.resolved_abort_batch_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedTruncateStmtNode:
      return ResolvedTruncateStmt::RestoreFrom(
          proto.resolved_truncate_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedExecuteImmediateStmtNode:
      return ResolvedExecuteImmediateStmt::RestoreFrom(
          proto.resolved_execute_immediate_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedAssignmentStmtNode:
      return ResolvedAssignmentStmt::RestoreFrom(
          proto.resolved_assignment_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedExportModelStmtNode:
      return ResolvedExportModelStmt::RestoreFrom(
          proto.resolved_export_model_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedDropTableFunctionStmtNode:
      return ResolvedDropTableFunctionStmt::RestoreFrom(
          proto.resolved_drop_table_function_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedCloneDataStmtNode:
      return ResolvedCloneDataStmt::RestoreFrom(
          proto.resolved_clone_data_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedAnalyzeStmtNode:
      return ResolvedAnalyzeStmt::RestoreFrom(
          proto.resolved_analyze_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedDropSnapshotTableStmtNode:
      return ResolvedDropSnapshotTableStmt::RestoreFrom(
          proto.resolved_drop_snapshot_table_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedAuxLoadDataStmtNode:
      return ResolvedAuxLoadDataStmt::RestoreFrom(
          proto.resolved_aux_load_data_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedDropSearchIndexStmtNode:
      return ResolvedDropSearchIndexStmt::RestoreFrom(
          proto.resolved_drop_search_index_stmt_node(), params);
    case AnyResolvedStatementProto::kResolvedDropPrivilegeRestrictionStmtNode:
      return ResolvedDropPrivilegeRestrictionStmt::RestoreFrom(
          proto.resolved_drop_privilege_restriction_stmt_node(), params);
  case AnyResolvedStatementProto::NODE_NOT_SET:
    return ::zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
        << "No subnode types set in ResolvedStatementProto";
  }
}

void ResolvedStatement::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : hint_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedStatement::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : hint_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedStatement::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedStatement(this);
}

absl::Status ResolvedStatement::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : hint_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedStatement::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!hint_list_.empty()) {
    fields->emplace_back("hint_list", hint_list_);
  }
}

absl::Status ResolvedStatement::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : hint_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedStatement::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : hint_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedStatement::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : hint_list_) it->ClearFieldsAccessed();
}

void ResolvedStatement::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : hint_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedExplainStmt::TYPE;

ResolvedExplainStmt::~ResolvedExplainStmt() {
}

absl::Status ResolvedExplainStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_explain_stmt_node());
}

absl::Status ResolvedExplainStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedExplainStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (statement_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(statement_->SaveTo(
        file_descriptor_set_map, proto->mutable_statement()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedExplainStmt>> ResolvedExplainStmt::RestoreFrom(
    const ResolvedExplainStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedStatement> statement;
  if (proto.
  has_statement()) {
    ZETASQL_ASSIGN_OR_RETURN(statement,
                     ResolvedStatement::RestoreFrom(
                         proto.statement(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedExplainStmt(
      std::move(statement));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedExplainStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (statement_ != nullptr) {
    child_nodes->emplace_back(statement_.get());
  }
}

void ResolvedExplainStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (statement_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &statement_));
    static_assert(sizeof(statement_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedExplainStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedExplainStmt(this);
}

absl::Status ResolvedExplainStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (statement_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(statement_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedExplainStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (statement_ != nullptr) {
    fields->emplace_back("statement", statement_.get());
  }
}

absl::Status ResolvedExplainStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedExplainStmt::statement not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (statement_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          statement_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedExplainStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedExplainStmt::statement is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (statement_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(statement_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedExplainStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (statement_ != nullptr) statement_->ClearFieldsAccessed();
}

void ResolvedExplainStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (statement_ != nullptr) statement_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedQueryStmt::TYPE;

ResolvedQueryStmt::~ResolvedQueryStmt() {
}

absl::Status ResolvedQueryStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_query_stmt_node());
}

absl::Status ResolvedQueryStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedQueryStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_output_column_list()));
  }
  proto->set_is_value_table(is_value_table_);
  if (query_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(query_->SaveTo(
        file_descriptor_set_map, proto->mutable_query()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedQueryStmt>> ResolvedQueryStmt::RestoreFrom(
    const ResolvedQueryStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOutputColumn>> output_column_list;
  for (const auto& elem : proto.output_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOutputColumn> elem_restored,
                     ResolvedOutputColumn::RestoreFrom(elem, params));
    output_column_list.push_back(std::move(elem_restored));
  }
  bool is_value_table =
      proto.is_value_table();
  std::unique_ptr<const ResolvedScan> query;
  if (proto.
  has_query()) {
    ZETASQL_ASSIGN_OR_RETURN(query,
                     ResolvedScan::RestoreFrom(
                         proto.query(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedQueryStmt(
      std::move(output_column_list),
      std::move(is_value_table),
      std::move(query));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedQueryStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : output_column_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (query_ != nullptr) {
    child_nodes->emplace_back(query_.get());
  }
}

void ResolvedQueryStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : output_column_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (query_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &query_));
    static_assert(sizeof(query_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedQueryStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedQueryStmt(this);
}

absl::Status ResolvedQueryStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (query_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(query_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedQueryStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!output_column_list_.empty()) {
    fields->emplace_back("output_column_list", output_column_list_);
  }
  if (!IsDefaultValue(is_value_table_)) {
    fields->emplace_back("is_value_table", ToStringImpl(is_value_table_));
  }
  if (query_ != nullptr) {
    fields->emplace_back("query", query_.get());
  }
}

absl::Status ResolvedQueryStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedQueryStmt::output_column_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(is_value_table_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedQueryStmt::is_value_table not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedQueryStmt::query not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (query_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          query_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedQueryStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedQueryStmt::output_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedQueryStmt::is_value_table is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedQueryStmt::query is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (query_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(query_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedQueryStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : output_column_list_) it->ClearFieldsAccessed();
  if (query_ != nullptr) query_->ClearFieldsAccessed();
}

void ResolvedQueryStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : output_column_list_) it->MarkFieldsAccessed();
  if (query_ != nullptr) query_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCreateDatabaseStmt::TYPE;

ResolvedCreateDatabaseStmt::~ResolvedCreateDatabaseStmt() {
}

absl::Status ResolvedCreateDatabaseStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_database_stmt_node());
}

absl::Status ResolvedCreateDatabaseStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateDatabaseStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateDatabaseStmt>> ResolvedCreateDatabaseStmt::RestoreFrom(
    const ResolvedCreateDatabaseStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::string> name_path;
  for (const auto& elem : proto.name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedCreateDatabaseStmt(
      std::move(name_path),
      std::move(option_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCreateDatabaseStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedCreateDatabaseStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedCreateDatabaseStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateDatabaseStmt(this);
}

absl::Status ResolvedCreateDatabaseStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreateDatabaseStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
}

absl::Status ResolvedCreateDatabaseStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateDatabaseStmt::name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateDatabaseStmt::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateDatabaseStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateDatabaseStmt::name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateDatabaseStmt::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreateDatabaseStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
}

void ResolvedCreateDatabaseStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
}

const ResolvedCreateStatement::CreateScope ResolvedCreateStatement::CREATE_DEFAULT_SCOPE;
const ResolvedCreateStatement::CreateScope ResolvedCreateStatement::CREATE_PRIVATE;
const ResolvedCreateStatement::CreateScope ResolvedCreateStatement::CREATE_PUBLIC;
const ResolvedCreateStatement::CreateScope ResolvedCreateStatement::CREATE_TEMP;
const ResolvedCreateStatement::CreateMode ResolvedCreateStatement::CREATE_DEFAULT;
const ResolvedCreateStatement::CreateMode ResolvedCreateStatement::CREATE_OR_REPLACE;
const ResolvedCreateStatement::CreateMode ResolvedCreateStatement::CREATE_IF_NOT_EXISTS;
const ResolvedCreateStatement::SqlSecurity ResolvedCreateStatement::SQL_SECURITY_UNSPECIFIED;
const ResolvedCreateStatement::SqlSecurity ResolvedCreateStatement::SQL_SECURITY_DEFINER;
const ResolvedCreateStatement::SqlSecurity ResolvedCreateStatement::SQL_SECURITY_INVOKER;
const ResolvedCreateStatement::DeterminismLevel ResolvedCreateStatement::DETERMINISM_UNSPECIFIED;
const ResolvedCreateStatement::DeterminismLevel ResolvedCreateStatement::DETERMINISM_DETERMINISTIC;
const ResolvedCreateStatement::DeterminismLevel ResolvedCreateStatement::DETERMINISM_NOT_DETERMINISTIC;
const ResolvedCreateStatement::DeterminismLevel ResolvedCreateStatement::DETERMINISM_IMMUTABLE;
const ResolvedCreateStatement::DeterminismLevel ResolvedCreateStatement::DETERMINISM_STABLE;
const ResolvedCreateStatement::DeterminismLevel ResolvedCreateStatement::DETERMINISM_VOLATILE;

ResolvedCreateStatement::~ResolvedCreateStatement() {
}

absl::Status ResolvedCreateStatement::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_statement_node());
}

absl::Status ResolvedCreateStatement::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateStatementProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  proto->set_create_scope(create_scope_);
  proto->set_create_mode(create_mode_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateStatement>> ResolvedCreateStatement::RestoreFrom(
    const AnyResolvedCreateStatementProto& proto,
    const ResolvedNode::RestoreParams& params) {
  switch (proto.node_case()) {
    case AnyResolvedCreateStatementProto::kResolvedCreateFunctionStmtNode:
      return ResolvedCreateFunctionStmt::RestoreFrom(
          proto.resolved_create_function_stmt_node(), params);
    case AnyResolvedCreateStatementProto::kResolvedCreateTableFunctionStmtNode:
      return ResolvedCreateTableFunctionStmt::RestoreFrom(
          proto.resolved_create_table_function_stmt_node(), params);
    case AnyResolvedCreateStatementProto::kResolvedCreateIndexStmtNode:
      return ResolvedCreateIndexStmt::RestoreFrom(
          proto.resolved_create_index_stmt_node(), params);
    case AnyResolvedCreateStatementProto::kResolvedCreateConstantStmtNode:
      return ResolvedCreateConstantStmt::RestoreFrom(
          proto.resolved_create_constant_stmt_node(), params);
    case AnyResolvedCreateStatementProto::kResolvedCreateTableStmtBaseNode:
      return ResolvedCreateTableStmtBase::RestoreFrom(
          proto.resolved_create_table_stmt_base_node(), params);
    case AnyResolvedCreateStatementProto::kResolvedCreateModelStmtNode:
      return ResolvedCreateModelStmt::RestoreFrom(
          proto.resolved_create_model_stmt_node(), params);
    case AnyResolvedCreateStatementProto::kResolvedCreateViewBaseNode:
      return ResolvedCreateViewBase::RestoreFrom(
          proto.resolved_create_view_base_node(), params);
    case AnyResolvedCreateStatementProto::kResolvedCreateProcedureStmtNode:
      return ResolvedCreateProcedureStmt::RestoreFrom(
          proto.resolved_create_procedure_stmt_node(), params);
    case AnyResolvedCreateStatementProto::kResolvedCreateEntityStmtNode:
      return ResolvedCreateEntityStmt::RestoreFrom(
          proto.resolved_create_entity_stmt_node(), params);
    case AnyResolvedCreateStatementProto::kResolvedCreateSchemaStmtNode:
      return ResolvedCreateSchemaStmt::RestoreFrom(
          proto.resolved_create_schema_stmt_node(), params);
    case AnyResolvedCreateStatementProto::kResolvedCreateSnapshotTableStmtNode:
      return ResolvedCreateSnapshotTableStmt::RestoreFrom(
          proto.resolved_create_snapshot_table_stmt_node(), params);
    case AnyResolvedCreateStatementProto::kResolvedCreatePrivilegeRestrictionStmtNode:
      return ResolvedCreatePrivilegeRestrictionStmt::RestoreFrom(
          proto.resolved_create_privilege_restriction_stmt_node(), params);
  case AnyResolvedCreateStatementProto::NODE_NOT_SET:
    return ::zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
        << "No subnode types set in ResolvedCreateStatementProto";
  }
}

void ResolvedCreateStatement::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedCreateStatement::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedCreateStatement::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateStatement(this);
}

absl::Status ResolvedCreateStatement::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedCreateStatement::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(name_path_)) {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
  if (!IsDefaultValue(create_scope_)) {
    fields->emplace_back("create_scope", ToStringImpl(create_scope_));
  }
  if (!IsDefaultValue(create_mode_)) {
    fields->emplace_back("create_mode", ToStringImpl(create_mode_));
  }
}

absl::Status ResolvedCreateStatement::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(name_path_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateStatement::name_path not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(create_scope_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateStatement::create_scope not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(create_mode_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateStatement::create_mode not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateStatement::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateStatement::name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateStatement::create_scope is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateStatement::create_mode is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedCreateStatement::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedCreateStatement::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedIndexItem::TYPE;

ResolvedIndexItem::~ResolvedIndexItem() {
}

absl::Status ResolvedIndexItem::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_index_item_node());
}

absl::Status ResolvedIndexItem::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedIndexItemProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (column_ref_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(column_ref_->SaveTo(
        file_descriptor_set_map, proto->mutable_column_ref()));
  }
  proto->set_descending(descending_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedIndexItem>> ResolvedIndexItem::RestoreFrom(
    const ResolvedIndexItemProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedColumnRef> column_ref;
  if (proto.
  has_column_ref()) {
    ZETASQL_ASSIGN_OR_RETURN(column_ref,
                     ResolvedColumnRef::RestoreFrom(
                         proto.column_ref(), params));
  }
  bool descending =
      proto.descending();
  auto node = MakeResolvedIndexItem(
      std::move(column_ref),
      std::move(descending));

  return node;
}

void ResolvedIndexItem::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (column_ref_ != nullptr) {
    child_nodes->emplace_back(column_ref_.get());
  }
}

void ResolvedIndexItem::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (column_ref_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &column_ref_));
    static_assert(sizeof(column_ref_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedIndexItem::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedIndexItem(this);
}

absl::Status ResolvedIndexItem::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (column_ref_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(column_ref_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedIndexItem::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (column_ref_ != nullptr) {
    fields->emplace_back("column_ref", column_ref_.get());
  }
  {
    fields->emplace_back("descending", ToStringImpl(descending_));
  }
}

absl::Status ResolvedIndexItem::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedIndexItem::column_ref not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedIndexItem::descending not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (column_ref_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          column_ref_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedIndexItem::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedIndexItem::column_ref is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedIndexItem::descending is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (column_ref_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(column_ref_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedIndexItem::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (column_ref_ != nullptr) column_ref_->ClearFieldsAccessed();
}

void ResolvedIndexItem::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (column_ref_ != nullptr) column_ref_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedUnnestItem::TYPE;

ResolvedUnnestItem::~ResolvedUnnestItem() {
}

absl::Status ResolvedUnnestItem::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_unnest_item_node());
}

absl::Status ResolvedUnnestItem::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedUnnestItemProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (array_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(array_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_array_expr()));
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      element_column_, file_descriptor_set_map,
      proto->mutable_element_column()));
  if (array_offset_column_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(array_offset_column_->SaveTo(
        file_descriptor_set_map, proto->mutable_array_offset_column()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedUnnestItem>> ResolvedUnnestItem::RestoreFrom(
    const ResolvedUnnestItemProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> array_expr;
  if (proto.
  has_array_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(array_expr,
                     ResolvedExpr::RestoreFrom(
                         proto.array_expr(), params));
  }
  ZETASQL_ASSIGN_OR_RETURN(auto element_column,
                   RestoreFromImpl<ResolvedColumn>(
                       proto.element_column(),
                       params));
  std::unique_ptr<const ResolvedColumnHolder> array_offset_column;
  if (proto.
  has_array_offset_column()) {
    ZETASQL_ASSIGN_OR_RETURN(array_offset_column,
                     ResolvedColumnHolder::RestoreFrom(
                         proto.array_offset_column(), params));
  }
  auto node = MakeResolvedUnnestItem(
      std::move(array_expr),
      std::move(element_column),
      std::move(array_offset_column));

  return node;
}

void ResolvedUnnestItem::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (array_expr_ != nullptr) {
    child_nodes->emplace_back(array_expr_.get());
  }
  if (array_offset_column_ != nullptr) {
    child_nodes->emplace_back(array_offset_column_.get());
  }
}

void ResolvedUnnestItem::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (array_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &array_expr_));
    static_assert(sizeof(array_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (array_offset_column_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &array_offset_column_));
    static_assert(sizeof(array_offset_column_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedUnnestItem::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedUnnestItem(this);
}

absl::Status ResolvedUnnestItem::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (array_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(array_expr_.get()->Accept(visitor));
  }
  if (array_offset_column_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(array_offset_column_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedUnnestItem::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (array_expr_ != nullptr) {
    fields->emplace_back("array_expr", array_expr_.get());
  }
  {
    fields->emplace_back("element_column", ToStringImpl(element_column_));
  }
  if (array_offset_column_ != nullptr) {
    fields->emplace_back("array_offset_column", array_offset_column_.get());
  }
}

absl::Status ResolvedUnnestItem::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUnnestItem::array_expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUnnestItem::element_column not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(array_offset_column_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUnnestItem::array_offset_column not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (array_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          array_expr_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (array_offset_column_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          array_offset_column_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedUnnestItem::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUnnestItem::array_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUnnestItem::element_column is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUnnestItem::array_offset_column is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (array_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(array_expr_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (array_offset_column_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(array_offset_column_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedUnnestItem::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (array_expr_ != nullptr) array_expr_->ClearFieldsAccessed();
  if (array_offset_column_ != nullptr) array_offset_column_->ClearFieldsAccessed();
}

void ResolvedUnnestItem::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (array_expr_ != nullptr) array_expr_->MarkFieldsAccessed();
  if (array_offset_column_ != nullptr) array_offset_column_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCreateIndexStmt::TYPE;

ResolvedCreateIndexStmt::~ResolvedCreateIndexStmt() {
}

absl::Status ResolvedCreateIndexStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedCreateStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_index_stmt_node());
}

absl::Status ResolvedCreateIndexStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateIndexStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : table_name_path_) {
    proto->add_table_name_path(elem);
  }
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_table_scan()));
  }
  proto->set_is_unique(is_unique_);
  proto->set_is_search(is_search_);
  proto->set_index_all_columns(index_all_columns_);
  for (const auto& elem : index_item_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_index_item_list()));
  }
  for (const auto& elem : storing_expression_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_storing_expression_list()));
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  for (const auto& elem : computed_columns_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_computed_columns_list()));
  }
  for (const auto& elem : unnest_expressions_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_unnest_expressions_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateIndexStmt>> ResolvedCreateIndexStmt::RestoreFrom(
    const ResolvedCreateIndexStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::string> table_name_path;
  for (const auto& elem : proto.table_name_path()) {
    table_name_path.push_back(elem);
  }
  std::unique_ptr<const ResolvedTableScan> table_scan;
  if (proto.
  has_table_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(table_scan,
                     ResolvedTableScan::RestoreFrom(
                         proto.table_scan(), params));
  }
  bool is_unique =
      proto.is_unique();
  bool is_search =
      proto.is_search();
  bool index_all_columns =
      proto.index_all_columns();
  std::vector<std::unique_ptr<const ResolvedIndexItem>> index_item_list;
  for (const auto& elem : proto.index_item_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedIndexItem> elem_restored,
                     ResolvedIndexItem::RestoreFrom(elem, params));
    index_item_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedExpr>> storing_expression_list;
  for (const auto& elem : proto.storing_expression_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    storing_expression_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedComputedColumn>> computed_columns_list;
  for (const auto& elem : proto.computed_columns_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedComputedColumn> elem_restored,
                     ResolvedComputedColumn::RestoreFrom(elem, params));
    computed_columns_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedUnnestItem>> unnest_expressions_list;
  for (const auto& elem : proto.unnest_expressions_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedUnnestItem> elem_restored,
                     ResolvedUnnestItem::RestoreFrom(elem, params));
    unnest_expressions_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  CreateScope create_scope =
      proto.parent().create_scope();
  CreateMode create_mode =
      proto.parent().create_mode();
  auto node = MakeResolvedCreateIndexStmt(
      std::move(name_path),
      std::move(create_scope),
      std::move(create_mode),
      std::move(table_name_path),
      std::move(table_scan),
      std::move(is_unique),
      std::move(is_search),
      std::move(index_all_columns),
      std::move(index_item_list),
      std::move(storing_expression_list),
      std::move(option_list),
      std::move(computed_columns_list),
      std::move(unnest_expressions_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCreateIndexStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (table_scan_ != nullptr) {
    child_nodes->emplace_back(table_scan_.get());
  }
  for (const auto& elem : index_item_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : storing_expression_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : computed_columns_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : unnest_expressions_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedCreateIndexStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (table_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &table_scan_));
    static_assert(sizeof(table_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : index_item_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : storing_expression_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : computed_columns_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : unnest_expressions_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedCreateIndexStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateIndexStmt(this);
}

absl::Status ResolvedCreateIndexStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_.get()->Accept(visitor));
  }
  for (const auto& elem : index_item_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : storing_expression_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : computed_columns_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : unnest_expressions_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreateIndexStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("table_name_path", ToStringImpl(table_name_path_));
  }
  if (table_scan_ != nullptr) {
    fields->emplace_back("table_scan", table_scan_.get());
  }
  {
    fields->emplace_back("is_unique", ToStringImpl(is_unique_));
  }
  if (!IsDefaultValue(is_search_)) {
    fields->emplace_back("is_search", ToStringImpl(is_search_));
  }
  if (!IsDefaultValue(index_all_columns_)) {
    fields->emplace_back("index_all_columns", ToStringImpl(index_all_columns_));
  }
  if (!index_item_list_.empty()) {
    fields->emplace_back("index_item_list", index_item_list_);
  }
  if (!storing_expression_list_.empty()) {
    fields->emplace_back("storing_expression_list", storing_expression_list_);
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
  if (!computed_columns_list_.empty()) {
    fields->emplace_back("computed_columns_list", computed_columns_list_);
  }
  if (!unnest_expressions_list_.empty()) {
    fields->emplace_back("unnest_expressions_list", unnest_expressions_list_);
  }
}

absl::Status ResolvedCreateIndexStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateIndexStmt::table_name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateIndexStmt::is_unique not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(is_search_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateIndexStmt::is_search not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(index_all_columns_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateIndexStmt::index_all_columns not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateIndexStmt::index_item_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<6)) == 0 &&
      !IsDefaultValue(storing_expression_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateIndexStmt::storing_expression_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<7)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateIndexStmt::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<8)) == 0 &&
      !IsDefaultValue(computed_columns_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateIndexStmt::computed_columns_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<9)) == 0 &&
      !IsDefaultValue(unnest_expressions_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateIndexStmt::unnest_expressions_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          table_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : index_item_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    for (const auto& it : storing_expression_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<7)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<8)) != 0) {
    for (const auto& it : computed_columns_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<9)) != 0) {
    for (const auto& it : unnest_expressions_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateIndexStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateIndexStmt::table_name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateIndexStmt::is_unique is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateIndexStmt::is_search is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateIndexStmt::index_all_columns is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateIndexStmt::index_item_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<6)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateIndexStmt::storing_expression_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<7)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateIndexStmt::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<8)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateIndexStmt::computed_columns_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<9)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateIndexStmt::unnest_expressions_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(table_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : index_item_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    for (const auto& it : storing_expression_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<7)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<8)) != 0) {
    for (const auto& it : computed_columns_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<9)) != 0) {
    for (const auto& it : unnest_expressions_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreateIndexStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (table_scan_ != nullptr) table_scan_->ClearFieldsAccessed();
  for (const auto& it : index_item_list_) it->ClearFieldsAccessed();
  for (const auto& it : storing_expression_list_) it->ClearFieldsAccessed();
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
  for (const auto& it : computed_columns_list_) it->ClearFieldsAccessed();
  for (const auto& it : unnest_expressions_list_) it->ClearFieldsAccessed();
}

void ResolvedCreateIndexStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (table_scan_ != nullptr) table_scan_->MarkFieldsAccessed();
  for (const auto& it : index_item_list_) it->MarkFieldsAccessed();
  for (const auto& it : storing_expression_list_) it->MarkFieldsAccessed();
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
  for (const auto& it : computed_columns_list_) it->MarkFieldsAccessed();
  for (const auto& it : unnest_expressions_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCreateSchemaStmt::TYPE;

ResolvedCreateSchemaStmt::~ResolvedCreateSchemaStmt() {
}

absl::Status ResolvedCreateSchemaStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedCreateStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_schema_stmt_node());
}

absl::Status ResolvedCreateSchemaStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateSchemaStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (collation_name_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(collation_name_->SaveTo(
        file_descriptor_set_map, proto->mutable_collation_name()));
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateSchemaStmt>> ResolvedCreateSchemaStmt::RestoreFrom(
    const ResolvedCreateSchemaStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> collation_name;
  if (proto.
  has_collation_name()) {
    ZETASQL_ASSIGN_OR_RETURN(collation_name,
                     ResolvedExpr::RestoreFrom(
                         proto.collation_name(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  CreateScope create_scope =
      proto.parent().create_scope();
  CreateMode create_mode =
      proto.parent().create_mode();
  auto node = MakeResolvedCreateSchemaStmt(
      std::move(name_path),
      std::move(create_scope),
      std::move(create_mode),
      std::move(collation_name),
      std::move(option_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCreateSchemaStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (collation_name_ != nullptr) {
    child_nodes->emplace_back(collation_name_.get());
  }
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedCreateSchemaStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (collation_name_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &collation_name_));
    static_assert(sizeof(collation_name_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedCreateSchemaStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateSchemaStmt(this);
}

absl::Status ResolvedCreateSchemaStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (collation_name_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(collation_name_.get()->Accept(visitor));
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreateSchemaStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (collation_name_ != nullptr) {
    fields->emplace_back("collation_name", collation_name_.get());
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
}

absl::Status ResolvedCreateSchemaStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(collation_name_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateSchemaStmt::collation_name not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateSchemaStmt::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (collation_name_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          collation_name_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateSchemaStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateSchemaStmt::collation_name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateSchemaStmt::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (collation_name_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(collation_name_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreateSchemaStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (collation_name_ != nullptr) collation_name_->ClearFieldsAccessed();
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
}

void ResolvedCreateSchemaStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (collation_name_ != nullptr) collation_name_->MarkFieldsAccessed();
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
}

ResolvedCreateTableStmtBase::~ResolvedCreateTableStmtBase() {
}

absl::Status ResolvedCreateTableStmtBase::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedCreateStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_table_stmt_base_node());
}

absl::Status ResolvedCreateTableStmtBase::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateTableStmtBaseProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  for (const auto& elem : column_definition_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_column_definition_list()));
  }
  for (const auto& elem : pseudo_column_list_) {
    ZETASQL_RETURN_IF_ERROR(SaveToImpl(
        elem, file_descriptor_set_map, proto->add_pseudo_column_list()));
  }
  if (primary_key_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(primary_key_->SaveTo(
        file_descriptor_set_map, proto->mutable_primary_key()));
  }
  for (const auto& elem : foreign_key_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_foreign_key_list()));
  }
  for (const auto& elem : check_constraint_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_check_constraint_list()));
  }
  proto->set_is_value_table(is_value_table_);
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      like_table_, file_descriptor_set_map,
      proto->mutable_like_table()));
  if (collation_name_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(collation_name_->SaveTo(
        file_descriptor_set_map, proto->mutable_collation_name()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateTableStmtBase>> ResolvedCreateTableStmtBase::RestoreFrom(
    const AnyResolvedCreateTableStmtBaseProto& proto,
    const ResolvedNode::RestoreParams& params) {
  switch (proto.node_case()) {
    case AnyResolvedCreateTableStmtBaseProto::kResolvedCreateTableAsSelectStmtNode:
      return ResolvedCreateTableAsSelectStmt::RestoreFrom(
          proto.resolved_create_table_as_select_stmt_node(), params);
    case AnyResolvedCreateTableStmtBaseProto::kResolvedCreateExternalTableStmtNode:
      return ResolvedCreateExternalTableStmt::RestoreFrom(
          proto.resolved_create_external_table_stmt_node(), params);
    case AnyResolvedCreateTableStmtBaseProto::kResolvedCreateTableStmtNode:
      return ResolvedCreateTableStmt::RestoreFrom(
          proto.resolved_create_table_stmt_node(), params);
  case AnyResolvedCreateTableStmtBaseProto::NODE_NOT_SET:
    return ::zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
        << "No subnode types set in ResolvedCreateTableStmtBaseProto";
  }
}

void ResolvedCreateTableStmtBase::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : column_definition_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (primary_key_ != nullptr) {
    child_nodes->emplace_back(primary_key_.get());
  }
  for (const auto& elem : foreign_key_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : check_constraint_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (collation_name_ != nullptr) {
    child_nodes->emplace_back(collation_name_.get());
  }
}

void ResolvedCreateTableStmtBase::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : column_definition_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (primary_key_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &primary_key_));
    static_assert(sizeof(primary_key_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : foreign_key_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : check_constraint_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (collation_name_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &collation_name_));
    static_assert(sizeof(collation_name_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedCreateTableStmtBase::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateTableStmtBase(this);
}

absl::Status ResolvedCreateTableStmtBase::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : column_definition_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (primary_key_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(primary_key_.get()->Accept(visitor));
  }
  for (const auto& elem : foreign_key_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : check_constraint_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (collation_name_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(collation_name_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreateTableStmtBase::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
  if (!column_definition_list_.empty()) {
    fields->emplace_back("column_definition_list", column_definition_list_);
  }
  if (!IsDefaultValue(pseudo_column_list_)) {
    fields->emplace_back("pseudo_column_list", ToStringImpl(pseudo_column_list_));
  }
  if (primary_key_ != nullptr) {
    fields->emplace_back("primary_key", primary_key_.get());
  }
  if (!foreign_key_list_.empty()) {
    fields->emplace_back("foreign_key_list", foreign_key_list_);
  }
  if (!check_constraint_list_.empty()) {
    fields->emplace_back("check_constraint_list", check_constraint_list_);
  }
  if (!IsDefaultValue(is_value_table_)) {
    fields->emplace_back("is_value_table", ToStringImpl(is_value_table_));
  }
  if (!IsDefaultValue(like_table_)) {
    fields->emplace_back("like_table", ToStringImpl(like_table_));
  }
  if (collation_name_ != nullptr) {
    fields->emplace_back("collation_name", collation_name_.get());
  }
}

absl::Status ResolvedCreateTableStmtBase::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableStmtBase::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(primary_key_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableStmtBase::primary_key not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(foreign_key_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableStmtBase::foreign_key_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0 &&
      !IsDefaultValue(check_constraint_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableStmtBase::check_constraint_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<6)) == 0 &&
      !IsDefaultValue(is_value_table_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableStmtBase::is_value_table not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<7)) == 0 &&
      !IsDefaultValue(like_table_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableStmtBase::like_table not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<8)) == 0 &&
      !IsDefaultValue(collation_name_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableStmtBase::collation_name not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : column_definition_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (primary_key_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          primary_key_.get(), root));
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    for (const auto& it : foreign_key_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : check_constraint_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<8)) != 0) {
    if (collation_name_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          collation_name_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateTableStmtBase::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableStmtBase::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableStmtBase::primary_key is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableStmtBase::foreign_key_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableStmtBase::check_constraint_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<6)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableStmtBase::is_value_table is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<7)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableStmtBase::like_table is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<8)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableStmtBase::collation_name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : column_definition_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (primary_key_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(primary_key_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    for (const auto& it : foreign_key_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : check_constraint_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<8)) != 0) {
    if (collation_name_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(collation_name_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreateTableStmtBase::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
  for (const auto& it : column_definition_list_) it->ClearFieldsAccessed();
  if (primary_key_ != nullptr) primary_key_->ClearFieldsAccessed();
  for (const auto& it : foreign_key_list_) it->ClearFieldsAccessed();
  for (const auto& it : check_constraint_list_) it->ClearFieldsAccessed();
  if (collation_name_ != nullptr) collation_name_->ClearFieldsAccessed();
}

void ResolvedCreateTableStmtBase::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
  for (const auto& it : column_definition_list_) it->MarkFieldsAccessed();
  if (primary_key_ != nullptr) primary_key_->MarkFieldsAccessed();
  for (const auto& it : foreign_key_list_) it->MarkFieldsAccessed();
  for (const auto& it : check_constraint_list_) it->MarkFieldsAccessed();
  if (collation_name_ != nullptr) collation_name_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCreateTableStmt::TYPE;

ResolvedCreateTableStmt::~ResolvedCreateTableStmt() {
}

absl::Status ResolvedCreateTableStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedCreateTableStmtBaseProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_table_stmt_node());
}

absl::Status ResolvedCreateTableStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateTableStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (clone_from_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(clone_from_->SaveTo(
        file_descriptor_set_map, proto->mutable_clone_from()));
  }
  if (copy_from_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(copy_from_->SaveTo(
        file_descriptor_set_map, proto->mutable_copy_from()));
  }
  for (const auto& elem : partition_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_partition_by_list()));
  }
  for (const auto& elem : cluster_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_cluster_by_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateTableStmt>> ResolvedCreateTableStmt::RestoreFrom(
    const ResolvedCreateTableStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedScan> clone_from;
  if (proto.
  has_clone_from()) {
    ZETASQL_ASSIGN_OR_RETURN(clone_from,
                     ResolvedScan::RestoreFrom(
                         proto.clone_from(), params));
  }
  std::unique_ptr<const ResolvedScan> copy_from;
  if (proto.
  has_copy_from()) {
    ZETASQL_ASSIGN_OR_RETURN(copy_from,
                     ResolvedScan::RestoreFrom(
                         proto.copy_from(), params));
  }
  std::vector<std::unique_ptr<const ResolvedExpr>> partition_by_list;
  for (const auto& elem : proto.partition_by_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    partition_by_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedExpr>> cluster_by_list;
  for (const auto& elem : proto.cluster_by_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    cluster_by_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().parent().name_path()) {
    name_path.push_back(elem);
  }
  CreateScope create_scope =
      proto.parent().parent().create_scope();
  CreateMode create_mode =
      proto.parent().parent().create_mode();
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.parent().option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedColumnDefinition>> column_definition_list;
  for (const auto& elem : proto.parent().column_definition_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedColumnDefinition> elem_restored,
                     ResolvedColumnDefinition::RestoreFrom(elem, params));
    column_definition_list.push_back(std::move(elem_restored));
  }
  std::vector<ResolvedColumn> pseudo_column_list;
  for (const auto& elem : proto.parent().pseudo_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    pseudo_column_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedPrimaryKey> primary_key;
  if (proto.parent().
  has_primary_key()) {
    ZETASQL_ASSIGN_OR_RETURN(primary_key,
                     ResolvedPrimaryKey::RestoreFrom(
                         proto.parent().primary_key(), params));
  }
  std::vector<std::unique_ptr<const ResolvedForeignKey>> foreign_key_list;
  for (const auto& elem : proto.parent().foreign_key_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedForeignKey> elem_restored,
                     ResolvedForeignKey::RestoreFrom(elem, params));
    foreign_key_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedCheckConstraint>> check_constraint_list;
  for (const auto& elem : proto.parent().check_constraint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedCheckConstraint> elem_restored,
                     ResolvedCheckConstraint::RestoreFrom(elem, params));
    check_constraint_list.push_back(std::move(elem_restored));
  }
  bool is_value_table =
      proto.parent().is_value_table();
  ZETASQL_ASSIGN_OR_RETURN(auto like_table,
                   RestoreFromImpl<const Table*>(
                       proto.parent().like_table(),
                       params));
  std::unique_ptr<const ResolvedExpr> collation_name;
  if (proto.parent().
  has_collation_name()) {
    ZETASQL_ASSIGN_OR_RETURN(collation_name,
                     ResolvedExpr::RestoreFrom(
                         proto.parent().collation_name(), params));
  }
  auto node = MakeResolvedCreateTableStmt(
      std::move(name_path),
      std::move(create_scope),
      std::move(create_mode),
      std::move(option_list),
      std::move(column_definition_list),
      std::move(pseudo_column_list),
      std::move(primary_key),
      std::move(foreign_key_list),
      std::move(check_constraint_list),
      std::move(is_value_table),
      std::move(like_table),
      std::move(collation_name),
      std::move(clone_from),
      std::move(copy_from),
      std::move(partition_by_list),
      std::move(cluster_by_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCreateTableStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (clone_from_ != nullptr) {
    child_nodes->emplace_back(clone_from_.get());
  }
  if (copy_from_ != nullptr) {
    child_nodes->emplace_back(copy_from_.get());
  }
  for (const auto& elem : partition_by_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : cluster_by_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedCreateTableStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (clone_from_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &clone_from_));
    static_assert(sizeof(clone_from_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (copy_from_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &copy_from_));
    static_assert(sizeof(copy_from_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : partition_by_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : cluster_by_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedCreateTableStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateTableStmt(this);
}

absl::Status ResolvedCreateTableStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (clone_from_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(clone_from_.get()->Accept(visitor));
  }
  if (copy_from_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(copy_from_.get()->Accept(visitor));
  }
  for (const auto& elem : partition_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : cluster_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreateTableStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (clone_from_ != nullptr) {
    fields->emplace_back("clone_from", clone_from_.get());
  }
  if (copy_from_ != nullptr) {
    fields->emplace_back("copy_from", copy_from_.get());
  }
  if (!partition_by_list_.empty()) {
    fields->emplace_back("partition_by_list", partition_by_list_);
  }
  if (!cluster_by_list_.empty()) {
    fields->emplace_back("cluster_by_list", cluster_by_list_);
  }
}

absl::Status ResolvedCreateTableStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(clone_from_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableStmt::clone_from not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(copy_from_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableStmt::copy_from not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(partition_by_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableStmt::partition_by_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(cluster_by_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableStmt::cluster_by_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (clone_from_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          clone_from_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (copy_from_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          copy_from_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : partition_by_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : cluster_by_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateTableStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableStmt::clone_from is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableStmt::copy_from is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableStmt::partition_by_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableStmt::cluster_by_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (clone_from_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(clone_from_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (copy_from_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(copy_from_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : partition_by_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : cluster_by_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreateTableStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (clone_from_ != nullptr) clone_from_->ClearFieldsAccessed();
  if (copy_from_ != nullptr) copy_from_->ClearFieldsAccessed();
  for (const auto& it : partition_by_list_) it->ClearFieldsAccessed();
  for (const auto& it : cluster_by_list_) it->ClearFieldsAccessed();
}

void ResolvedCreateTableStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (clone_from_ != nullptr) clone_from_->MarkFieldsAccessed();
  if (copy_from_ != nullptr) copy_from_->MarkFieldsAccessed();
  for (const auto& it : partition_by_list_) it->MarkFieldsAccessed();
  for (const auto& it : cluster_by_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCreateTableAsSelectStmt::TYPE;

ResolvedCreateTableAsSelectStmt::~ResolvedCreateTableAsSelectStmt() {
}

absl::Status ResolvedCreateTableAsSelectStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedCreateTableStmtBaseProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_table_as_select_stmt_node());
}

absl::Status ResolvedCreateTableAsSelectStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateTableAsSelectStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : partition_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_partition_by_list()));
  }
  for (const auto& elem : cluster_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_cluster_by_list()));
  }
  for (const auto& elem : output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_output_column_list()));
  }
  if (query_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(query_->SaveTo(
        file_descriptor_set_map, proto->mutable_query()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateTableAsSelectStmt>> ResolvedCreateTableAsSelectStmt::RestoreFrom(
    const ResolvedCreateTableAsSelectStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedExpr>> partition_by_list;
  for (const auto& elem : proto.partition_by_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    partition_by_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedExpr>> cluster_by_list;
  for (const auto& elem : proto.cluster_by_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    cluster_by_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOutputColumn>> output_column_list;
  for (const auto& elem : proto.output_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOutputColumn> elem_restored,
                     ResolvedOutputColumn::RestoreFrom(elem, params));
    output_column_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedScan> query;
  if (proto.
  has_query()) {
    ZETASQL_ASSIGN_OR_RETURN(query,
                     ResolvedScan::RestoreFrom(
                         proto.query(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().parent().name_path()) {
    name_path.push_back(elem);
  }
  CreateScope create_scope =
      proto.parent().parent().create_scope();
  CreateMode create_mode =
      proto.parent().parent().create_mode();
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.parent().option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedColumnDefinition>> column_definition_list;
  for (const auto& elem : proto.parent().column_definition_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedColumnDefinition> elem_restored,
                     ResolvedColumnDefinition::RestoreFrom(elem, params));
    column_definition_list.push_back(std::move(elem_restored));
  }
  std::vector<ResolvedColumn> pseudo_column_list;
  for (const auto& elem : proto.parent().pseudo_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    pseudo_column_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedPrimaryKey> primary_key;
  if (proto.parent().
  has_primary_key()) {
    ZETASQL_ASSIGN_OR_RETURN(primary_key,
                     ResolvedPrimaryKey::RestoreFrom(
                         proto.parent().primary_key(), params));
  }
  std::vector<std::unique_ptr<const ResolvedForeignKey>> foreign_key_list;
  for (const auto& elem : proto.parent().foreign_key_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedForeignKey> elem_restored,
                     ResolvedForeignKey::RestoreFrom(elem, params));
    foreign_key_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedCheckConstraint>> check_constraint_list;
  for (const auto& elem : proto.parent().check_constraint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedCheckConstraint> elem_restored,
                     ResolvedCheckConstraint::RestoreFrom(elem, params));
    check_constraint_list.push_back(std::move(elem_restored));
  }
  bool is_value_table =
      proto.parent().is_value_table();
  ZETASQL_ASSIGN_OR_RETURN(auto like_table,
                   RestoreFromImpl<const Table*>(
                       proto.parent().like_table(),
                       params));
  std::unique_ptr<const ResolvedExpr> collation_name;
  if (proto.parent().
  has_collation_name()) {
    ZETASQL_ASSIGN_OR_RETURN(collation_name,
                     ResolvedExpr::RestoreFrom(
                         proto.parent().collation_name(), params));
  }
  auto node = MakeResolvedCreateTableAsSelectStmt(
      std::move(name_path),
      std::move(create_scope),
      std::move(create_mode),
      std::move(option_list),
      std::move(column_definition_list),
      std::move(pseudo_column_list),
      std::move(primary_key),
      std::move(foreign_key_list),
      std::move(check_constraint_list),
      std::move(is_value_table),
      std::move(like_table),
      std::move(collation_name),
      std::move(partition_by_list),
      std::move(cluster_by_list),
      std::move(output_column_list),
      std::move(query));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCreateTableAsSelectStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : partition_by_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : cluster_by_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : output_column_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (query_ != nullptr) {
    child_nodes->emplace_back(query_.get());
  }
}

void ResolvedCreateTableAsSelectStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : partition_by_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : cluster_by_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : output_column_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (query_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &query_));
    static_assert(sizeof(query_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedCreateTableAsSelectStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateTableAsSelectStmt(this);
}

absl::Status ResolvedCreateTableAsSelectStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : partition_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : cluster_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (query_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(query_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreateTableAsSelectStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!partition_by_list_.empty()) {
    fields->emplace_back("partition_by_list", partition_by_list_);
  }
  if (!cluster_by_list_.empty()) {
    fields->emplace_back("cluster_by_list", cluster_by_list_);
  }
  if (!output_column_list_.empty()) {
    fields->emplace_back("output_column_list", output_column_list_);
  }
  if (query_ != nullptr) {
    fields->emplace_back("query", query_.get());
  }
}

absl::Status ResolvedCreateTableAsSelectStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(partition_by_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableAsSelectStmt::partition_by_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(cluster_by_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableAsSelectStmt::cluster_by_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableAsSelectStmt::output_column_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableAsSelectStmt::query not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : partition_by_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : cluster_by_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (query_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          query_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateTableAsSelectStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableAsSelectStmt::partition_by_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableAsSelectStmt::cluster_by_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableAsSelectStmt::output_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableAsSelectStmt::query is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : partition_by_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : cluster_by_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (query_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(query_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreateTableAsSelectStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : partition_by_list_) it->ClearFieldsAccessed();
  for (const auto& it : cluster_by_list_) it->ClearFieldsAccessed();
  for (const auto& it : output_column_list_) it->ClearFieldsAccessed();
  if (query_ != nullptr) query_->ClearFieldsAccessed();
}

void ResolvedCreateTableAsSelectStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : partition_by_list_) it->MarkFieldsAccessed();
  for (const auto& it : cluster_by_list_) it->MarkFieldsAccessed();
  for (const auto& it : output_column_list_) it->MarkFieldsAccessed();
  if (query_ != nullptr) query_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCreateModelStmt::TYPE;

ResolvedCreateModelStmt::~ResolvedCreateModelStmt() {
}

absl::Status ResolvedCreateModelStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedCreateStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_model_stmt_node());
}

absl::Status ResolvedCreateModelStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateModelStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  for (const auto& elem : output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_output_column_list()));
  }
  if (query_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(query_->SaveTo(
        file_descriptor_set_map, proto->mutable_query()));
  }
  for (const auto& elem : transform_input_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_transform_input_column_list()));
  }
  for (const auto& elem : transform_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_transform_list()));
  }
  for (const auto& elem : transform_output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_transform_output_column_list()));
  }
  for (const auto& elem : transform_analytic_function_group_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_transform_analytic_function_group_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateModelStmt>> ResolvedCreateModelStmt::RestoreFrom(
    const ResolvedCreateModelStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOutputColumn>> output_column_list;
  for (const auto& elem : proto.output_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOutputColumn> elem_restored,
                     ResolvedOutputColumn::RestoreFrom(elem, params));
    output_column_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedScan> query;
  if (proto.
  has_query()) {
    ZETASQL_ASSIGN_OR_RETURN(query,
                     ResolvedScan::RestoreFrom(
                         proto.query(), params));
  }
  std::vector<std::unique_ptr<const ResolvedColumnDefinition>> transform_input_column_list;
  for (const auto& elem : proto.transform_input_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedColumnDefinition> elem_restored,
                     ResolvedColumnDefinition::RestoreFrom(elem, params));
    transform_input_column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedComputedColumn>> transform_list;
  for (const auto& elem : proto.transform_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedComputedColumn> elem_restored,
                     ResolvedComputedColumn::RestoreFrom(elem, params));
    transform_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOutputColumn>> transform_output_column_list;
  for (const auto& elem : proto.transform_output_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOutputColumn> elem_restored,
                     ResolvedOutputColumn::RestoreFrom(elem, params));
    transform_output_column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedAnalyticFunctionGroup>> transform_analytic_function_group_list;
  for (const auto& elem : proto.transform_analytic_function_group_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedAnalyticFunctionGroup> elem_restored,
                     ResolvedAnalyticFunctionGroup::RestoreFrom(elem, params));
    transform_analytic_function_group_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  CreateScope create_scope =
      proto.parent().create_scope();
  CreateMode create_mode =
      proto.parent().create_mode();
  auto node = MakeResolvedCreateModelStmt(
      std::move(name_path),
      std::move(create_scope),
      std::move(create_mode),
      std::move(option_list),
      std::move(output_column_list),
      std::move(query),
      std::move(transform_input_column_list),
      std::move(transform_list),
      std::move(transform_output_column_list),
      std::move(transform_analytic_function_group_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCreateModelStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : output_column_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (query_ != nullptr) {
    child_nodes->emplace_back(query_.get());
  }
  for (const auto& elem : transform_input_column_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : transform_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : transform_output_column_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : transform_analytic_function_group_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedCreateModelStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : output_column_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (query_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &query_));
    static_assert(sizeof(query_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : transform_input_column_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : transform_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : transform_output_column_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : transform_analytic_function_group_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedCreateModelStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateModelStmt(this);
}

absl::Status ResolvedCreateModelStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (query_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(query_.get()->Accept(visitor));
  }
  for (const auto& elem : transform_input_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : transform_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : transform_output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : transform_analytic_function_group_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreateModelStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
  if (!output_column_list_.empty()) {
    fields->emplace_back("output_column_list", output_column_list_);
  }
  if (query_ != nullptr) {
    fields->emplace_back("query", query_.get());
  }
  if (!transform_input_column_list_.empty()) {
    fields->emplace_back("transform_input_column_list", transform_input_column_list_);
  }
  if (!transform_list_.empty()) {
    fields->emplace_back("transform_list", transform_list_);
  }
  if (!transform_output_column_list_.empty()) {
    fields->emplace_back("transform_output_column_list", transform_output_column_list_);
  }
  if (!transform_analytic_function_group_list_.empty()) {
    fields->emplace_back("transform_analytic_function_group_list", transform_analytic_function_group_list_);
  }
}

absl::Status ResolvedCreateModelStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateModelStmt::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateModelStmt::output_column_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateModelStmt::query not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(transform_input_column_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateModelStmt::transform_input_column_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(transform_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateModelStmt::transform_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0 &&
      !IsDefaultValue(transform_output_column_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateModelStmt::transform_output_column_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<6)) == 0 &&
      !IsDefaultValue(transform_analytic_function_group_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateModelStmt::transform_analytic_function_group_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (query_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          query_.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : transform_input_column_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    for (const auto& it : transform_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : transform_output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    for (const auto& it : transform_analytic_function_group_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateModelStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateModelStmt::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateModelStmt::output_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateModelStmt::query is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateModelStmt::transform_input_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateModelStmt::transform_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateModelStmt::transform_output_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<6)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateModelStmt::transform_analytic_function_group_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (query_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(query_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : transform_input_column_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    for (const auto& it : transform_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : transform_output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    for (const auto& it : transform_analytic_function_group_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreateModelStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
  for (const auto& it : output_column_list_) it->ClearFieldsAccessed();
  if (query_ != nullptr) query_->ClearFieldsAccessed();
  for (const auto& it : transform_input_column_list_) it->ClearFieldsAccessed();
  for (const auto& it : transform_list_) it->ClearFieldsAccessed();
  for (const auto& it : transform_output_column_list_) it->ClearFieldsAccessed();
  for (const auto& it : transform_analytic_function_group_list_) it->ClearFieldsAccessed();
}

void ResolvedCreateModelStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
  for (const auto& it : output_column_list_) it->MarkFieldsAccessed();
  if (query_ != nullptr) query_->MarkFieldsAccessed();
  for (const auto& it : transform_input_column_list_) it->MarkFieldsAccessed();
  for (const auto& it : transform_list_) it->MarkFieldsAccessed();
  for (const auto& it : transform_output_column_list_) it->MarkFieldsAccessed();
  for (const auto& it : transform_analytic_function_group_list_) it->MarkFieldsAccessed();
}

ResolvedCreateViewBase::~ResolvedCreateViewBase() {
}

absl::Status ResolvedCreateViewBase::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedCreateStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_view_base_node());
}

absl::Status ResolvedCreateViewBase::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateViewBaseProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  for (const auto& elem : output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_output_column_list()));
  }
  proto->set_has_explicit_columns(has_explicit_columns_);
  if (query_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(query_->SaveTo(
        file_descriptor_set_map, proto->mutable_query()));
  }
  proto->set_sql(sql_);
  proto->set_sql_security(sql_security_);
  proto->set_is_value_table(is_value_table_);
  proto->set_recursive(recursive_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateViewBase>> ResolvedCreateViewBase::RestoreFrom(
    const AnyResolvedCreateViewBaseProto& proto,
    const ResolvedNode::RestoreParams& params) {
  switch (proto.node_case()) {
    case AnyResolvedCreateViewBaseProto::kResolvedCreateViewStmtNode:
      return ResolvedCreateViewStmt::RestoreFrom(
          proto.resolved_create_view_stmt_node(), params);
    case AnyResolvedCreateViewBaseProto::kResolvedCreateMaterializedViewStmtNode:
      return ResolvedCreateMaterializedViewStmt::RestoreFrom(
          proto.resolved_create_materialized_view_stmt_node(), params);
  case AnyResolvedCreateViewBaseProto::NODE_NOT_SET:
    return ::zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
        << "No subnode types set in ResolvedCreateViewBaseProto";
  }
}

void ResolvedCreateViewBase::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : output_column_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (query_ != nullptr) {
    child_nodes->emplace_back(query_.get());
  }
}

void ResolvedCreateViewBase::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : output_column_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (query_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &query_));
    static_assert(sizeof(query_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedCreateViewBase::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateViewBase(this);
}

absl::Status ResolvedCreateViewBase::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (query_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(query_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreateViewBase::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
  if (!output_column_list_.empty()) {
    fields->emplace_back("output_column_list", output_column_list_);
  }
  if (!IsDefaultValue(has_explicit_columns_)) {
    fields->emplace_back("has_explicit_columns", ToStringImpl(has_explicit_columns_));
  }
  if (query_ != nullptr) {
    fields->emplace_back("query", query_.get());
  }
  if (!IsDefaultValue(sql_)) {
    fields->emplace_back("sql", ToStringImpl(sql_));
  }
  if (!IsDefaultValue(sql_security_)) {
    fields->emplace_back("sql_security", ToStringImpl(sql_security_));
  }
  if (!IsDefaultValue(is_value_table_)) {
    fields->emplace_back("is_value_table", ToStringImpl(is_value_table_));
  }
  if (!IsDefaultValue(recursive_)) {
    fields->emplace_back("recursive", ToStringImpl(recursive_));
  }
}

absl::Status ResolvedCreateViewBase::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateViewBase::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateViewBase::output_column_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(has_explicit_columns_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateViewBase::has_explicit_columns not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0 &&
      !IsDefaultValue(sql_security_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateViewBase::sql_security not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<6)) == 0 &&
      !IsDefaultValue(is_value_table_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateViewBase::is_value_table not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (query_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          query_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateViewBase::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateViewBase::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateViewBase::output_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateViewBase::has_explicit_columns is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateViewBase::sql_security is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<6)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateViewBase::is_value_table is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (query_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(query_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreateViewBase::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
  for (const auto& it : output_column_list_) it->ClearFieldsAccessed();
  if (query_ != nullptr) query_->ClearFieldsAccessed();
}

void ResolvedCreateViewBase::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
  for (const auto& it : output_column_list_) it->MarkFieldsAccessed();
  if (query_ != nullptr) query_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCreateViewStmt::TYPE;

ResolvedCreateViewStmt::~ResolvedCreateViewStmt() {
}

absl::Status ResolvedCreateViewStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedCreateViewBaseProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_view_stmt_node());
}

absl::Status ResolvedCreateViewStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateViewStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateViewStmt>> ResolvedCreateViewStmt::RestoreFrom(
    const ResolvedCreateViewStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().parent().name_path()) {
    name_path.push_back(elem);
  }
  CreateScope create_scope =
      proto.parent().parent().create_scope();
  CreateMode create_mode =
      proto.parent().parent().create_mode();
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.parent().option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOutputColumn>> output_column_list;
  for (const auto& elem : proto.parent().output_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOutputColumn> elem_restored,
                     ResolvedOutputColumn::RestoreFrom(elem, params));
    output_column_list.push_back(std::move(elem_restored));
  }
  bool has_explicit_columns =
      proto.parent().has_explicit_columns();
  std::unique_ptr<const ResolvedScan> query;
  if (proto.parent().
  has_query()) {
    ZETASQL_ASSIGN_OR_RETURN(query,
                     ResolvedScan::RestoreFrom(
                         proto.parent().query(), params));
  }
  std::string sql =
      proto.parent().sql();
  SqlSecurity sql_security =
      proto.parent().sql_security();
  bool is_value_table =
      proto.parent().is_value_table();
  bool recursive =
      proto.parent().recursive();
  auto node = MakeResolvedCreateViewStmt(
      std::move(name_path),
      std::move(create_scope),
      std::move(create_mode),
      std::move(option_list),
      std::move(output_column_list),
      std::move(has_explicit_columns),
      std::move(query),
      std::move(sql),
      std::move(sql_security),
      std::move(is_value_table),
      std::move(recursive));

  node->set_hint_list(std::move(hint_list));
  return node;
}

absl::Status ResolvedCreateViewStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateViewStmt(this);
}

absl::Status ResolvedCreateViewStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

const ResolvedNodeKind ResolvedWithPartitionColumns::TYPE;

ResolvedWithPartitionColumns::~ResolvedWithPartitionColumns() {
}

absl::Status ResolvedWithPartitionColumns::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_with_partition_columns_node());
}

absl::Status ResolvedWithPartitionColumns::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedWithPartitionColumnsProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : column_definition_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_column_definition_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedWithPartitionColumns>> ResolvedWithPartitionColumns::RestoreFrom(
    const ResolvedWithPartitionColumnsProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedColumnDefinition>> column_definition_list;
  for (const auto& elem : proto.column_definition_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedColumnDefinition> elem_restored,
                     ResolvedColumnDefinition::RestoreFrom(elem, params));
    column_definition_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedWithPartitionColumns(
      std::move(column_definition_list));

  return node;
}

void ResolvedWithPartitionColumns::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : column_definition_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedWithPartitionColumns::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : column_definition_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedWithPartitionColumns::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedWithPartitionColumns(this);
}

absl::Status ResolvedWithPartitionColumns::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : column_definition_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedWithPartitionColumns::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!column_definition_list_.empty()) {
    fields->emplace_back("column_definition_list", column_definition_list_);
  }
}

absl::Status ResolvedWithPartitionColumns::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(column_definition_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedWithPartitionColumns::column_definition_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : column_definition_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedWithPartitionColumns::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedWithPartitionColumns::column_definition_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : column_definition_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedWithPartitionColumns::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : column_definition_list_) it->ClearFieldsAccessed();
}

void ResolvedWithPartitionColumns::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : column_definition_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCreateSnapshotTableStmt::TYPE;

ResolvedCreateSnapshotTableStmt::~ResolvedCreateSnapshotTableStmt() {
}

absl::Status ResolvedCreateSnapshotTableStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedCreateStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_snapshot_table_stmt_node());
}

absl::Status ResolvedCreateSnapshotTableStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateSnapshotTableStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (clone_from_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(clone_from_->SaveTo(
        file_descriptor_set_map, proto->mutable_clone_from()));
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateSnapshotTableStmt>> ResolvedCreateSnapshotTableStmt::RestoreFrom(
    const ResolvedCreateSnapshotTableStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedScan> clone_from;
  if (proto.
  has_clone_from()) {
    ZETASQL_ASSIGN_OR_RETURN(clone_from,
                     ResolvedScan::RestoreFrom(
                         proto.clone_from(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  CreateScope create_scope =
      proto.parent().create_scope();
  CreateMode create_mode =
      proto.parent().create_mode();
  auto node = MakeResolvedCreateSnapshotTableStmt(
      std::move(name_path),
      std::move(create_scope),
      std::move(create_mode),
      std::move(clone_from),
      std::move(option_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCreateSnapshotTableStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (clone_from_ != nullptr) {
    child_nodes->emplace_back(clone_from_.get());
  }
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedCreateSnapshotTableStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (clone_from_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &clone_from_));
    static_assert(sizeof(clone_from_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedCreateSnapshotTableStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateSnapshotTableStmt(this);
}

absl::Status ResolvedCreateSnapshotTableStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (clone_from_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(clone_from_.get()->Accept(visitor));
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreateSnapshotTableStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (clone_from_ != nullptr) {
    fields->emplace_back("clone_from", clone_from_.get());
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
}

absl::Status ResolvedCreateSnapshotTableStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateSnapshotTableStmt::clone_from not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateSnapshotTableStmt::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (clone_from_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          clone_from_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateSnapshotTableStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateSnapshotTableStmt::clone_from is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateSnapshotTableStmt::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (clone_from_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(clone_from_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreateSnapshotTableStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (clone_from_ != nullptr) clone_from_->ClearFieldsAccessed();
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
}

void ResolvedCreateSnapshotTableStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (clone_from_ != nullptr) clone_from_->MarkFieldsAccessed();
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCreateExternalTableStmt::TYPE;

ResolvedCreateExternalTableStmt::~ResolvedCreateExternalTableStmt() {
}

absl::Status ResolvedCreateExternalTableStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedCreateTableStmtBaseProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_external_table_stmt_node());
}

absl::Status ResolvedCreateExternalTableStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateExternalTableStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (with_partition_columns_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(with_partition_columns_->SaveTo(
        file_descriptor_set_map, proto->mutable_with_partition_columns()));
  }
  if (connection_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(connection_->SaveTo(
        file_descriptor_set_map, proto->mutable_connection()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateExternalTableStmt>> ResolvedCreateExternalTableStmt::RestoreFrom(
    const ResolvedCreateExternalTableStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedWithPartitionColumns> with_partition_columns;
  if (proto.
  has_with_partition_columns()) {
    ZETASQL_ASSIGN_OR_RETURN(with_partition_columns,
                     ResolvedWithPartitionColumns::RestoreFrom(
                         proto.with_partition_columns(), params));
  }
  std::unique_ptr<const ResolvedConnection> connection;
  if (proto.
  has_connection()) {
    ZETASQL_ASSIGN_OR_RETURN(connection,
                     ResolvedConnection::RestoreFrom(
                         proto.connection(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().parent().name_path()) {
    name_path.push_back(elem);
  }
  CreateScope create_scope =
      proto.parent().parent().create_scope();
  CreateMode create_mode =
      proto.parent().parent().create_mode();
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.parent().option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedColumnDefinition>> column_definition_list;
  for (const auto& elem : proto.parent().column_definition_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedColumnDefinition> elem_restored,
                     ResolvedColumnDefinition::RestoreFrom(elem, params));
    column_definition_list.push_back(std::move(elem_restored));
  }
  std::vector<ResolvedColumn> pseudo_column_list;
  for (const auto& elem : proto.parent().pseudo_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    pseudo_column_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedPrimaryKey> primary_key;
  if (proto.parent().
  has_primary_key()) {
    ZETASQL_ASSIGN_OR_RETURN(primary_key,
                     ResolvedPrimaryKey::RestoreFrom(
                         proto.parent().primary_key(), params));
  }
  std::vector<std::unique_ptr<const ResolvedForeignKey>> foreign_key_list;
  for (const auto& elem : proto.parent().foreign_key_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedForeignKey> elem_restored,
                     ResolvedForeignKey::RestoreFrom(elem, params));
    foreign_key_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedCheckConstraint>> check_constraint_list;
  for (const auto& elem : proto.parent().check_constraint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedCheckConstraint> elem_restored,
                     ResolvedCheckConstraint::RestoreFrom(elem, params));
    check_constraint_list.push_back(std::move(elem_restored));
  }
  bool is_value_table =
      proto.parent().is_value_table();
  ZETASQL_ASSIGN_OR_RETURN(auto like_table,
                   RestoreFromImpl<const Table*>(
                       proto.parent().like_table(),
                       params));
  std::unique_ptr<const ResolvedExpr> collation_name;
  if (proto.parent().
  has_collation_name()) {
    ZETASQL_ASSIGN_OR_RETURN(collation_name,
                     ResolvedExpr::RestoreFrom(
                         proto.parent().collation_name(), params));
  }
  auto node = MakeResolvedCreateExternalTableStmt(
      std::move(name_path),
      std::move(create_scope),
      std::move(create_mode),
      std::move(option_list),
      std::move(column_definition_list),
      std::move(pseudo_column_list),
      std::move(primary_key),
      std::move(foreign_key_list),
      std::move(check_constraint_list),
      std::move(is_value_table),
      std::move(like_table),
      std::move(collation_name),
      std::move(with_partition_columns),
      std::move(connection));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCreateExternalTableStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (with_partition_columns_ != nullptr) {
    child_nodes->emplace_back(with_partition_columns_.get());
  }
  if (connection_ != nullptr) {
    child_nodes->emplace_back(connection_.get());
  }
}

void ResolvedCreateExternalTableStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (with_partition_columns_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &with_partition_columns_));
    static_assert(sizeof(with_partition_columns_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (connection_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &connection_));
    static_assert(sizeof(connection_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedCreateExternalTableStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateExternalTableStmt(this);
}

absl::Status ResolvedCreateExternalTableStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (with_partition_columns_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(with_partition_columns_.get()->Accept(visitor));
  }
  if (connection_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(connection_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreateExternalTableStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (with_partition_columns_ != nullptr) {
    fields->emplace_back("with_partition_columns", with_partition_columns_.get());
  }
  if (connection_ != nullptr) {
    fields->emplace_back("connection", connection_.get());
  }
}

absl::Status ResolvedCreateExternalTableStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(with_partition_columns_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateExternalTableStmt::with_partition_columns not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(connection_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateExternalTableStmt::connection not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (with_partition_columns_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          with_partition_columns_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (connection_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          connection_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateExternalTableStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateExternalTableStmt::with_partition_columns is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateExternalTableStmt::connection is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (with_partition_columns_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(with_partition_columns_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (connection_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(connection_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreateExternalTableStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (with_partition_columns_ != nullptr) with_partition_columns_->ClearFieldsAccessed();
  if (connection_ != nullptr) connection_->ClearFieldsAccessed();
}

void ResolvedCreateExternalTableStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (with_partition_columns_ != nullptr) with_partition_columns_->MarkFieldsAccessed();
  if (connection_ != nullptr) connection_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedExportModelStmt::TYPE;

ResolvedExportModelStmt::~ResolvedExportModelStmt() {
}

absl::Status ResolvedExportModelStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_export_model_stmt_node());
}

absl::Status ResolvedExportModelStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedExportModelStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : model_name_path_) {
    proto->add_model_name_path(elem);
  }
  if (connection_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(connection_->SaveTo(
        file_descriptor_set_map, proto->mutable_connection()));
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedExportModelStmt>> ResolvedExportModelStmt::RestoreFrom(
    const ResolvedExportModelStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::string> model_name_path;
  for (const auto& elem : proto.model_name_path()) {
    model_name_path.push_back(elem);
  }
  std::unique_ptr<const ResolvedConnection> connection;
  if (proto.
  has_connection()) {
    ZETASQL_ASSIGN_OR_RETURN(connection,
                     ResolvedConnection::RestoreFrom(
                         proto.connection(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedExportModelStmt(
      std::move(model_name_path),
      std::move(connection),
      std::move(option_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedExportModelStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (connection_ != nullptr) {
    child_nodes->emplace_back(connection_.get());
  }
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedExportModelStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (connection_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &connection_));
    static_assert(sizeof(connection_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedExportModelStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedExportModelStmt(this);
}

absl::Status ResolvedExportModelStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (connection_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(connection_.get()->Accept(visitor));
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedExportModelStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("model_name_path", ToStringImpl(model_name_path_));
  }
  if (connection_ != nullptr) {
    fields->emplace_back("connection", connection_.get());
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
}

absl::Status ResolvedExportModelStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedExportModelStmt::model_name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(connection_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedExportModelStmt::connection not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedExportModelStmt::option_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (connection_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          connection_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedExportModelStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedExportModelStmt::model_name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedExportModelStmt::connection is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedExportModelStmt::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (connection_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(connection_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedExportModelStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (connection_ != nullptr) connection_->ClearFieldsAccessed();
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
}

void ResolvedExportModelStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (connection_ != nullptr) connection_->MarkFieldsAccessed();
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedExportDataStmt::TYPE;

ResolvedExportDataStmt::~ResolvedExportDataStmt() {
}

absl::Status ResolvedExportDataStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_export_data_stmt_node());
}

absl::Status ResolvedExportDataStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedExportDataStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (connection_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(connection_->SaveTo(
        file_descriptor_set_map, proto->mutable_connection()));
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  for (const auto& elem : output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_output_column_list()));
  }
  proto->set_is_value_table(is_value_table_);
  if (query_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(query_->SaveTo(
        file_descriptor_set_map, proto->mutable_query()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedExportDataStmt>> ResolvedExportDataStmt::RestoreFrom(
    const ResolvedExportDataStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedConnection> connection;
  if (proto.
  has_connection()) {
    ZETASQL_ASSIGN_OR_RETURN(connection,
                     ResolvedConnection::RestoreFrom(
                         proto.connection(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOutputColumn>> output_column_list;
  for (const auto& elem : proto.output_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOutputColumn> elem_restored,
                     ResolvedOutputColumn::RestoreFrom(elem, params));
    output_column_list.push_back(std::move(elem_restored));
  }
  bool is_value_table =
      proto.is_value_table();
  std::unique_ptr<const ResolvedScan> query;
  if (proto.
  has_query()) {
    ZETASQL_ASSIGN_OR_RETURN(query,
                     ResolvedScan::RestoreFrom(
                         proto.query(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedExportDataStmt(
      std::move(connection),
      std::move(option_list),
      std::move(output_column_list),
      std::move(is_value_table),
      std::move(query));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedExportDataStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (connection_ != nullptr) {
    child_nodes->emplace_back(connection_.get());
  }
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : output_column_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (query_ != nullptr) {
    child_nodes->emplace_back(query_.get());
  }
}

void ResolvedExportDataStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (connection_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &connection_));
    static_assert(sizeof(connection_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : output_column_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (query_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &query_));
    static_assert(sizeof(query_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedExportDataStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedExportDataStmt(this);
}

absl::Status ResolvedExportDataStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (connection_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(connection_.get()->Accept(visitor));
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (query_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(query_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedExportDataStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (connection_ != nullptr) {
    fields->emplace_back("connection", connection_.get());
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
  if (!output_column_list_.empty()) {
    fields->emplace_back("output_column_list", output_column_list_);
  }
  if (!IsDefaultValue(is_value_table_)) {
    fields->emplace_back("is_value_table", ToStringImpl(is_value_table_));
  }
  if (query_ != nullptr) {
    fields->emplace_back("query", query_.get());
  }
}

absl::Status ResolvedExportDataStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(connection_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedExportDataStmt::connection not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedExportDataStmt::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedExportDataStmt::output_column_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(is_value_table_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedExportDataStmt::is_value_table not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedExportDataStmt::query not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (connection_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          connection_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (query_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          query_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedExportDataStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedExportDataStmt::connection is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedExportDataStmt::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedExportDataStmt::output_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedExportDataStmt::is_value_table is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedExportDataStmt::query is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (connection_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(connection_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (query_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(query_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedExportDataStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (connection_ != nullptr) connection_->ClearFieldsAccessed();
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
  for (const auto& it : output_column_list_) it->ClearFieldsAccessed();
  if (query_ != nullptr) query_->ClearFieldsAccessed();
}

void ResolvedExportDataStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (connection_ != nullptr) connection_->MarkFieldsAccessed();
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
  for (const auto& it : output_column_list_) it->MarkFieldsAccessed();
  if (query_ != nullptr) query_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedDefineTableStmt::TYPE;

ResolvedDefineTableStmt::~ResolvedDefineTableStmt() {
}

absl::Status ResolvedDefineTableStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_define_table_stmt_node());
}

absl::Status ResolvedDefineTableStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedDefineTableStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedDefineTableStmt>> ResolvedDefineTableStmt::RestoreFrom(
    const ResolvedDefineTableStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::string> name_path;
  for (const auto& elem : proto.name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedDefineTableStmt(
      std::move(name_path),
      std::move(option_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedDefineTableStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedDefineTableStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedDefineTableStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedDefineTableStmt(this);
}

absl::Status ResolvedDefineTableStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedDefineTableStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
}

absl::Status ResolvedDefineTableStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDefineTableStmt::name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDefineTableStmt::option_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedDefineTableStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDefineTableStmt::name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDefineTableStmt::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedDefineTableStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
}

void ResolvedDefineTableStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedDescribeStmt::TYPE;

ResolvedDescribeStmt::~ResolvedDescribeStmt() {
}

absl::Status ResolvedDescribeStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_describe_stmt_node());
}

absl::Status ResolvedDescribeStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedDescribeStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_object_type(object_type_);
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  for (const auto& elem : from_name_path_) {
    proto->add_from_name_path(elem);
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedDescribeStmt>> ResolvedDescribeStmt::RestoreFrom(
    const ResolvedDescribeStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string object_type =
      proto.object_type();
  std::vector<std::string> name_path;
  for (const auto& elem : proto.name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::string> from_name_path;
  for (const auto& elem : proto.from_name_path()) {
    from_name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedDescribeStmt(
      std::move(object_type),
      std::move(name_path),
      std::move(from_name_path));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedDescribeStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedDescribeStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedDescribeStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedDescribeStmt(this);
}

absl::Status ResolvedDescribeStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedDescribeStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("object_type", ToStringImpl(object_type_));
  }
  {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
  if (!IsDefaultValue(from_name_path_)) {
    fields->emplace_back("from_name_path", ToStringImpl(from_name_path_));
  }
}

absl::Status ResolvedDescribeStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDescribeStmt::object_type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDescribeStmt::name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(from_name_path_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDescribeStmt::from_name_path not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedDescribeStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDescribeStmt::object_type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDescribeStmt::name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDescribeStmt::from_name_path is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedDescribeStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedDescribeStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedShowStmt::TYPE;

ResolvedShowStmt::~ResolvedShowStmt() {
}

absl::Status ResolvedShowStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_show_stmt_node());
}

absl::Status ResolvedShowStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedShowStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_identifier(identifier_);
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  if (like_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(like_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_like_expr()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedShowStmt>> ResolvedShowStmt::RestoreFrom(
    const ResolvedShowStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string identifier =
      proto.identifier();
  std::vector<std::string> name_path;
  for (const auto& elem : proto.name_path()) {
    name_path.push_back(elem);
  }
  std::unique_ptr<const ResolvedLiteral> like_expr;
  if (proto.
  has_like_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(like_expr,
                     ResolvedLiteral::RestoreFrom(
                         proto.like_expr(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedShowStmt(
      std::move(identifier),
      std::move(name_path),
      std::move(like_expr));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedShowStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (like_expr_ != nullptr) {
    child_nodes->emplace_back(like_expr_.get());
  }
}

void ResolvedShowStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (like_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &like_expr_));
    static_assert(sizeof(like_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedShowStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedShowStmt(this);
}

absl::Status ResolvedShowStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (like_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(like_expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedShowStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("identifier", ToStringImpl(identifier_));
  }
  if (!IsDefaultValue(name_path_)) {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
  if (like_expr_ != nullptr) {
    fields->emplace_back("like_expr", like_expr_.get());
  }
}

absl::Status ResolvedShowStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedShowStmt::identifier not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(name_path_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedShowStmt::name_path not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(like_expr_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedShowStmt::like_expr not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (like_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          like_expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedShowStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedShowStmt::identifier is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedShowStmt::name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedShowStmt::like_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (like_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(like_expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedShowStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (like_expr_ != nullptr) like_expr_->ClearFieldsAccessed();
}

void ResolvedShowStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (like_expr_ != nullptr) like_expr_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedBeginStmt::TYPE;

const ResolvedBeginStmt::ReadWriteMode ResolvedBeginStmt::MODE_UNSPECIFIED;
const ResolvedBeginStmt::ReadWriteMode ResolvedBeginStmt::MODE_READ_ONLY;
const ResolvedBeginStmt::ReadWriteMode ResolvedBeginStmt::MODE_READ_WRITE;

ResolvedBeginStmt::~ResolvedBeginStmt() {
}

absl::Status ResolvedBeginStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_begin_stmt_node());
}

absl::Status ResolvedBeginStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedBeginStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_read_write_mode(read_write_mode_);
  for (const auto& elem : isolation_level_list_) {
    proto->add_isolation_level_list(elem);
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedBeginStmt>> ResolvedBeginStmt::RestoreFrom(
    const ResolvedBeginStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ReadWriteMode read_write_mode =
      proto.read_write_mode();
  std::vector<std::string> isolation_level_list;
  for (const auto& elem : proto.isolation_level_list()) {
    isolation_level_list.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedBeginStmt(
      std::move(read_write_mode),
      std::move(isolation_level_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedBeginStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedBeginStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedBeginStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedBeginStmt(this);
}

absl::Status ResolvedBeginStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedBeginStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(read_write_mode_)) {
    fields->emplace_back("read_write_mode", ToStringImpl(read_write_mode_));
  }
  if (!IsDefaultValue(isolation_level_list_)) {
    fields->emplace_back("isolation_level_list", ToStringImpl(isolation_level_list_));
  }
}

absl::Status ResolvedBeginStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(read_write_mode_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedBeginStmt::read_write_mode not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(isolation_level_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedBeginStmt::isolation_level_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedBeginStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedBeginStmt::read_write_mode is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedBeginStmt::isolation_level_list is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedBeginStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedBeginStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedSetTransactionStmt::TYPE;

ResolvedSetTransactionStmt::~ResolvedSetTransactionStmt() {
}

absl::Status ResolvedSetTransactionStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_set_transaction_stmt_node());
}

absl::Status ResolvedSetTransactionStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedSetTransactionStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_read_write_mode(read_write_mode_);
  for (const auto& elem : isolation_level_list_) {
    proto->add_isolation_level_list(elem);
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedSetTransactionStmt>> ResolvedSetTransactionStmt::RestoreFrom(
    const ResolvedSetTransactionStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ReadWriteMode read_write_mode =
      proto.read_write_mode();
  std::vector<std::string> isolation_level_list;
  for (const auto& elem : proto.isolation_level_list()) {
    isolation_level_list.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedSetTransactionStmt(
      std::move(read_write_mode),
      std::move(isolation_level_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedSetTransactionStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedSetTransactionStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedSetTransactionStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedSetTransactionStmt(this);
}

absl::Status ResolvedSetTransactionStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedSetTransactionStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(read_write_mode_)) {
    fields->emplace_back("read_write_mode", ToStringImpl(read_write_mode_));
  }
  if (!IsDefaultValue(isolation_level_list_)) {
    fields->emplace_back("isolation_level_list", ToStringImpl(isolation_level_list_));
  }
}

absl::Status ResolvedSetTransactionStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(read_write_mode_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSetTransactionStmt::read_write_mode not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(isolation_level_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSetTransactionStmt::isolation_level_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedSetTransactionStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSetTransactionStmt::read_write_mode is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSetTransactionStmt::isolation_level_list is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedSetTransactionStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedSetTransactionStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedCommitStmt::TYPE;

ResolvedCommitStmt::~ResolvedCommitStmt() {
}

absl::Status ResolvedCommitStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_commit_stmt_node());
}

absl::Status ResolvedCommitStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCommitStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCommitStmt>> ResolvedCommitStmt::RestoreFrom(
    const ResolvedCommitStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedCommitStmt(
);

  node->set_hint_list(std::move(hint_list));
  return node;
}

absl::Status ResolvedCommitStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCommitStmt(this);
}

absl::Status ResolvedCommitStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

const ResolvedNodeKind ResolvedRollbackStmt::TYPE;

ResolvedRollbackStmt::~ResolvedRollbackStmt() {
}

absl::Status ResolvedRollbackStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_rollback_stmt_node());
}

absl::Status ResolvedRollbackStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedRollbackStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedRollbackStmt>> ResolvedRollbackStmt::RestoreFrom(
    const ResolvedRollbackStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedRollbackStmt(
);

  node->set_hint_list(std::move(hint_list));
  return node;
}

absl::Status ResolvedRollbackStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedRollbackStmt(this);
}

absl::Status ResolvedRollbackStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

const ResolvedNodeKind ResolvedStartBatchStmt::TYPE;

ResolvedStartBatchStmt::~ResolvedStartBatchStmt() {
}

absl::Status ResolvedStartBatchStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_start_batch_stmt_node());
}

absl::Status ResolvedStartBatchStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedStartBatchStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_batch_type(batch_type_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedStartBatchStmt>> ResolvedStartBatchStmt::RestoreFrom(
    const ResolvedStartBatchStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string batch_type =
      proto.batch_type();
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedStartBatchStmt(
      std::move(batch_type));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedStartBatchStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedStartBatchStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedStartBatchStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedStartBatchStmt(this);
}

absl::Status ResolvedStartBatchStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedStartBatchStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(batch_type_)) {
    fields->emplace_back("batch_type", ToStringImpl(batch_type_));
  }
}

absl::Status ResolvedStartBatchStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(batch_type_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedStartBatchStmt::batch_type not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedStartBatchStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedStartBatchStmt::batch_type is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedStartBatchStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedStartBatchStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedRunBatchStmt::TYPE;

ResolvedRunBatchStmt::~ResolvedRunBatchStmt() {
}

absl::Status ResolvedRunBatchStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_run_batch_stmt_node());
}

absl::Status ResolvedRunBatchStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedRunBatchStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedRunBatchStmt>> ResolvedRunBatchStmt::RestoreFrom(
    const ResolvedRunBatchStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedRunBatchStmt(
);

  node->set_hint_list(std::move(hint_list));
  return node;
}

absl::Status ResolvedRunBatchStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedRunBatchStmt(this);
}

absl::Status ResolvedRunBatchStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

const ResolvedNodeKind ResolvedAbortBatchStmt::TYPE;

ResolvedAbortBatchStmt::~ResolvedAbortBatchStmt() {
}

absl::Status ResolvedAbortBatchStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_abort_batch_stmt_node());
}

absl::Status ResolvedAbortBatchStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAbortBatchStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAbortBatchStmt>> ResolvedAbortBatchStmt::RestoreFrom(
    const ResolvedAbortBatchStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedAbortBatchStmt(
);

  node->set_hint_list(std::move(hint_list));
  return node;
}

absl::Status ResolvedAbortBatchStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAbortBatchStmt(this);
}

absl::Status ResolvedAbortBatchStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

const ResolvedNodeKind ResolvedDropStmt::TYPE;

const ResolvedDropStmt::DropMode ResolvedDropStmt::DROP_MODE_UNSPECIFIED;
const ResolvedDropStmt::DropMode ResolvedDropStmt::RESTRICT;
const ResolvedDropStmt::DropMode ResolvedDropStmt::CASCADE;

ResolvedDropStmt::~ResolvedDropStmt() {
}

absl::Status ResolvedDropStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_drop_stmt_node());
}

absl::Status ResolvedDropStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedDropStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_object_type(object_type_);
  proto->set_is_if_exists(is_if_exists_);
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  proto->set_drop_mode(drop_mode_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedDropStmt>> ResolvedDropStmt::RestoreFrom(
    const ResolvedDropStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string object_type =
      proto.object_type();
  bool is_if_exists =
      proto.is_if_exists();
  std::vector<std::string> name_path;
  for (const auto& elem : proto.name_path()) {
    name_path.push_back(elem);
  }
  DropMode drop_mode =
      proto.drop_mode();
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedDropStmt(
      std::move(object_type),
      std::move(is_if_exists),
      std::move(name_path),
      std::move(drop_mode));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedDropStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedDropStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedDropStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedDropStmt(this);
}

absl::Status ResolvedDropStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedDropStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("object_type", ToStringImpl(object_type_));
  }
  {
    fields->emplace_back("is_if_exists", ToStringImpl(is_if_exists_));
  }
  {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
  if (!IsDefaultValue(drop_mode_)) {
    fields->emplace_back("drop_mode", ToStringImpl(drop_mode_));
  }
}

absl::Status ResolvedDropStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropStmt::object_type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropStmt::is_if_exists not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropStmt::name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(drop_mode_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropStmt::drop_mode not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedDropStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropStmt::object_type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropStmt::is_if_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropStmt::name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropStmt::drop_mode is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedDropStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedDropStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedDropMaterializedViewStmt::TYPE;

ResolvedDropMaterializedViewStmt::~ResolvedDropMaterializedViewStmt() {
}

absl::Status ResolvedDropMaterializedViewStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_drop_materialized_view_stmt_node());
}

absl::Status ResolvedDropMaterializedViewStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedDropMaterializedViewStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_is_if_exists(is_if_exists_);
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedDropMaterializedViewStmt>> ResolvedDropMaterializedViewStmt::RestoreFrom(
    const ResolvedDropMaterializedViewStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool is_if_exists =
      proto.is_if_exists();
  std::vector<std::string> name_path;
  for (const auto& elem : proto.name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedDropMaterializedViewStmt(
      std::move(is_if_exists),
      std::move(name_path));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedDropMaterializedViewStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedDropMaterializedViewStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedDropMaterializedViewStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedDropMaterializedViewStmt(this);
}

absl::Status ResolvedDropMaterializedViewStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedDropMaterializedViewStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("is_if_exists", ToStringImpl(is_if_exists_));
  }
  {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
}

absl::Status ResolvedDropMaterializedViewStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropMaterializedViewStmt::is_if_exists not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropMaterializedViewStmt::name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedDropMaterializedViewStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropMaterializedViewStmt::is_if_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropMaterializedViewStmt::name_path is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedDropMaterializedViewStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedDropMaterializedViewStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedDropSnapshotTableStmt::TYPE;

ResolvedDropSnapshotTableStmt::~ResolvedDropSnapshotTableStmt() {
}

absl::Status ResolvedDropSnapshotTableStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_drop_snapshot_table_stmt_node());
}

absl::Status ResolvedDropSnapshotTableStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedDropSnapshotTableStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_is_if_exists(is_if_exists_);
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedDropSnapshotTableStmt>> ResolvedDropSnapshotTableStmt::RestoreFrom(
    const ResolvedDropSnapshotTableStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool is_if_exists =
      proto.is_if_exists();
  std::vector<std::string> name_path;
  for (const auto& elem : proto.name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedDropSnapshotTableStmt(
      std::move(is_if_exists),
      std::move(name_path));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedDropSnapshotTableStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedDropSnapshotTableStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedDropSnapshotTableStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedDropSnapshotTableStmt(this);
}

absl::Status ResolvedDropSnapshotTableStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedDropSnapshotTableStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("is_if_exists", ToStringImpl(is_if_exists_));
  }
  {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
}

absl::Status ResolvedDropSnapshotTableStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropSnapshotTableStmt::is_if_exists not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropSnapshotTableStmt::name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedDropSnapshotTableStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropSnapshotTableStmt::is_if_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropSnapshotTableStmt::name_path is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedDropSnapshotTableStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedDropSnapshotTableStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedRecursiveRefScan::TYPE;

ResolvedRecursiveRefScan::~ResolvedRecursiveRefScan() {
}

absl::Status ResolvedRecursiveRefScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_recursive_ref_scan_node());
}

absl::Status ResolvedRecursiveRefScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedRecursiveRefScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedRecursiveRefScan>> ResolvedRecursiveRefScan::RestoreFrom(
    const ResolvedRecursiveRefScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedRecursiveRefScan(
      std::move(column_list));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

absl::Status ResolvedRecursiveRefScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedRecursiveRefScan(this);
}

absl::Status ResolvedRecursiveRefScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

const ResolvedNodeKind ResolvedRecursiveScan::TYPE;

const ResolvedRecursiveScan::RecursiveSetOperationType ResolvedRecursiveScan::UNION_ALL;
const ResolvedRecursiveScan::RecursiveSetOperationType ResolvedRecursiveScan::UNION_DISTINCT;

ResolvedRecursiveScan::~ResolvedRecursiveScan() {
}

absl::Status ResolvedRecursiveScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_recursive_scan_node());
}

absl::Status ResolvedRecursiveScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedRecursiveScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_op_type(op_type_);
  if (non_recursive_term_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(non_recursive_term_->SaveTo(
        file_descriptor_set_map, proto->mutable_non_recursive_term()));
  }
  if (recursive_term_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(recursive_term_->SaveTo(
        file_descriptor_set_map, proto->mutable_recursive_term()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedRecursiveScan>> ResolvedRecursiveScan::RestoreFrom(
    const ResolvedRecursiveScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  RecursiveSetOperationType op_type =
      proto.op_type();
  std::unique_ptr<const ResolvedSetOperationItem> non_recursive_term;
  if (proto.
  has_non_recursive_term()) {
    ZETASQL_ASSIGN_OR_RETURN(non_recursive_term,
                     ResolvedSetOperationItem::RestoreFrom(
                         proto.non_recursive_term(), params));
  }
  std::unique_ptr<const ResolvedSetOperationItem> recursive_term;
  if (proto.
  has_recursive_term()) {
    ZETASQL_ASSIGN_OR_RETURN(recursive_term,
                     ResolvedSetOperationItem::RestoreFrom(
                         proto.recursive_term(), params));
  }
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedRecursiveScan(
      std::move(column_list),
      std::move(op_type),
      std::move(non_recursive_term),
      std::move(recursive_term));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

void ResolvedRecursiveScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (non_recursive_term_ != nullptr) {
    child_nodes->emplace_back(non_recursive_term_.get());
  }
  if (recursive_term_ != nullptr) {
    child_nodes->emplace_back(recursive_term_.get());
  }
}

void ResolvedRecursiveScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (non_recursive_term_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &non_recursive_term_));
    static_assert(sizeof(non_recursive_term_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (recursive_term_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &recursive_term_));
    static_assert(sizeof(recursive_term_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedRecursiveScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedRecursiveScan(this);
}

absl::Status ResolvedRecursiveScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (non_recursive_term_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(non_recursive_term_.get()->Accept(visitor));
  }
  if (recursive_term_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(recursive_term_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedRecursiveScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("op_type", ToStringImpl(op_type_));
  }
  if (non_recursive_term_ != nullptr) {
    fields->emplace_back("non_recursive_term", non_recursive_term_.get());
  }
  if (recursive_term_ != nullptr) {
    fields->emplace_back("recursive_term", recursive_term_.get());
  }
}

absl::Status ResolvedRecursiveScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedRecursiveScan::op_type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedRecursiveScan::non_recursive_term not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedRecursiveScan::recursive_term not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (non_recursive_term_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          non_recursive_term_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (recursive_term_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          recursive_term_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedRecursiveScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedRecursiveScan::op_type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedRecursiveScan::non_recursive_term is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedRecursiveScan::recursive_term is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (non_recursive_term_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(non_recursive_term_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (recursive_term_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(recursive_term_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedRecursiveScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (non_recursive_term_ != nullptr) non_recursive_term_->ClearFieldsAccessed();
  if (recursive_term_ != nullptr) recursive_term_->ClearFieldsAccessed();
}

void ResolvedRecursiveScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (non_recursive_term_ != nullptr) non_recursive_term_->MarkFieldsAccessed();
  if (recursive_term_ != nullptr) recursive_term_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedWithScan::TYPE;

ResolvedWithScan::~ResolvedWithScan() {
}

absl::Status ResolvedWithScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_with_scan_node());
}

absl::Status ResolvedWithScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedWithScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : with_entry_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_with_entry_list()));
  }
  if (query_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(query_->SaveTo(
        file_descriptor_set_map, proto->mutable_query()));
  }
  proto->set_recursive(recursive_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedWithScan>> ResolvedWithScan::RestoreFrom(
    const ResolvedWithScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedWithEntry>> with_entry_list;
  for (const auto& elem : proto.with_entry_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedWithEntry> elem_restored,
                     ResolvedWithEntry::RestoreFrom(elem, params));
    with_entry_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedScan> query;
  if (proto.
  has_query()) {
    ZETASQL_ASSIGN_OR_RETURN(query,
                     ResolvedScan::RestoreFrom(
                         proto.query(), params));
  }
  bool recursive =
      proto.recursive();
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedWithScan(
      std::move(column_list),
      std::move(with_entry_list),
      std::move(query),
      std::move(recursive));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

void ResolvedWithScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : with_entry_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (query_ != nullptr) {
    child_nodes->emplace_back(query_.get());
  }
}

void ResolvedWithScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : with_entry_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (query_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &query_));
    static_assert(sizeof(query_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedWithScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedWithScan(this);
}

absl::Status ResolvedWithScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : with_entry_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (query_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(query_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedWithScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!with_entry_list_.empty()) {
    fields->emplace_back("with_entry_list", with_entry_list_);
  }
  if (query_ != nullptr) {
    fields->emplace_back("query", query_.get());
  }
  if (!IsDefaultValue(recursive_)) {
    fields->emplace_back("recursive", ToStringImpl(recursive_));
  }
}

absl::Status ResolvedWithScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedWithScan::with_entry_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedWithScan::query not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : with_entry_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (query_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          query_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedWithScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedWithScan::with_entry_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedWithScan::query is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : with_entry_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (query_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(query_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedWithScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : with_entry_list_) it->ClearFieldsAccessed();
  if (query_ != nullptr) query_->ClearFieldsAccessed();
}

void ResolvedWithScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : with_entry_list_) it->MarkFieldsAccessed();
  if (query_ != nullptr) query_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedWithEntry::TYPE;

ResolvedWithEntry::~ResolvedWithEntry() {
}

absl::Status ResolvedWithEntry::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_with_entry_node());
}

absl::Status ResolvedWithEntry::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedWithEntryProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_with_query_name(with_query_name_);
  if (with_subquery_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(with_subquery_->SaveTo(
        file_descriptor_set_map, proto->mutable_with_subquery()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedWithEntry>> ResolvedWithEntry::RestoreFrom(
    const ResolvedWithEntryProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string with_query_name =
      proto.with_query_name();
  std::unique_ptr<const ResolvedScan> with_subquery;
  if (proto.
  has_with_subquery()) {
    ZETASQL_ASSIGN_OR_RETURN(with_subquery,
                     ResolvedScan::RestoreFrom(
                         proto.with_subquery(), params));
  }
  auto node = MakeResolvedWithEntry(
      std::move(with_query_name),
      std::move(with_subquery));

  return node;
}

void ResolvedWithEntry::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (with_subquery_ != nullptr) {
    child_nodes->emplace_back(with_subquery_.get());
  }
}

void ResolvedWithEntry::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (with_subquery_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &with_subquery_));
    static_assert(sizeof(with_subquery_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedWithEntry::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedWithEntry(this);
}

absl::Status ResolvedWithEntry::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (with_subquery_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(with_subquery_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedWithEntry::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("with_query_name", ToStringImpl(with_query_name_));
  }
  if (with_subquery_ != nullptr) {
    fields->emplace_back("with_subquery", with_subquery_.get());
  }
}

absl::Status ResolvedWithEntry::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedWithEntry::with_query_name not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedWithEntry::with_subquery not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (with_subquery_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          with_subquery_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedWithEntry::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedWithEntry::with_query_name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedWithEntry::with_subquery is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (with_subquery_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(with_subquery_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedWithEntry::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (with_subquery_ != nullptr) with_subquery_->ClearFieldsAccessed();
}

void ResolvedWithEntry::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (with_subquery_ != nullptr) with_subquery_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedOption::TYPE;

ResolvedOption::~ResolvedOption() {
}

absl::Status ResolvedOption::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_option_node());
}

absl::Status ResolvedOption::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedOptionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_qualifier(qualifier_);
  proto->set_name(name_);
  if (value_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(value_->SaveTo(
        file_descriptor_set_map, proto->mutable_value()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedOption>> ResolvedOption::RestoreFrom(
    const ResolvedOptionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string qualifier =
      proto.qualifier();
  std::string name =
      proto.name();
  std::unique_ptr<const ResolvedExpr> value;
  if (proto.
  has_value()) {
    ZETASQL_ASSIGN_OR_RETURN(value,
                     ResolvedExpr::RestoreFrom(
                         proto.value(), params));
  }
  auto node = MakeResolvedOption(
      std::move(qualifier),
      std::move(name),
      std::move(value));

  return node;
}

void ResolvedOption::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (value_ != nullptr) {
    child_nodes->emplace_back(value_.get());
  }
}

void ResolvedOption::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (value_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &value_));
    static_assert(sizeof(value_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedOption::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedOption(this);
}

absl::Status ResolvedOption::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (value_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(value_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

absl::Status ResolvedOption::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedOption::qualifier not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (value_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          value_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedOption::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedOption::qualifier is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (value_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(value_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedOption::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (value_ != nullptr) value_->ClearFieldsAccessed();
}

void ResolvedOption::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (value_ != nullptr) value_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedWindowPartitioning::TYPE;

ResolvedWindowPartitioning::~ResolvedWindowPartitioning() {
}

absl::Status ResolvedWindowPartitioning::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_window_partitioning_node());
}

absl::Status ResolvedWindowPartitioning::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedWindowPartitioningProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : partition_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_partition_by_list()));
  }
  for (const auto& elem : hint_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_hint_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedWindowPartitioning>> ResolvedWindowPartitioning::RestoreFrom(
    const ResolvedWindowPartitioningProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedColumnRef>> partition_by_list;
  for (const auto& elem : proto.partition_by_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedColumnRef> elem_restored,
                     ResolvedColumnRef::RestoreFrom(elem, params));
    partition_by_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedWindowPartitioning(
      std::move(partition_by_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedWindowPartitioning::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : partition_by_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : hint_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedWindowPartitioning::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : partition_by_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : hint_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedWindowPartitioning::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedWindowPartitioning(this);
}

absl::Status ResolvedWindowPartitioning::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : partition_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : hint_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedWindowPartitioning::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!partition_by_list_.empty()) {
    fields->emplace_back("partition_by_list", partition_by_list_);
  }
  if (!hint_list_.empty()) {
    fields->emplace_back("hint_list", hint_list_);
  }
}

absl::Status ResolvedWindowPartitioning::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedWindowPartitioning::partition_by_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : partition_by_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : hint_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedWindowPartitioning::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedWindowPartitioning::partition_by_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : partition_by_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : hint_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedWindowPartitioning::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : partition_by_list_) it->ClearFieldsAccessed();
  for (const auto& it : hint_list_) it->ClearFieldsAccessed();
}

void ResolvedWindowPartitioning::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : partition_by_list_) it->MarkFieldsAccessed();
  for (const auto& it : hint_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedWindowOrdering::TYPE;

ResolvedWindowOrdering::~ResolvedWindowOrdering() {
}

absl::Status ResolvedWindowOrdering::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_window_ordering_node());
}

absl::Status ResolvedWindowOrdering::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedWindowOrderingProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : order_by_item_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_order_by_item_list()));
  }
  for (const auto& elem : hint_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_hint_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedWindowOrdering>> ResolvedWindowOrdering::RestoreFrom(
    const ResolvedWindowOrderingProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOrderByItem>> order_by_item_list;
  for (const auto& elem : proto.order_by_item_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOrderByItem> elem_restored,
                     ResolvedOrderByItem::RestoreFrom(elem, params));
    order_by_item_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedWindowOrdering(
      std::move(order_by_item_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedWindowOrdering::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : order_by_item_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : hint_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedWindowOrdering::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : order_by_item_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : hint_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedWindowOrdering::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedWindowOrdering(this);
}

absl::Status ResolvedWindowOrdering::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : order_by_item_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : hint_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedWindowOrdering::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!order_by_item_list_.empty()) {
    fields->emplace_back("order_by_item_list", order_by_item_list_);
  }
  if (!hint_list_.empty()) {
    fields->emplace_back("hint_list", hint_list_);
  }
}

absl::Status ResolvedWindowOrdering::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedWindowOrdering::order_by_item_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : order_by_item_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : hint_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedWindowOrdering::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedWindowOrdering::order_by_item_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : order_by_item_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : hint_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedWindowOrdering::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : order_by_item_list_) it->ClearFieldsAccessed();
  for (const auto& it : hint_list_) it->ClearFieldsAccessed();
}

void ResolvedWindowOrdering::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : order_by_item_list_) it->MarkFieldsAccessed();
  for (const auto& it : hint_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedWindowFrame::TYPE;

const ResolvedWindowFrame::FrameUnit ResolvedWindowFrame::ROWS;
const ResolvedWindowFrame::FrameUnit ResolvedWindowFrame::RANGE;

ResolvedWindowFrame::~ResolvedWindowFrame() {
}

absl::Status ResolvedWindowFrame::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_window_frame_node());
}

absl::Status ResolvedWindowFrame::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedWindowFrameProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_frame_unit(frame_unit_);
  if (start_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(start_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_start_expr()));
  }
  if (end_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(end_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_end_expr()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedWindowFrame>> ResolvedWindowFrame::RestoreFrom(
    const ResolvedWindowFrameProto& proto,
    const ResolvedNode::RestoreParams& params) {
  FrameUnit frame_unit =
      proto.frame_unit();
  std::unique_ptr<const ResolvedWindowFrameExpr> start_expr;
  if (proto.
  has_start_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(start_expr,
                     ResolvedWindowFrameExpr::RestoreFrom(
                         proto.start_expr(), params));
  }
  std::unique_ptr<const ResolvedWindowFrameExpr> end_expr;
  if (proto.
  has_end_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(end_expr,
                     ResolvedWindowFrameExpr::RestoreFrom(
                         proto.end_expr(), params));
  }
  auto node = MakeResolvedWindowFrame(
      std::move(frame_unit),
      std::move(start_expr),
      std::move(end_expr));

  return node;
}

void ResolvedWindowFrame::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (start_expr_ != nullptr) {
    child_nodes->emplace_back(start_expr_.get());
  }
  if (end_expr_ != nullptr) {
    child_nodes->emplace_back(end_expr_.get());
  }
}

void ResolvedWindowFrame::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (start_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &start_expr_));
    static_assert(sizeof(start_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (end_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &end_expr_));
    static_assert(sizeof(end_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedWindowFrame::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedWindowFrame(this);
}

absl::Status ResolvedWindowFrame::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (start_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(start_expr_.get()->Accept(visitor));
  }
  if (end_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(end_expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

absl::Status ResolvedWindowFrame::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedWindowFrame::frame_unit not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedWindowFrame::start_expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedWindowFrame::end_expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (start_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          start_expr_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (end_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          end_expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedWindowFrame::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedWindowFrame::frame_unit is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedWindowFrame::start_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedWindowFrame::end_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (start_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(start_expr_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (end_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(end_expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedWindowFrame::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (start_expr_ != nullptr) start_expr_->ClearFieldsAccessed();
  if (end_expr_ != nullptr) end_expr_->ClearFieldsAccessed();
}

void ResolvedWindowFrame::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (start_expr_ != nullptr) start_expr_->MarkFieldsAccessed();
  if (end_expr_ != nullptr) end_expr_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAnalyticFunctionGroup::TYPE;

ResolvedAnalyticFunctionGroup::~ResolvedAnalyticFunctionGroup() {
}

absl::Status ResolvedAnalyticFunctionGroup::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_analytic_function_group_node());
}

absl::Status ResolvedAnalyticFunctionGroup::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAnalyticFunctionGroupProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (partition_by_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(partition_by_->SaveTo(
        file_descriptor_set_map, proto->mutable_partition_by()));
  }
  if (order_by_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(order_by_->SaveTo(
        file_descriptor_set_map, proto->mutable_order_by()));
  }
  for (const auto& elem : analytic_function_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_analytic_function_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAnalyticFunctionGroup>> ResolvedAnalyticFunctionGroup::RestoreFrom(
    const ResolvedAnalyticFunctionGroupProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedWindowPartitioning> partition_by;
  if (proto.
  has_partition_by()) {
    ZETASQL_ASSIGN_OR_RETURN(partition_by,
                     ResolvedWindowPartitioning::RestoreFrom(
                         proto.partition_by(), params));
  }
  std::unique_ptr<const ResolvedWindowOrdering> order_by;
  if (proto.
  has_order_by()) {
    ZETASQL_ASSIGN_OR_RETURN(order_by,
                     ResolvedWindowOrdering::RestoreFrom(
                         proto.order_by(), params));
  }
  std::vector<std::unique_ptr<const ResolvedComputedColumn>> analytic_function_list;
  for (const auto& elem : proto.analytic_function_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedComputedColumn> elem_restored,
                     ResolvedComputedColumn::RestoreFrom(elem, params));
    analytic_function_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedAnalyticFunctionGroup(
      std::move(partition_by),
      std::move(order_by),
      std::move(analytic_function_list));

  return node;
}

void ResolvedAnalyticFunctionGroup::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (partition_by_ != nullptr) {
    child_nodes->emplace_back(partition_by_.get());
  }
  if (order_by_ != nullptr) {
    child_nodes->emplace_back(order_by_.get());
  }
  for (const auto& elem : analytic_function_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedAnalyticFunctionGroup::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (partition_by_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &partition_by_));
    static_assert(sizeof(partition_by_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (order_by_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &order_by_));
    static_assert(sizeof(order_by_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : analytic_function_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedAnalyticFunctionGroup::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAnalyticFunctionGroup(this);
}

absl::Status ResolvedAnalyticFunctionGroup::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (partition_by_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(partition_by_.get()->Accept(visitor));
  }
  if (order_by_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(order_by_.get()->Accept(visitor));
  }
  for (const auto& elem : analytic_function_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAnalyticFunctionGroup::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (partition_by_ != nullptr) {
    fields->emplace_back("partition_by", partition_by_.get());
  }
  if (order_by_ != nullptr) {
    fields->emplace_back("order_by", order_by_.get());
  }
  if (!analytic_function_list_.empty()) {
    fields->emplace_back("analytic_function_list", analytic_function_list_);
  }
}

absl::Status ResolvedAnalyticFunctionGroup::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAnalyticFunctionGroup::partition_by not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAnalyticFunctionGroup::order_by not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAnalyticFunctionGroup::analytic_function_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (partition_by_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          partition_by_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (order_by_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          order_by_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : analytic_function_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAnalyticFunctionGroup::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAnalyticFunctionGroup::partition_by is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAnalyticFunctionGroup::order_by is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAnalyticFunctionGroup::analytic_function_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (partition_by_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(partition_by_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (order_by_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(order_by_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : analytic_function_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAnalyticFunctionGroup::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (partition_by_ != nullptr) partition_by_->ClearFieldsAccessed();
  if (order_by_ != nullptr) order_by_->ClearFieldsAccessed();
  for (const auto& it : analytic_function_list_) it->ClearFieldsAccessed();
}

void ResolvedAnalyticFunctionGroup::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (partition_by_ != nullptr) partition_by_->MarkFieldsAccessed();
  if (order_by_ != nullptr) order_by_->MarkFieldsAccessed();
  for (const auto& it : analytic_function_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedWindowFrameExpr::TYPE;

const ResolvedWindowFrameExpr::BoundaryType ResolvedWindowFrameExpr::UNBOUNDED_PRECEDING;
const ResolvedWindowFrameExpr::BoundaryType ResolvedWindowFrameExpr::OFFSET_PRECEDING;
const ResolvedWindowFrameExpr::BoundaryType ResolvedWindowFrameExpr::CURRENT_ROW;
const ResolvedWindowFrameExpr::BoundaryType ResolvedWindowFrameExpr::OFFSET_FOLLOWING;
const ResolvedWindowFrameExpr::BoundaryType ResolvedWindowFrameExpr::UNBOUNDED_FOLLOWING;

ResolvedWindowFrameExpr::~ResolvedWindowFrameExpr() {
}

absl::Status ResolvedWindowFrameExpr::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_window_frame_expr_node());
}

absl::Status ResolvedWindowFrameExpr::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedWindowFrameExprProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_boundary_type(boundary_type_);
  if (expression_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expression_->SaveTo(
        file_descriptor_set_map, proto->mutable_expression()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedWindowFrameExpr>> ResolvedWindowFrameExpr::RestoreFrom(
    const ResolvedWindowFrameExprProto& proto,
    const ResolvedNode::RestoreParams& params) {
  BoundaryType boundary_type =
      proto.boundary_type();
  std::unique_ptr<const ResolvedExpr> expression;
  if (proto.
  has_expression()) {
    ZETASQL_ASSIGN_OR_RETURN(expression,
                     ResolvedExpr::RestoreFrom(
                         proto.expression(), params));
  }
  auto node = MakeResolvedWindowFrameExpr(
      std::move(boundary_type),
      std::move(expression));

  return node;
}

void ResolvedWindowFrameExpr::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expression_ != nullptr) {
    child_nodes->emplace_back(expression_.get());
  }
}

void ResolvedWindowFrameExpr::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expression_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expression_));
    static_assert(sizeof(expression_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedWindowFrameExpr::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedWindowFrameExpr(this);
}

absl::Status ResolvedWindowFrameExpr::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expression_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expression_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

absl::Status ResolvedWindowFrameExpr::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedWindowFrameExpr::boundary_type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedWindowFrameExpr::expression not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (expression_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expression_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedWindowFrameExpr::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedWindowFrameExpr::boundary_type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedWindowFrameExpr::expression is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (expression_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expression_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedWindowFrameExpr::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expression_ != nullptr) expression_->ClearFieldsAccessed();
}

void ResolvedWindowFrameExpr::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expression_ != nullptr) expression_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedDMLValue::TYPE;

ResolvedDMLValue::~ResolvedDMLValue() {
}

absl::Status ResolvedDMLValue::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_dmlvalue_node());
}

absl::Status ResolvedDMLValue::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedDMLValueProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (value_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(value_->SaveTo(
        file_descriptor_set_map, proto->mutable_value()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedDMLValue>> ResolvedDMLValue::RestoreFrom(
    const ResolvedDMLValueProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> value;
  if (proto.
  has_value()) {
    ZETASQL_ASSIGN_OR_RETURN(value,
                     ResolvedExpr::RestoreFrom(
                         proto.value(), params));
  }
  auto node = MakeResolvedDMLValue(
      std::move(value));

  return node;
}

void ResolvedDMLValue::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (value_ != nullptr) {
    child_nodes->emplace_back(value_.get());
  }
}

void ResolvedDMLValue::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (value_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &value_));
    static_assert(sizeof(value_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedDMLValue::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedDMLValue(this);
}

absl::Status ResolvedDMLValue::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (value_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(value_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedDMLValue::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (value_ != nullptr) {
    fields->emplace_back("value", value_.get());
  }
}

absl::Status ResolvedDMLValue::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDMLValue::value not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (value_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          value_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedDMLValue::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDMLValue::value is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (value_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(value_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedDMLValue::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (value_ != nullptr) value_->ClearFieldsAccessed();
}

void ResolvedDMLValue::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (value_ != nullptr) value_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedDMLDefault::TYPE;

ResolvedDMLDefault::~ResolvedDMLDefault() {
}

absl::Status ResolvedDMLDefault::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_dmldefault_node());
}

absl::Status ResolvedDMLDefault::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedDMLDefaultProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedDMLDefault>> ResolvedDMLDefault::RestoreFrom(
    const ResolvedDMLDefaultProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedDMLDefault(
      std::move(type));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

absl::Status ResolvedDMLDefault::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedDMLDefault(this);
}

absl::Status ResolvedDMLDefault::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

const ResolvedNodeKind ResolvedAssertStmt::TYPE;

ResolvedAssertStmt::~ResolvedAssertStmt() {
}

absl::Status ResolvedAssertStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_assert_stmt_node());
}

absl::Status ResolvedAssertStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAssertStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (expression_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expression_->SaveTo(
        file_descriptor_set_map, proto->mutable_expression()));
  }
  proto->set_description(description_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAssertStmt>> ResolvedAssertStmt::RestoreFrom(
    const ResolvedAssertStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> expression;
  if (proto.
  has_expression()) {
    ZETASQL_ASSIGN_OR_RETURN(expression,
                     ResolvedExpr::RestoreFrom(
                         proto.expression(), params));
  }
  std::string description =
      proto.description();
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedAssertStmt(
      std::move(expression),
      std::move(description));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedAssertStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expression_ != nullptr) {
    child_nodes->emplace_back(expression_.get());
  }
}

void ResolvedAssertStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expression_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expression_));
    static_assert(sizeof(expression_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedAssertStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAssertStmt(this);
}

absl::Status ResolvedAssertStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expression_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expression_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAssertStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (expression_ != nullptr) {
    fields->emplace_back("expression", expression_.get());
  }
  if (!IsDefaultValue(description_)) {
    fields->emplace_back("description", ToStringImpl(description_));
  }
}

absl::Status ResolvedAssertStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAssertStmt::expression not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(description_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAssertStmt::description not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expression_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expression_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAssertStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAssertStmt::expression is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAssertStmt::description is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expression_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expression_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAssertStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expression_ != nullptr) expression_->ClearFieldsAccessed();
}

void ResolvedAssertStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expression_ != nullptr) expression_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAssertRowsModified::TYPE;

ResolvedAssertRowsModified::~ResolvedAssertRowsModified() {
}

absl::Status ResolvedAssertRowsModified::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_assert_rows_modified_node());
}

absl::Status ResolvedAssertRowsModified::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAssertRowsModifiedProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (rows_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(rows_->SaveTo(
        file_descriptor_set_map, proto->mutable_rows()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAssertRowsModified>> ResolvedAssertRowsModified::RestoreFrom(
    const ResolvedAssertRowsModifiedProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> rows;
  if (proto.
  has_rows()) {
    ZETASQL_ASSIGN_OR_RETURN(rows,
                     ResolvedExpr::RestoreFrom(
                         proto.rows(), params));
  }
  auto node = MakeResolvedAssertRowsModified(
      std::move(rows));

  return node;
}

void ResolvedAssertRowsModified::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (rows_ != nullptr) {
    child_nodes->emplace_back(rows_.get());
  }
}

void ResolvedAssertRowsModified::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (rows_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &rows_));
    static_assert(sizeof(rows_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedAssertRowsModified::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAssertRowsModified(this);
}

absl::Status ResolvedAssertRowsModified::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (rows_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(rows_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAssertRowsModified::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (rows_ != nullptr) {
    fields->emplace_back("rows", rows_.get());
  }
}

absl::Status ResolvedAssertRowsModified::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAssertRowsModified::rows not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (rows_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          rows_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAssertRowsModified::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAssertRowsModified::rows is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (rows_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(rows_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAssertRowsModified::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (rows_ != nullptr) rows_->ClearFieldsAccessed();
}

void ResolvedAssertRowsModified::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (rows_ != nullptr) rows_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedInsertRow::TYPE;

ResolvedInsertRow::~ResolvedInsertRow() {
}

absl::Status ResolvedInsertRow::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_insert_row_node());
}

absl::Status ResolvedInsertRow::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedInsertRowProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : value_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_value_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedInsertRow>> ResolvedInsertRow::RestoreFrom(
    const ResolvedInsertRowProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedDMLValue>> value_list;
  for (const auto& elem : proto.value_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedDMLValue> elem_restored,
                     ResolvedDMLValue::RestoreFrom(elem, params));
    value_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedInsertRow(
      std::move(value_list));

  return node;
}

void ResolvedInsertRow::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : value_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedInsertRow::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : value_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedInsertRow::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedInsertRow(this);
}

absl::Status ResolvedInsertRow::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : value_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedInsertRow::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!value_list_.empty()) {
    fields->emplace_back("value_list", value_list_);
  }
}

absl::Status ResolvedInsertRow::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedInsertRow::value_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : value_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedInsertRow::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedInsertRow::value_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : value_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedInsertRow::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : value_list_) it->ClearFieldsAccessed();
}

void ResolvedInsertRow::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : value_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedInsertStmt::TYPE;

const ResolvedInsertStmt::InsertMode ResolvedInsertStmt::OR_ERROR;
const ResolvedInsertStmt::InsertMode ResolvedInsertStmt::OR_IGNORE;
const ResolvedInsertStmt::InsertMode ResolvedInsertStmt::OR_REPLACE;
const ResolvedInsertStmt::InsertMode ResolvedInsertStmt::OR_UPDATE;

ResolvedInsertStmt::~ResolvedInsertStmt() {
}

absl::Status ResolvedInsertStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_insert_stmt_node());
}

absl::Status ResolvedInsertStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedInsertStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_table_scan()));
  }
  proto->set_insert_mode(insert_mode_);
  if (assert_rows_modified_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(assert_rows_modified_->SaveTo(
        file_descriptor_set_map, proto->mutable_assert_rows_modified()));
  }
  if (returning_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(returning_->SaveTo(
        file_descriptor_set_map, proto->mutable_returning()));
  }
  for (const auto& elem : insert_column_list_) {
    ZETASQL_RETURN_IF_ERROR(SaveToImpl(
        elem, file_descriptor_set_map, proto->add_insert_column_list()));
  }
  for (const auto& elem : query_parameter_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_query_parameter_list()));
  }
  if (query_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(query_->SaveTo(
        file_descriptor_set_map, proto->mutable_query()));
  }
  for (const auto& elem : query_output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(SaveToImpl(
        elem, file_descriptor_set_map, proto->add_query_output_column_list()));
  }
  for (const auto& elem : row_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_row_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedInsertStmt>> ResolvedInsertStmt::RestoreFrom(
    const ResolvedInsertStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedTableScan> table_scan;
  if (proto.
  has_table_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(table_scan,
                     ResolvedTableScan::RestoreFrom(
                         proto.table_scan(), params));
  }
  InsertMode insert_mode =
      proto.insert_mode();
  std::unique_ptr<const ResolvedAssertRowsModified> assert_rows_modified;
  if (proto.
  has_assert_rows_modified()) {
    ZETASQL_ASSIGN_OR_RETURN(assert_rows_modified,
                     ResolvedAssertRowsModified::RestoreFrom(
                         proto.assert_rows_modified(), params));
  }
  std::unique_ptr<const ResolvedReturningClause> returning;
  if (proto.
  has_returning()) {
    ZETASQL_ASSIGN_OR_RETURN(returning,
                     ResolvedReturningClause::RestoreFrom(
                         proto.returning(), params));
  }
  std::vector<ResolvedColumn> insert_column_list;
  for (const auto& elem : proto.insert_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    insert_column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedColumnRef>> query_parameter_list;
  for (const auto& elem : proto.query_parameter_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedColumnRef> elem_restored,
                     ResolvedColumnRef::RestoreFrom(elem, params));
    query_parameter_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedScan> query;
  if (proto.
  has_query()) {
    ZETASQL_ASSIGN_OR_RETURN(query,
                     ResolvedScan::RestoreFrom(
                         proto.query(), params));
  }
  std::vector<ResolvedColumn> query_output_column_list;
  for (const auto& elem : proto.query_output_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    query_output_column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedInsertRow>> row_list;
  for (const auto& elem : proto.row_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedInsertRow> elem_restored,
                     ResolvedInsertRow::RestoreFrom(elem, params));
    row_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedInsertStmt(
      std::move(table_scan),
      std::move(insert_mode),
      std::move(assert_rows_modified),
      std::move(returning),
      std::move(insert_column_list),
      std::move(query_parameter_list),
      std::move(query),
      std::move(query_output_column_list),
      std::move(row_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedInsertStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (table_scan_ != nullptr) {
    child_nodes->emplace_back(table_scan_.get());
  }
  if (assert_rows_modified_ != nullptr) {
    child_nodes->emplace_back(assert_rows_modified_.get());
  }
  if (returning_ != nullptr) {
    child_nodes->emplace_back(returning_.get());
  }
  for (const auto& elem : query_parameter_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (query_ != nullptr) {
    child_nodes->emplace_back(query_.get());
  }
  for (const auto& elem : row_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedInsertStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (table_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &table_scan_));
    static_assert(sizeof(table_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (assert_rows_modified_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &assert_rows_modified_));
    static_assert(sizeof(assert_rows_modified_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (returning_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &returning_));
    static_assert(sizeof(returning_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : query_parameter_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (query_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &query_));
    static_assert(sizeof(query_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : row_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedInsertStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedInsertStmt(this);
}

absl::Status ResolvedInsertStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_.get()->Accept(visitor));
  }
  if (assert_rows_modified_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(assert_rows_modified_.get()->Accept(visitor));
  }
  if (returning_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(returning_.get()->Accept(visitor));
  }
  for (const auto& elem : query_parameter_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (query_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(query_.get()->Accept(visitor));
  }
  for (const auto& elem : row_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedInsertStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (table_scan_ != nullptr) {
    fields->emplace_back("table_scan", table_scan_.get());
  }
  if (!IsDefaultValue(insert_mode_)) {
    fields->emplace_back("insert_mode", ToStringImpl(insert_mode_));
  }
  if (assert_rows_modified_ != nullptr) {
    fields->emplace_back("assert_rows_modified", assert_rows_modified_.get());
  }
  if (returning_ != nullptr) {
    fields->emplace_back("returning", returning_.get());
  }
  if (!IsDefaultValue(insert_column_list_)) {
    fields->emplace_back("insert_column_list", ToStringImpl(insert_column_list_));
  }
  if (!query_parameter_list_.empty()) {
    fields->emplace_back("query_parameter_list", query_parameter_list_);
  }
  if (query_ != nullptr) {
    fields->emplace_back("query", query_.get());
  }
  if (!IsDefaultValue(query_output_column_list_)) {
    fields->emplace_back("query_output_column_list", ToStringImpl(query_output_column_list_));
  }
  if (!row_list_.empty()) {
    fields->emplace_back("row_list", row_list_);
  }
}

absl::Status ResolvedInsertStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(table_scan_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedInsertStmt::table_scan not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(insert_mode_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedInsertStmt::insert_mode not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(assert_rows_modified_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedInsertStmt::assert_rows_modified not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(returning_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedInsertStmt::returning not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(insert_column_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedInsertStmt::insert_column_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0 &&
      !IsDefaultValue(query_parameter_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedInsertStmt::query_parameter_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<6)) == 0 &&
      !IsDefaultValue(query_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedInsertStmt::query not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<7)) == 0 &&
      !IsDefaultValue(query_output_column_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedInsertStmt::query_output_column_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<8)) == 0 &&
      !IsDefaultValue(row_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedInsertStmt::row_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          table_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (assert_rows_modified_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          assert_rows_modified_.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (returning_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          returning_.get(), root));
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : query_parameter_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    if (query_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          query_.get(), root));
    }
  }
  if ((accessed_ & (1<<8)) != 0) {
    for (const auto& it : row_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedInsertStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedInsertStmt::table_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedInsertStmt::insert_mode is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedInsertStmt::assert_rows_modified is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedInsertStmt::returning is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedInsertStmt::insert_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedInsertStmt::query_parameter_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<6)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedInsertStmt::query is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<7)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedInsertStmt::query_output_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<8)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedInsertStmt::row_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(table_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (assert_rows_modified_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(assert_rows_modified_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (returning_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(returning_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : query_parameter_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    if (query_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(query_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<8)) != 0) {
    for (const auto& it : row_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedInsertStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (table_scan_ != nullptr) table_scan_->ClearFieldsAccessed();
  if (assert_rows_modified_ != nullptr) assert_rows_modified_->ClearFieldsAccessed();
  if (returning_ != nullptr) returning_->ClearFieldsAccessed();
  for (const auto& it : query_parameter_list_) it->ClearFieldsAccessed();
  if (query_ != nullptr) query_->ClearFieldsAccessed();
  for (const auto& it : row_list_) it->ClearFieldsAccessed();
}

void ResolvedInsertStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (table_scan_ != nullptr) table_scan_->MarkFieldsAccessed();
  if (assert_rows_modified_ != nullptr) assert_rows_modified_->MarkFieldsAccessed();
  if (returning_ != nullptr) returning_->MarkFieldsAccessed();
  for (const auto& it : query_parameter_list_) it->MarkFieldsAccessed();
  if (query_ != nullptr) query_->MarkFieldsAccessed();
  for (const auto& it : row_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedDeleteStmt::TYPE;

ResolvedDeleteStmt::~ResolvedDeleteStmt() {
}

absl::Status ResolvedDeleteStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_delete_stmt_node());
}

absl::Status ResolvedDeleteStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedDeleteStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_table_scan()));
  }
  if (assert_rows_modified_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(assert_rows_modified_->SaveTo(
        file_descriptor_set_map, proto->mutable_assert_rows_modified()));
  }
  if (returning_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(returning_->SaveTo(
        file_descriptor_set_map, proto->mutable_returning()));
  }
  if (array_offset_column_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(array_offset_column_->SaveTo(
        file_descriptor_set_map, proto->mutable_array_offset_column()));
  }
  if (where_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(where_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_where_expr()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedDeleteStmt>> ResolvedDeleteStmt::RestoreFrom(
    const ResolvedDeleteStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedTableScan> table_scan;
  if (proto.
  has_table_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(table_scan,
                     ResolvedTableScan::RestoreFrom(
                         proto.table_scan(), params));
  }
  std::unique_ptr<const ResolvedAssertRowsModified> assert_rows_modified;
  if (proto.
  has_assert_rows_modified()) {
    ZETASQL_ASSIGN_OR_RETURN(assert_rows_modified,
                     ResolvedAssertRowsModified::RestoreFrom(
                         proto.assert_rows_modified(), params));
  }
  std::unique_ptr<const ResolvedReturningClause> returning;
  if (proto.
  has_returning()) {
    ZETASQL_ASSIGN_OR_RETURN(returning,
                     ResolvedReturningClause::RestoreFrom(
                         proto.returning(), params));
  }
  std::unique_ptr<const ResolvedColumnHolder> array_offset_column;
  if (proto.
  has_array_offset_column()) {
    ZETASQL_ASSIGN_OR_RETURN(array_offset_column,
                     ResolvedColumnHolder::RestoreFrom(
                         proto.array_offset_column(), params));
  }
  std::unique_ptr<const ResolvedExpr> where_expr;
  if (proto.
  has_where_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(where_expr,
                     ResolvedExpr::RestoreFrom(
                         proto.where_expr(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedDeleteStmt(
      std::move(table_scan),
      std::move(assert_rows_modified),
      std::move(returning),
      std::move(array_offset_column),
      std::move(where_expr));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedDeleteStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (table_scan_ != nullptr) {
    child_nodes->emplace_back(table_scan_.get());
  }
  if (assert_rows_modified_ != nullptr) {
    child_nodes->emplace_back(assert_rows_modified_.get());
  }
  if (returning_ != nullptr) {
    child_nodes->emplace_back(returning_.get());
  }
  if (array_offset_column_ != nullptr) {
    child_nodes->emplace_back(array_offset_column_.get());
  }
  if (where_expr_ != nullptr) {
    child_nodes->emplace_back(where_expr_.get());
  }
}

void ResolvedDeleteStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (table_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &table_scan_));
    static_assert(sizeof(table_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (assert_rows_modified_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &assert_rows_modified_));
    static_assert(sizeof(assert_rows_modified_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (returning_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &returning_));
    static_assert(sizeof(returning_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (array_offset_column_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &array_offset_column_));
    static_assert(sizeof(array_offset_column_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (where_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &where_expr_));
    static_assert(sizeof(where_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedDeleteStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedDeleteStmt(this);
}

absl::Status ResolvedDeleteStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_.get()->Accept(visitor));
  }
  if (assert_rows_modified_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(assert_rows_modified_.get()->Accept(visitor));
  }
  if (returning_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(returning_.get()->Accept(visitor));
  }
  if (array_offset_column_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(array_offset_column_.get()->Accept(visitor));
  }
  if (where_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(where_expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedDeleteStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (table_scan_ != nullptr) {
    fields->emplace_back("table_scan", table_scan_.get());
  }
  if (assert_rows_modified_ != nullptr) {
    fields->emplace_back("assert_rows_modified", assert_rows_modified_.get());
  }
  if (returning_ != nullptr) {
    fields->emplace_back("returning", returning_.get());
  }
  if (array_offset_column_ != nullptr) {
    fields->emplace_back("array_offset_column", array_offset_column_.get());
  }
  if (where_expr_ != nullptr) {
    fields->emplace_back("where_expr", where_expr_.get());
  }
}

absl::Status ResolvedDeleteStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(table_scan_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDeleteStmt::table_scan not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(assert_rows_modified_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDeleteStmt::assert_rows_modified not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(returning_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDeleteStmt::returning not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(array_offset_column_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDeleteStmt::array_offset_column not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDeleteStmt::where_expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          table_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (assert_rows_modified_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          assert_rows_modified_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (returning_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          returning_.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (array_offset_column_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          array_offset_column_.get(), root));
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (where_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          where_expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedDeleteStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDeleteStmt::table_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDeleteStmt::assert_rows_modified is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDeleteStmt::returning is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDeleteStmt::array_offset_column is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDeleteStmt::where_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(table_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (assert_rows_modified_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(assert_rows_modified_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (returning_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(returning_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (array_offset_column_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(array_offset_column_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (where_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(where_expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedDeleteStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (table_scan_ != nullptr) table_scan_->ClearFieldsAccessed();
  if (assert_rows_modified_ != nullptr) assert_rows_modified_->ClearFieldsAccessed();
  if (returning_ != nullptr) returning_->ClearFieldsAccessed();
  if (array_offset_column_ != nullptr) array_offset_column_->ClearFieldsAccessed();
  if (where_expr_ != nullptr) where_expr_->ClearFieldsAccessed();
}

void ResolvedDeleteStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (table_scan_ != nullptr) table_scan_->MarkFieldsAccessed();
  if (assert_rows_modified_ != nullptr) assert_rows_modified_->MarkFieldsAccessed();
  if (returning_ != nullptr) returning_->MarkFieldsAccessed();
  if (array_offset_column_ != nullptr) array_offset_column_->MarkFieldsAccessed();
  if (where_expr_ != nullptr) where_expr_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedUpdateItem::TYPE;

ResolvedUpdateItem::~ResolvedUpdateItem() {
}

absl::Status ResolvedUpdateItem::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_update_item_node());
}

absl::Status ResolvedUpdateItem::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedUpdateItemProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (target_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(target_->SaveTo(
        file_descriptor_set_map, proto->mutable_target()));
  }
  if (set_value_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(set_value_->SaveTo(
        file_descriptor_set_map, proto->mutable_set_value()));
  }
  if (element_column_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(element_column_->SaveTo(
        file_descriptor_set_map, proto->mutable_element_column()));
  }
  for (const auto& elem : array_update_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_array_update_list()));
  }
  for (const auto& elem : delete_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_delete_list()));
  }
  for (const auto& elem : update_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_update_list()));
  }
  for (const auto& elem : insert_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_insert_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedUpdateItem>> ResolvedUpdateItem::RestoreFrom(
    const ResolvedUpdateItemProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> target;
  if (proto.
  has_target()) {
    ZETASQL_ASSIGN_OR_RETURN(target,
                     ResolvedExpr::RestoreFrom(
                         proto.target(), params));
  }
  std::unique_ptr<const ResolvedDMLValue> set_value;
  if (proto.
  has_set_value()) {
    ZETASQL_ASSIGN_OR_RETURN(set_value,
                     ResolvedDMLValue::RestoreFrom(
                         proto.set_value(), params));
  }
  std::unique_ptr<const ResolvedColumnHolder> element_column;
  if (proto.
  has_element_column()) {
    ZETASQL_ASSIGN_OR_RETURN(element_column,
                     ResolvedColumnHolder::RestoreFrom(
                         proto.element_column(), params));
  }
  std::vector<std::unique_ptr<const ResolvedUpdateArrayItem>> array_update_list;
  for (const auto& elem : proto.array_update_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedUpdateArrayItem> elem_restored,
                     ResolvedUpdateArrayItem::RestoreFrom(elem, params));
    array_update_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedDeleteStmt>> delete_list;
  for (const auto& elem : proto.delete_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedDeleteStmt> elem_restored,
                     ResolvedDeleteStmt::RestoreFrom(elem, params));
    delete_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedUpdateStmt>> update_list;
  for (const auto& elem : proto.update_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedUpdateStmt> elem_restored,
                     ResolvedUpdateStmt::RestoreFrom(elem, params));
    update_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedInsertStmt>> insert_list;
  for (const auto& elem : proto.insert_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedInsertStmt> elem_restored,
                     ResolvedInsertStmt::RestoreFrom(elem, params));
    insert_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedUpdateItem(
      std::move(target),
      std::move(set_value),
      std::move(element_column),
      std::move(array_update_list),
      std::move(delete_list),
      std::move(update_list),
      std::move(insert_list));

  return node;
}

void ResolvedUpdateItem::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (target_ != nullptr) {
    child_nodes->emplace_back(target_.get());
  }
  if (set_value_ != nullptr) {
    child_nodes->emplace_back(set_value_.get());
  }
  if (element_column_ != nullptr) {
    child_nodes->emplace_back(element_column_.get());
  }
  for (const auto& elem : array_update_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : delete_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : update_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : insert_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedUpdateItem::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (target_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &target_));
    static_assert(sizeof(target_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (set_value_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &set_value_));
    static_assert(sizeof(set_value_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (element_column_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &element_column_));
    static_assert(sizeof(element_column_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : array_update_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : delete_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : update_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : insert_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedUpdateItem::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedUpdateItem(this);
}

absl::Status ResolvedUpdateItem::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (target_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(target_.get()->Accept(visitor));
  }
  if (set_value_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(set_value_.get()->Accept(visitor));
  }
  if (element_column_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(element_column_.get()->Accept(visitor));
  }
  for (const auto& elem : array_update_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : delete_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : update_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : insert_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedUpdateItem::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (target_ != nullptr) {
    fields->emplace_back("target", target_.get());
  }
  if (set_value_ != nullptr) {
    fields->emplace_back("set_value", set_value_.get());
  }
  if (element_column_ != nullptr) {
    fields->emplace_back("element_column", element_column_.get());
  }
  if (!array_update_list_.empty()) {
    fields->emplace_back("array_update_list", array_update_list_);
  }
  if (!delete_list_.empty()) {
    fields->emplace_back("delete_list", delete_list_);
  }
  if (!update_list_.empty()) {
    fields->emplace_back("update_list", update_list_);
  }
  if (!insert_list_.empty()) {
    fields->emplace_back("insert_list", insert_list_);
  }
}

absl::Status ResolvedUpdateItem::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUpdateItem::target not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(set_value_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUpdateItem::set_value not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUpdateItem::element_column not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(array_update_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUpdateItem::array_update_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(delete_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUpdateItem::delete_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0 &&
      !IsDefaultValue(update_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUpdateItem::update_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<6)) == 0 &&
      !IsDefaultValue(insert_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUpdateItem::insert_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (target_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          target_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (set_value_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          set_value_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (element_column_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          element_column_.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : array_update_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    for (const auto& it : delete_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : update_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    for (const auto& it : insert_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedUpdateItem::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUpdateItem::target is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUpdateItem::set_value is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUpdateItem::element_column is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUpdateItem::array_update_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUpdateItem::delete_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUpdateItem::update_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<6)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUpdateItem::insert_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (target_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(target_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (set_value_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(set_value_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (element_column_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(element_column_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : array_update_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    for (const auto& it : delete_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : update_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    for (const auto& it : insert_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedUpdateItem::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (target_ != nullptr) target_->ClearFieldsAccessed();
  if (set_value_ != nullptr) set_value_->ClearFieldsAccessed();
  if (element_column_ != nullptr) element_column_->ClearFieldsAccessed();
  for (const auto& it : array_update_list_) it->ClearFieldsAccessed();
  for (const auto& it : delete_list_) it->ClearFieldsAccessed();
  for (const auto& it : update_list_) it->ClearFieldsAccessed();
  for (const auto& it : insert_list_) it->ClearFieldsAccessed();
}

void ResolvedUpdateItem::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (target_ != nullptr) target_->MarkFieldsAccessed();
  if (set_value_ != nullptr) set_value_->MarkFieldsAccessed();
  if (element_column_ != nullptr) element_column_->MarkFieldsAccessed();
  for (const auto& it : array_update_list_) it->MarkFieldsAccessed();
  for (const auto& it : delete_list_) it->MarkFieldsAccessed();
  for (const auto& it : update_list_) it->MarkFieldsAccessed();
  for (const auto& it : insert_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedUpdateArrayItem::TYPE;

ResolvedUpdateArrayItem::~ResolvedUpdateArrayItem() {
}

absl::Status ResolvedUpdateArrayItem::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_update_array_item_node());
}

absl::Status ResolvedUpdateArrayItem::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedUpdateArrayItemProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (offset_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(offset_->SaveTo(
        file_descriptor_set_map, proto->mutable_offset()));
  }
  if (update_item_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(update_item_->SaveTo(
        file_descriptor_set_map, proto->mutable_update_item()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedUpdateArrayItem>> ResolvedUpdateArrayItem::RestoreFrom(
    const ResolvedUpdateArrayItemProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> offset;
  if (proto.
  has_offset()) {
    ZETASQL_ASSIGN_OR_RETURN(offset,
                     ResolvedExpr::RestoreFrom(
                         proto.offset(), params));
  }
  std::unique_ptr<const ResolvedUpdateItem> update_item;
  if (proto.
  has_update_item()) {
    ZETASQL_ASSIGN_OR_RETURN(update_item,
                     ResolvedUpdateItem::RestoreFrom(
                         proto.update_item(), params));
  }
  auto node = MakeResolvedUpdateArrayItem(
      std::move(offset),
      std::move(update_item));

  return node;
}

void ResolvedUpdateArrayItem::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (offset_ != nullptr) {
    child_nodes->emplace_back(offset_.get());
  }
  if (update_item_ != nullptr) {
    child_nodes->emplace_back(update_item_.get());
  }
}

void ResolvedUpdateArrayItem::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (offset_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &offset_));
    static_assert(sizeof(offset_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (update_item_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &update_item_));
    static_assert(sizeof(update_item_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedUpdateArrayItem::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedUpdateArrayItem(this);
}

absl::Status ResolvedUpdateArrayItem::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (offset_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(offset_.get()->Accept(visitor));
  }
  if (update_item_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(update_item_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedUpdateArrayItem::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (offset_ != nullptr) {
    fields->emplace_back("offset", offset_.get());
  }
  if (update_item_ != nullptr) {
    fields->emplace_back("update_item", update_item_.get());
  }
}

absl::Status ResolvedUpdateArrayItem::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUpdateArrayItem::offset not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUpdateArrayItem::update_item not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (offset_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          offset_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (update_item_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          update_item_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedUpdateArrayItem::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUpdateArrayItem::offset is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUpdateArrayItem::update_item is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (offset_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(offset_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (update_item_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(update_item_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedUpdateArrayItem::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (offset_ != nullptr) offset_->ClearFieldsAccessed();
  if (update_item_ != nullptr) update_item_->ClearFieldsAccessed();
}

void ResolvedUpdateArrayItem::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (offset_ != nullptr) offset_->MarkFieldsAccessed();
  if (update_item_ != nullptr) update_item_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedUpdateStmt::TYPE;

ResolvedUpdateStmt::~ResolvedUpdateStmt() {
}

absl::Status ResolvedUpdateStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_update_stmt_node());
}

absl::Status ResolvedUpdateStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedUpdateStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_table_scan()));
  }
  for (const auto& elem : column_access_list_) {
    proto->add_column_access_list(elem);
  }
  if (assert_rows_modified_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(assert_rows_modified_->SaveTo(
        file_descriptor_set_map, proto->mutable_assert_rows_modified()));
  }
  if (returning_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(returning_->SaveTo(
        file_descriptor_set_map, proto->mutable_returning()));
  }
  if (array_offset_column_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(array_offset_column_->SaveTo(
        file_descriptor_set_map, proto->mutable_array_offset_column()));
  }
  if (where_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(where_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_where_expr()));
  }
  for (const auto& elem : update_item_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_update_item_list()));
  }
  if (from_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(from_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_from_scan()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedUpdateStmt>> ResolvedUpdateStmt::RestoreFrom(
    const ResolvedUpdateStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedTableScan> table_scan;
  if (proto.
  has_table_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(table_scan,
                     ResolvedTableScan::RestoreFrom(
                         proto.table_scan(), params));
  }
  std::vector<ObjectAccess> column_access_list;
  for (const auto& elem : proto.column_access_list()) {
    // We need a static cast because the proto getter returns a
    // RepeatedField<int>, not RepeatedField<enum>.
    column_access_list.push_back(static_cast<ObjectAccess>(elem));
  }
  std::unique_ptr<const ResolvedAssertRowsModified> assert_rows_modified;
  if (proto.
  has_assert_rows_modified()) {
    ZETASQL_ASSIGN_OR_RETURN(assert_rows_modified,
                     ResolvedAssertRowsModified::RestoreFrom(
                         proto.assert_rows_modified(), params));
  }
  std::unique_ptr<const ResolvedReturningClause> returning;
  if (proto.
  has_returning()) {
    ZETASQL_ASSIGN_OR_RETURN(returning,
                     ResolvedReturningClause::RestoreFrom(
                         proto.returning(), params));
  }
  std::unique_ptr<const ResolvedColumnHolder> array_offset_column;
  if (proto.
  has_array_offset_column()) {
    ZETASQL_ASSIGN_OR_RETURN(array_offset_column,
                     ResolvedColumnHolder::RestoreFrom(
                         proto.array_offset_column(), params));
  }
  std::unique_ptr<const ResolvedExpr> where_expr;
  if (proto.
  has_where_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(where_expr,
                     ResolvedExpr::RestoreFrom(
                         proto.where_expr(), params));
  }
  std::vector<std::unique_ptr<const ResolvedUpdateItem>> update_item_list;
  for (const auto& elem : proto.update_item_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedUpdateItem> elem_restored,
                     ResolvedUpdateItem::RestoreFrom(elem, params));
    update_item_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedScan> from_scan;
  if (proto.
  has_from_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(from_scan,
                     ResolvedScan::RestoreFrom(
                         proto.from_scan(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedUpdateStmt(
      std::move(table_scan),
      std::move(assert_rows_modified),
      std::move(returning),
      std::move(array_offset_column),
      std::move(where_expr),
      std::move(update_item_list),
      std::move(from_scan));

  node->set_hint_list(std::move(hint_list));
  node->set_column_access_list(std::move(column_access_list));
  return node;
}

void ResolvedUpdateStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (table_scan_ != nullptr) {
    child_nodes->emplace_back(table_scan_.get());
  }
  if (assert_rows_modified_ != nullptr) {
    child_nodes->emplace_back(assert_rows_modified_.get());
  }
  if (returning_ != nullptr) {
    child_nodes->emplace_back(returning_.get());
  }
  if (array_offset_column_ != nullptr) {
    child_nodes->emplace_back(array_offset_column_.get());
  }
  if (where_expr_ != nullptr) {
    child_nodes->emplace_back(where_expr_.get());
  }
  for (const auto& elem : update_item_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (from_scan_ != nullptr) {
    child_nodes->emplace_back(from_scan_.get());
  }
}

void ResolvedUpdateStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (table_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &table_scan_));
    static_assert(sizeof(table_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (assert_rows_modified_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &assert_rows_modified_));
    static_assert(sizeof(assert_rows_modified_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (returning_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &returning_));
    static_assert(sizeof(returning_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (array_offset_column_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &array_offset_column_));
    static_assert(sizeof(array_offset_column_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (where_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &where_expr_));
    static_assert(sizeof(where_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : update_item_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (from_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &from_scan_));
    static_assert(sizeof(from_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedUpdateStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedUpdateStmt(this);
}

absl::Status ResolvedUpdateStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_.get()->Accept(visitor));
  }
  if (assert_rows_modified_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(assert_rows_modified_.get()->Accept(visitor));
  }
  if (returning_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(returning_.get()->Accept(visitor));
  }
  if (array_offset_column_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(array_offset_column_.get()->Accept(visitor));
  }
  if (where_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(where_expr_.get()->Accept(visitor));
  }
  for (const auto& elem : update_item_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (from_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(from_scan_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedUpdateStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (table_scan_ != nullptr) {
    fields->emplace_back("table_scan", table_scan_.get());
  }
  if (!IsDefaultValue(column_access_list_)) {
    fields->emplace_back("column_access_list", ToStringImpl(column_access_list_));
  }
  if (assert_rows_modified_ != nullptr) {
    fields->emplace_back("assert_rows_modified", assert_rows_modified_.get());
  }
  if (returning_ != nullptr) {
    fields->emplace_back("returning", returning_.get());
  }
  if (array_offset_column_ != nullptr) {
    fields->emplace_back("array_offset_column", array_offset_column_.get());
  }
  if (where_expr_ != nullptr) {
    fields->emplace_back("where_expr", where_expr_.get());
  }
  if (!update_item_list_.empty()) {
    fields->emplace_back("update_item_list", update_item_list_);
  }
  if (from_scan_ != nullptr) {
    fields->emplace_back("from_scan", from_scan_.get());
  }
}

absl::Status ResolvedUpdateStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(table_scan_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUpdateStmt::table_scan not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(assert_rows_modified_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUpdateStmt::assert_rows_modified not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(returning_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUpdateStmt::returning not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(array_offset_column_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUpdateStmt::array_offset_column not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUpdateStmt::where_expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<6)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUpdateStmt::update_item_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<7)) == 0 &&
      !IsDefaultValue(from_scan_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUpdateStmt::from_scan not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          table_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (assert_rows_modified_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          assert_rows_modified_.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (returning_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          returning_.get(), root));
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (array_offset_column_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          array_offset_column_.get(), root));
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    if (where_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          where_expr_.get(), root));
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    for (const auto& it : update_item_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<7)) != 0) {
    if (from_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          from_scan_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedUpdateStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUpdateStmt::table_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUpdateStmt::assert_rows_modified is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUpdateStmt::returning is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUpdateStmt::array_offset_column is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUpdateStmt::where_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<6)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUpdateStmt::update_item_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<7)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUpdateStmt::from_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(table_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (assert_rows_modified_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(assert_rows_modified_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (returning_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(returning_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (array_offset_column_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(array_offset_column_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    if (where_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(where_expr_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    for (const auto& it : update_item_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<7)) != 0) {
    if (from_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(from_scan_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedUpdateStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (table_scan_ != nullptr) table_scan_->ClearFieldsAccessed();
  if (assert_rows_modified_ != nullptr) assert_rows_modified_->ClearFieldsAccessed();
  if (returning_ != nullptr) returning_->ClearFieldsAccessed();
  if (array_offset_column_ != nullptr) array_offset_column_->ClearFieldsAccessed();
  if (where_expr_ != nullptr) where_expr_->ClearFieldsAccessed();
  for (const auto& it : update_item_list_) it->ClearFieldsAccessed();
  if (from_scan_ != nullptr) from_scan_->ClearFieldsAccessed();
}

void ResolvedUpdateStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (table_scan_ != nullptr) table_scan_->MarkFieldsAccessed();
  if (assert_rows_modified_ != nullptr) assert_rows_modified_->MarkFieldsAccessed();
  if (returning_ != nullptr) returning_->MarkFieldsAccessed();
  if (array_offset_column_ != nullptr) array_offset_column_->MarkFieldsAccessed();
  if (where_expr_ != nullptr) where_expr_->MarkFieldsAccessed();
  for (const auto& it : update_item_list_) it->MarkFieldsAccessed();
  if (from_scan_ != nullptr) from_scan_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedMergeWhen::TYPE;

const ResolvedMergeWhen::MatchType ResolvedMergeWhen::MATCHED;
const ResolvedMergeWhen::MatchType ResolvedMergeWhen::NOT_MATCHED_BY_SOURCE;
const ResolvedMergeWhen::MatchType ResolvedMergeWhen::NOT_MATCHED_BY_TARGET;
const ResolvedMergeWhen::ActionType ResolvedMergeWhen::INSERT;
const ResolvedMergeWhen::ActionType ResolvedMergeWhen::UPDATE;
const ResolvedMergeWhen::ActionType ResolvedMergeWhen::DELETE;

ResolvedMergeWhen::~ResolvedMergeWhen() {
}

absl::Status ResolvedMergeWhen::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_merge_when_node());
}

absl::Status ResolvedMergeWhen::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedMergeWhenProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_match_type(match_type_);
  if (match_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(match_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_match_expr()));
  }
  proto->set_action_type(action_type_);
  for (const auto& elem : insert_column_list_) {
    ZETASQL_RETURN_IF_ERROR(SaveToImpl(
        elem, file_descriptor_set_map, proto->add_insert_column_list()));
  }
  if (insert_row_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(insert_row_->SaveTo(
        file_descriptor_set_map, proto->mutable_insert_row()));
  }
  for (const auto& elem : update_item_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_update_item_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedMergeWhen>> ResolvedMergeWhen::RestoreFrom(
    const ResolvedMergeWhenProto& proto,
    const ResolvedNode::RestoreParams& params) {
  MatchType match_type =
      proto.match_type();
  std::unique_ptr<const ResolvedExpr> match_expr;
  if (proto.
  has_match_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(match_expr,
                     ResolvedExpr::RestoreFrom(
                         proto.match_expr(), params));
  }
  ActionType action_type =
      proto.action_type();
  std::vector<ResolvedColumn> insert_column_list;
  for (const auto& elem : proto.insert_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    insert_column_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedInsertRow> insert_row;
  if (proto.
  has_insert_row()) {
    ZETASQL_ASSIGN_OR_RETURN(insert_row,
                     ResolvedInsertRow::RestoreFrom(
                         proto.insert_row(), params));
  }
  std::vector<std::unique_ptr<const ResolvedUpdateItem>> update_item_list;
  for (const auto& elem : proto.update_item_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedUpdateItem> elem_restored,
                     ResolvedUpdateItem::RestoreFrom(elem, params));
    update_item_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedMergeWhen(
      std::move(match_type),
      std::move(match_expr),
      std::move(action_type),
      std::move(insert_column_list),
      std::move(insert_row),
      std::move(update_item_list));

  return node;
}

void ResolvedMergeWhen::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (match_expr_ != nullptr) {
    child_nodes->emplace_back(match_expr_.get());
  }
  if (insert_row_ != nullptr) {
    child_nodes->emplace_back(insert_row_.get());
  }
  for (const auto& elem : update_item_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedMergeWhen::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (match_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &match_expr_));
    static_assert(sizeof(match_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (insert_row_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &insert_row_));
    static_assert(sizeof(insert_row_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : update_item_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedMergeWhen::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedMergeWhen(this);
}

absl::Status ResolvedMergeWhen::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (match_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(match_expr_.get()->Accept(visitor));
  }
  if (insert_row_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(insert_row_.get()->Accept(visitor));
  }
  for (const auto& elem : update_item_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedMergeWhen::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("match_type", ToStringImpl(match_type_));
  }
  if (match_expr_ != nullptr) {
    fields->emplace_back("match_expr", match_expr_.get());
  }
  {
    fields->emplace_back("action_type", ToStringImpl(action_type_));
  }
  if (!IsDefaultValue(insert_column_list_)) {
    fields->emplace_back("insert_column_list", ToStringImpl(insert_column_list_));
  }
  if (insert_row_ != nullptr) {
    fields->emplace_back("insert_row", insert_row_.get());
  }
  if (!update_item_list_.empty()) {
    fields->emplace_back("update_item_list", update_item_list_);
  }
}

absl::Status ResolvedMergeWhen::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedMergeWhen::match_type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedMergeWhen::match_expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedMergeWhen::action_type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(insert_column_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedMergeWhen::insert_column_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(insert_row_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedMergeWhen::insert_row not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0 &&
      !IsDefaultValue(update_item_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedMergeWhen::update_item_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (match_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          match_expr_.get(), root));
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (insert_row_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          insert_row_.get(), root));
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : update_item_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedMergeWhen::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedMergeWhen::match_type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedMergeWhen::match_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedMergeWhen::action_type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedMergeWhen::insert_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedMergeWhen::insert_row is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedMergeWhen::update_item_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (match_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(match_expr_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    if (insert_row_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(insert_row_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : update_item_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedMergeWhen::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (match_expr_ != nullptr) match_expr_->ClearFieldsAccessed();
  if (insert_row_ != nullptr) insert_row_->ClearFieldsAccessed();
  for (const auto& it : update_item_list_) it->ClearFieldsAccessed();
}

void ResolvedMergeWhen::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (match_expr_ != nullptr) match_expr_->MarkFieldsAccessed();
  if (insert_row_ != nullptr) insert_row_->MarkFieldsAccessed();
  for (const auto& it : update_item_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedMergeStmt::TYPE;

ResolvedMergeStmt::~ResolvedMergeStmt() {
}

absl::Status ResolvedMergeStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_merge_stmt_node());
}

absl::Status ResolvedMergeStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedMergeStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_table_scan()));
  }
  for (const auto& elem : column_access_list_) {
    proto->add_column_access_list(elem);
  }
  if (from_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(from_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_from_scan()));
  }
  if (merge_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(merge_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_merge_expr()));
  }
  for (const auto& elem : when_clause_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_when_clause_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedMergeStmt>> ResolvedMergeStmt::RestoreFrom(
    const ResolvedMergeStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedTableScan> table_scan;
  if (proto.
  has_table_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(table_scan,
                     ResolvedTableScan::RestoreFrom(
                         proto.table_scan(), params));
  }
  std::vector<ObjectAccess> column_access_list;
  for (const auto& elem : proto.column_access_list()) {
    // We need a static cast because the proto getter returns a
    // RepeatedField<int>, not RepeatedField<enum>.
    column_access_list.push_back(static_cast<ObjectAccess>(elem));
  }
  std::unique_ptr<const ResolvedScan> from_scan;
  if (proto.
  has_from_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(from_scan,
                     ResolvedScan::RestoreFrom(
                         proto.from_scan(), params));
  }
  std::unique_ptr<const ResolvedExpr> merge_expr;
  if (proto.
  has_merge_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(merge_expr,
                     ResolvedExpr::RestoreFrom(
                         proto.merge_expr(), params));
  }
  std::vector<std::unique_ptr<const ResolvedMergeWhen>> when_clause_list;
  for (const auto& elem : proto.when_clause_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedMergeWhen> elem_restored,
                     ResolvedMergeWhen::RestoreFrom(elem, params));
    when_clause_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedMergeStmt(
      std::move(table_scan),
      std::move(from_scan),
      std::move(merge_expr),
      std::move(when_clause_list));

  node->set_hint_list(std::move(hint_list));
  node->set_column_access_list(std::move(column_access_list));
  return node;
}

void ResolvedMergeStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (table_scan_ != nullptr) {
    child_nodes->emplace_back(table_scan_.get());
  }
  if (from_scan_ != nullptr) {
    child_nodes->emplace_back(from_scan_.get());
  }
  if (merge_expr_ != nullptr) {
    child_nodes->emplace_back(merge_expr_.get());
  }
  for (const auto& elem : when_clause_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedMergeStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (table_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &table_scan_));
    static_assert(sizeof(table_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (from_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &from_scan_));
    static_assert(sizeof(from_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (merge_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &merge_expr_));
    static_assert(sizeof(merge_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : when_clause_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedMergeStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedMergeStmt(this);
}

absl::Status ResolvedMergeStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_.get()->Accept(visitor));
  }
  if (from_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(from_scan_.get()->Accept(visitor));
  }
  if (merge_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(merge_expr_.get()->Accept(visitor));
  }
  for (const auto& elem : when_clause_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedMergeStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (table_scan_ != nullptr) {
    fields->emplace_back("table_scan", table_scan_.get());
  }
  if (!IsDefaultValue(column_access_list_)) {
    fields->emplace_back("column_access_list", ToStringImpl(column_access_list_));
  }
  if (from_scan_ != nullptr) {
    fields->emplace_back("from_scan", from_scan_.get());
  }
  if (merge_expr_ != nullptr) {
    fields->emplace_back("merge_expr", merge_expr_.get());
  }
  if (!when_clause_list_.empty()) {
    fields->emplace_back("when_clause_list", when_clause_list_);
  }
}

absl::Status ResolvedMergeStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedMergeStmt::table_scan not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedMergeStmt::from_scan not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedMergeStmt::merge_expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedMergeStmt::when_clause_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          table_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (from_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          from_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (merge_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          merge_expr_.get(), root));
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    for (const auto& it : when_clause_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedMergeStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedMergeStmt::table_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedMergeStmt::from_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedMergeStmt::merge_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedMergeStmt::when_clause_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(table_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (from_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(from_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (merge_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(merge_expr_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    for (const auto& it : when_clause_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedMergeStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (table_scan_ != nullptr) table_scan_->ClearFieldsAccessed();
  if (from_scan_ != nullptr) from_scan_->ClearFieldsAccessed();
  if (merge_expr_ != nullptr) merge_expr_->ClearFieldsAccessed();
  for (const auto& it : when_clause_list_) it->ClearFieldsAccessed();
}

void ResolvedMergeStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (table_scan_ != nullptr) table_scan_->MarkFieldsAccessed();
  if (from_scan_ != nullptr) from_scan_->MarkFieldsAccessed();
  if (merge_expr_ != nullptr) merge_expr_->MarkFieldsAccessed();
  for (const auto& it : when_clause_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedTruncateStmt::TYPE;

ResolvedTruncateStmt::~ResolvedTruncateStmt() {
}

absl::Status ResolvedTruncateStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_truncate_stmt_node());
}

absl::Status ResolvedTruncateStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedTruncateStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_table_scan()));
  }
  if (where_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(where_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_where_expr()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedTruncateStmt>> ResolvedTruncateStmt::RestoreFrom(
    const ResolvedTruncateStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedTableScan> table_scan;
  if (proto.
  has_table_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(table_scan,
                     ResolvedTableScan::RestoreFrom(
                         proto.table_scan(), params));
  }
  std::unique_ptr<const ResolvedExpr> where_expr;
  if (proto.
  has_where_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(where_expr,
                     ResolvedExpr::RestoreFrom(
                         proto.where_expr(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedTruncateStmt(
      std::move(table_scan),
      std::move(where_expr));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedTruncateStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (table_scan_ != nullptr) {
    child_nodes->emplace_back(table_scan_.get());
  }
  if (where_expr_ != nullptr) {
    child_nodes->emplace_back(where_expr_.get());
  }
}

void ResolvedTruncateStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (table_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &table_scan_));
    static_assert(sizeof(table_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (where_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &where_expr_));
    static_assert(sizeof(where_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedTruncateStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedTruncateStmt(this);
}

absl::Status ResolvedTruncateStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_.get()->Accept(visitor));
  }
  if (where_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(where_expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedTruncateStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (table_scan_ != nullptr) {
    fields->emplace_back("table_scan", table_scan_.get());
  }
  if (where_expr_ != nullptr) {
    fields->emplace_back("where_expr", where_expr_.get());
  }
}

absl::Status ResolvedTruncateStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedTruncateStmt::table_scan not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedTruncateStmt::where_expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          table_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (where_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          where_expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedTruncateStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedTruncateStmt::table_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedTruncateStmt::where_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(table_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (where_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(where_expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedTruncateStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (table_scan_ != nullptr) table_scan_->ClearFieldsAccessed();
  if (where_expr_ != nullptr) where_expr_->ClearFieldsAccessed();
}

void ResolvedTruncateStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (table_scan_ != nullptr) table_scan_->MarkFieldsAccessed();
  if (where_expr_ != nullptr) where_expr_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedObjectUnit::TYPE;

ResolvedObjectUnit::~ResolvedObjectUnit() {
}

absl::Status ResolvedObjectUnit::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_object_unit_node());
}

absl::Status ResolvedObjectUnit::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedObjectUnitProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedObjectUnit>> ResolvedObjectUnit::RestoreFrom(
    const ResolvedObjectUnitProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::string> name_path;
  for (const auto& elem : proto.name_path()) {
    name_path.push_back(elem);
  }
  auto node = MakeResolvedObjectUnit(
      std::move(name_path));

  return node;
}

void ResolvedObjectUnit::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedObjectUnit::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedObjectUnit::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedObjectUnit(this);
}

absl::Status ResolvedObjectUnit::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedObjectUnit::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
}

absl::Status ResolvedObjectUnit::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedObjectUnit::name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedObjectUnit::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedObjectUnit::name_path is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedObjectUnit::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedObjectUnit::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedPrivilege::TYPE;

ResolvedPrivilege::~ResolvedPrivilege() {
}

absl::Status ResolvedPrivilege::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_privilege_node());
}

absl::Status ResolvedPrivilege::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedPrivilegeProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_action_type(action_type_);
  for (const auto& elem : unit_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_unit_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedPrivilege>> ResolvedPrivilege::RestoreFrom(
    const ResolvedPrivilegeProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string action_type =
      proto.action_type();
  std::vector<std::unique_ptr<const ResolvedObjectUnit>> unit_list;
  for (const auto& elem : proto.unit_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedObjectUnit> elem_restored,
                     ResolvedObjectUnit::RestoreFrom(elem, params));
    unit_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedPrivilege(
      std::move(action_type),
      std::move(unit_list));

  return node;
}

void ResolvedPrivilege::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : unit_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedPrivilege::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : unit_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedPrivilege::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedPrivilege(this);
}

absl::Status ResolvedPrivilege::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : unit_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedPrivilege::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("action_type", ToStringImpl(action_type_));
  }
  if (!unit_list_.empty()) {
    fields->emplace_back("unit_list", unit_list_);
  }
}

absl::Status ResolvedPrivilege::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedPrivilege::action_type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedPrivilege::unit_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : unit_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedPrivilege::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedPrivilege::action_type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedPrivilege::unit_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : unit_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedPrivilege::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : unit_list_) it->ClearFieldsAccessed();
}

void ResolvedPrivilege::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : unit_list_) it->MarkFieldsAccessed();
}

ResolvedGrantOrRevokeStmt::~ResolvedGrantOrRevokeStmt() {
}

absl::Status ResolvedGrantOrRevokeStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_grant_or_revoke_stmt_node());
}

absl::Status ResolvedGrantOrRevokeStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedGrantOrRevokeStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : privilege_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_privilege_list()));
  }
  proto->set_object_type(object_type_);
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  for (const auto& elem : grantee_list_) {
    proto->add_grantee_list(elem);
  }
  for (const auto& elem : grantee_expr_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_grantee_expr_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedGrantOrRevokeStmt>> ResolvedGrantOrRevokeStmt::RestoreFrom(
    const AnyResolvedGrantOrRevokeStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  switch (proto.node_case()) {
    case AnyResolvedGrantOrRevokeStmtProto::kResolvedGrantStmtNode:
      return ResolvedGrantStmt::RestoreFrom(
          proto.resolved_grant_stmt_node(), params);
    case AnyResolvedGrantOrRevokeStmtProto::kResolvedRevokeStmtNode:
      return ResolvedRevokeStmt::RestoreFrom(
          proto.resolved_revoke_stmt_node(), params);
  case AnyResolvedGrantOrRevokeStmtProto::NODE_NOT_SET:
    return ::zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
        << "No subnode types set in ResolvedGrantOrRevokeStmtProto";
  }
}

void ResolvedGrantOrRevokeStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : privilege_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : grantee_expr_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedGrantOrRevokeStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : privilege_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : grantee_expr_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedGrantOrRevokeStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedGrantOrRevokeStmt(this);
}

absl::Status ResolvedGrantOrRevokeStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : privilege_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : grantee_expr_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedGrantOrRevokeStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!privilege_list_.empty()) {
    fields->emplace_back("privilege_list", privilege_list_);
  }
  {
    fields->emplace_back("object_type", ToStringImpl(object_type_));
  }
  {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
  if (!IsDefaultValue(grantee_list_)) {
    fields->emplace_back("grantee_list", ToStringCommaSeparated(grantee_list_));
  }
  if (!grantee_expr_list_.empty()) {
    fields->emplace_back("grantee_expr_list", grantee_expr_list_);
  }
}

absl::Status ResolvedGrantOrRevokeStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGrantOrRevokeStmt::privilege_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGrantOrRevokeStmt::object_type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGrantOrRevokeStmt::name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(grantee_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGrantOrRevokeStmt::grantee_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(grantee_expr_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGrantOrRevokeStmt::grantee_expr_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : privilege_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    for (const auto& it : grantee_expr_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedGrantOrRevokeStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGrantOrRevokeStmt::privilege_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGrantOrRevokeStmt::object_type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGrantOrRevokeStmt::name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGrantOrRevokeStmt::grantee_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGrantOrRevokeStmt::grantee_expr_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : privilege_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    for (const auto& it : grantee_expr_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedGrantOrRevokeStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : privilege_list_) it->ClearFieldsAccessed();
  for (const auto& it : grantee_expr_list_) it->ClearFieldsAccessed();
}

void ResolvedGrantOrRevokeStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : privilege_list_) it->MarkFieldsAccessed();
  for (const auto& it : grantee_expr_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedGrantStmt::TYPE;

ResolvedGrantStmt::~ResolvedGrantStmt() {
}

absl::Status ResolvedGrantStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedGrantOrRevokeStmtProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_grant_stmt_node());
}

absl::Status ResolvedGrantStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedGrantStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedGrantStmt>> ResolvedGrantStmt::RestoreFrom(
    const ResolvedGrantStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedPrivilege>> privilege_list;
  for (const auto& elem : proto.parent().privilege_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedPrivilege> elem_restored,
                     ResolvedPrivilege::RestoreFrom(elem, params));
    privilege_list.push_back(std::move(elem_restored));
  }
  std::string object_type =
      proto.parent().object_type();
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::string> grantee_list;
  for (const auto& elem : proto.parent().grantee_list()) {
    grantee_list.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedExpr>> grantee_expr_list;
  for (const auto& elem : proto.parent().grantee_expr_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    grantee_expr_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedGrantStmt(
      std::move(privilege_list),
      std::move(object_type),
      std::move(name_path),
      std::move(grantee_list),
      std::move(grantee_expr_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

absl::Status ResolvedGrantStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedGrantStmt(this);
}

absl::Status ResolvedGrantStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

const ResolvedNodeKind ResolvedRevokeStmt::TYPE;

ResolvedRevokeStmt::~ResolvedRevokeStmt() {
}

absl::Status ResolvedRevokeStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedGrantOrRevokeStmtProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_revoke_stmt_node());
}

absl::Status ResolvedRevokeStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedRevokeStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedRevokeStmt>> ResolvedRevokeStmt::RestoreFrom(
    const ResolvedRevokeStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedPrivilege>> privilege_list;
  for (const auto& elem : proto.parent().privilege_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedPrivilege> elem_restored,
                     ResolvedPrivilege::RestoreFrom(elem, params));
    privilege_list.push_back(std::move(elem_restored));
  }
  std::string object_type =
      proto.parent().object_type();
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::string> grantee_list;
  for (const auto& elem : proto.parent().grantee_list()) {
    grantee_list.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedExpr>> grantee_expr_list;
  for (const auto& elem : proto.parent().grantee_expr_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    grantee_expr_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedRevokeStmt(
      std::move(privilege_list),
      std::move(object_type),
      std::move(name_path),
      std::move(grantee_list),
      std::move(grantee_expr_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

absl::Status ResolvedRevokeStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedRevokeStmt(this);
}

absl::Status ResolvedRevokeStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

ResolvedAlterObjectStmt::~ResolvedAlterObjectStmt() {
}

absl::Status ResolvedAlterObjectStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_object_stmt_node());
}

absl::Status ResolvedAlterObjectStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterObjectStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  for (const auto& elem : alter_action_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_alter_action_list()));
  }
  proto->set_is_if_exists(is_if_exists_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterObjectStmt>> ResolvedAlterObjectStmt::RestoreFrom(
    const AnyResolvedAlterObjectStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  switch (proto.node_case()) {
    case AnyResolvedAlterObjectStmtProto::kResolvedAlterRowAccessPolicyStmtNode:
      return ResolvedAlterRowAccessPolicyStmt::RestoreFrom(
          proto.resolved_alter_row_access_policy_stmt_node(), params);
    case AnyResolvedAlterObjectStmtProto::kResolvedAlterTableStmtNode:
      return ResolvedAlterTableStmt::RestoreFrom(
          proto.resolved_alter_table_stmt_node(), params);
    case AnyResolvedAlterObjectStmtProto::kResolvedAlterViewStmtNode:
      return ResolvedAlterViewStmt::RestoreFrom(
          proto.resolved_alter_view_stmt_node(), params);
    case AnyResolvedAlterObjectStmtProto::kResolvedAlterMaterializedViewStmtNode:
      return ResolvedAlterMaterializedViewStmt::RestoreFrom(
          proto.resolved_alter_materialized_view_stmt_node(), params);
    case AnyResolvedAlterObjectStmtProto::kResolvedAlterDatabaseStmtNode:
      return ResolvedAlterDatabaseStmt::RestoreFrom(
          proto.resolved_alter_database_stmt_node(), params);
    case AnyResolvedAlterObjectStmtProto::kResolvedAlterAllRowAccessPoliciesStmtNode:
      return ResolvedAlterAllRowAccessPoliciesStmt::RestoreFrom(
          proto.resolved_alter_all_row_access_policies_stmt_node(), params);
    case AnyResolvedAlterObjectStmtProto::kResolvedAlterEntityStmtNode:
      return ResolvedAlterEntityStmt::RestoreFrom(
          proto.resolved_alter_entity_stmt_node(), params);
    case AnyResolvedAlterObjectStmtProto::kResolvedAlterSchemaStmtNode:
      return ResolvedAlterSchemaStmt::RestoreFrom(
          proto.resolved_alter_schema_stmt_node(), params);
    case AnyResolvedAlterObjectStmtProto::kResolvedAlterPrivilegeRestrictionStmtNode:
      return ResolvedAlterPrivilegeRestrictionStmt::RestoreFrom(
          proto.resolved_alter_privilege_restriction_stmt_node(), params);
  case AnyResolvedAlterObjectStmtProto::NODE_NOT_SET:
    return ::zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
        << "No subnode types set in ResolvedAlterObjectStmtProto";
  }
}

void ResolvedAlterObjectStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : alter_action_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedAlterObjectStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : alter_action_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedAlterObjectStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterObjectStmt(this);
}

absl::Status ResolvedAlterObjectStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : alter_action_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAlterObjectStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(name_path_)) {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
  if (!alter_action_list_.empty()) {
    fields->emplace_back("alter_action_list", alter_action_list_);
  }
  if (!IsDefaultValue(is_if_exists_)) {
    fields->emplace_back("is_if_exists", ToStringImpl(is_if_exists_));
  }
}

absl::Status ResolvedAlterObjectStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(name_path_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAlterObjectStmt::name_path not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAlterObjectStmt::alter_action_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(is_if_exists_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAlterObjectStmt::is_if_exists not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : alter_action_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAlterObjectStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAlterObjectStmt::name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAlterObjectStmt::alter_action_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAlterObjectStmt::is_if_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : alter_action_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAlterObjectStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : alter_action_list_) it->ClearFieldsAccessed();
}

void ResolvedAlterObjectStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : alter_action_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAlterDatabaseStmt::TYPE;

ResolvedAlterDatabaseStmt::~ResolvedAlterDatabaseStmt() {
}

absl::Status ResolvedAlterDatabaseStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterObjectStmtProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_database_stmt_node());
}

absl::Status ResolvedAlterDatabaseStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterDatabaseStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterDatabaseStmt>> ResolvedAlterDatabaseStmt::RestoreFrom(
    const ResolvedAlterDatabaseStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedAlterAction>> alter_action_list;
  for (const auto& elem : proto.parent().alter_action_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedAlterAction> elem_restored,
                     ResolvedAlterAction::RestoreFrom(elem, params));
    alter_action_list.push_back(std::move(elem_restored));
  }
  bool is_if_exists =
      proto.parent().is_if_exists();
  auto node = MakeResolvedAlterDatabaseStmt(
      std::move(name_path),
      std::move(alter_action_list),
      std::move(is_if_exists));

  node->set_hint_list(std::move(hint_list));
  return node;
}

absl::Status ResolvedAlterDatabaseStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterDatabaseStmt(this);
}

absl::Status ResolvedAlterDatabaseStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

const ResolvedNodeKind ResolvedAlterMaterializedViewStmt::TYPE;

ResolvedAlterMaterializedViewStmt::~ResolvedAlterMaterializedViewStmt() {
}

absl::Status ResolvedAlterMaterializedViewStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterObjectStmtProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_materialized_view_stmt_node());
}

absl::Status ResolvedAlterMaterializedViewStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterMaterializedViewStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterMaterializedViewStmt>> ResolvedAlterMaterializedViewStmt::RestoreFrom(
    const ResolvedAlterMaterializedViewStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedAlterAction>> alter_action_list;
  for (const auto& elem : proto.parent().alter_action_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedAlterAction> elem_restored,
                     ResolvedAlterAction::RestoreFrom(elem, params));
    alter_action_list.push_back(std::move(elem_restored));
  }
  bool is_if_exists =
      proto.parent().is_if_exists();
  auto node = MakeResolvedAlterMaterializedViewStmt(
      std::move(name_path),
      std::move(alter_action_list),
      std::move(is_if_exists));

  node->set_hint_list(std::move(hint_list));
  return node;
}

absl::Status ResolvedAlterMaterializedViewStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterMaterializedViewStmt(this);
}

absl::Status ResolvedAlterMaterializedViewStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

const ResolvedNodeKind ResolvedAlterSchemaStmt::TYPE;

ResolvedAlterSchemaStmt::~ResolvedAlterSchemaStmt() {
}

absl::Status ResolvedAlterSchemaStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterObjectStmtProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_schema_stmt_node());
}

absl::Status ResolvedAlterSchemaStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterSchemaStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterSchemaStmt>> ResolvedAlterSchemaStmt::RestoreFrom(
    const ResolvedAlterSchemaStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedAlterAction>> alter_action_list;
  for (const auto& elem : proto.parent().alter_action_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedAlterAction> elem_restored,
                     ResolvedAlterAction::RestoreFrom(elem, params));
    alter_action_list.push_back(std::move(elem_restored));
  }
  bool is_if_exists =
      proto.parent().is_if_exists();
  auto node = MakeResolvedAlterSchemaStmt(
      std::move(name_path),
      std::move(alter_action_list),
      std::move(is_if_exists));

  node->set_hint_list(std::move(hint_list));
  return node;
}

absl::Status ResolvedAlterSchemaStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterSchemaStmt(this);
}

absl::Status ResolvedAlterSchemaStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

const ResolvedNodeKind ResolvedAlterTableStmt::TYPE;

ResolvedAlterTableStmt::~ResolvedAlterTableStmt() {
}

absl::Status ResolvedAlterTableStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterObjectStmtProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_table_stmt_node());
}

absl::Status ResolvedAlterTableStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterTableStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterTableStmt>> ResolvedAlterTableStmt::RestoreFrom(
    const ResolvedAlterTableStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedAlterAction>> alter_action_list;
  for (const auto& elem : proto.parent().alter_action_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedAlterAction> elem_restored,
                     ResolvedAlterAction::RestoreFrom(elem, params));
    alter_action_list.push_back(std::move(elem_restored));
  }
  bool is_if_exists =
      proto.parent().is_if_exists();
  auto node = MakeResolvedAlterTableStmt(
      std::move(name_path),
      std::move(alter_action_list),
      std::move(is_if_exists));

  node->set_hint_list(std::move(hint_list));
  return node;
}

absl::Status ResolvedAlterTableStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterTableStmt(this);
}

absl::Status ResolvedAlterTableStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

const ResolvedNodeKind ResolvedAlterViewStmt::TYPE;

ResolvedAlterViewStmt::~ResolvedAlterViewStmt() {
}

absl::Status ResolvedAlterViewStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterObjectStmtProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_view_stmt_node());
}

absl::Status ResolvedAlterViewStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterViewStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterViewStmt>> ResolvedAlterViewStmt::RestoreFrom(
    const ResolvedAlterViewStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedAlterAction>> alter_action_list;
  for (const auto& elem : proto.parent().alter_action_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedAlterAction> elem_restored,
                     ResolvedAlterAction::RestoreFrom(elem, params));
    alter_action_list.push_back(std::move(elem_restored));
  }
  bool is_if_exists =
      proto.parent().is_if_exists();
  auto node = MakeResolvedAlterViewStmt(
      std::move(name_path),
      std::move(alter_action_list),
      std::move(is_if_exists));

  node->set_hint_list(std::move(hint_list));
  return node;
}

absl::Status ResolvedAlterViewStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterViewStmt(this);
}

absl::Status ResolvedAlterViewStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

ResolvedAlterAction::~ResolvedAlterAction() {
}

absl::Status ResolvedAlterAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_action_node());
}

absl::Status ResolvedAlterAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterAction>> ResolvedAlterAction::RestoreFrom(
    const AnyResolvedAlterActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  switch (proto.node_case()) {
    case AnyResolvedAlterActionProto::kResolvedSetOptionsActionNode:
      return ResolvedSetOptionsAction::RestoreFrom(
          proto.resolved_set_options_action_node(), params);
    case AnyResolvedAlterActionProto::kResolvedAddColumnActionNode:
      return ResolvedAddColumnAction::RestoreFrom(
          proto.resolved_add_column_action_node(), params);
    case AnyResolvedAlterActionProto::kResolvedDropColumnActionNode:
      return ResolvedDropColumnAction::RestoreFrom(
          proto.resolved_drop_column_action_node(), params);
    case AnyResolvedAlterActionProto::kResolvedGrantToActionNode:
      return ResolvedGrantToAction::RestoreFrom(
          proto.resolved_grant_to_action_node(), params);
    case AnyResolvedAlterActionProto::kResolvedFilterUsingActionNode:
      return ResolvedFilterUsingAction::RestoreFrom(
          proto.resolved_filter_using_action_node(), params);
    case AnyResolvedAlterActionProto::kResolvedRevokeFromActionNode:
      return ResolvedRevokeFromAction::RestoreFrom(
          proto.resolved_revoke_from_action_node(), params);
    case AnyResolvedAlterActionProto::kResolvedRenameToActionNode:
      return ResolvedRenameToAction::RestoreFrom(
          proto.resolved_rename_to_action_node(), params);
    case AnyResolvedAlterActionProto::kResolvedSetAsActionNode:
      return ResolvedSetAsAction::RestoreFrom(
          proto.resolved_set_as_action_node(), params);
    case AnyResolvedAlterActionProto::kResolvedAddConstraintActionNode:
      return ResolvedAddConstraintAction::RestoreFrom(
          proto.resolved_add_constraint_action_node(), params);
    case AnyResolvedAlterActionProto::kResolvedDropConstraintActionNode:
      return ResolvedDropConstraintAction::RestoreFrom(
          proto.resolved_drop_constraint_action_node(), params);
    case AnyResolvedAlterActionProto::kResolvedDropPrimaryKeyActionNode:
      return ResolvedDropPrimaryKeyAction::RestoreFrom(
          proto.resolved_drop_primary_key_action_node(), params);
    case AnyResolvedAlterActionProto::kResolvedRenameColumnActionNode:
      return ResolvedRenameColumnAction::RestoreFrom(
          proto.resolved_rename_column_action_node(), params);
    case AnyResolvedAlterActionProto::kResolvedSetCollateClauseNode:
      return ResolvedSetCollateClause::RestoreFrom(
          proto.resolved_set_collate_clause_node(), params);
    case AnyResolvedAlterActionProto::kResolvedRestrictToActionNode:
      return ResolvedRestrictToAction::RestoreFrom(
          proto.resolved_restrict_to_action_node(), params);
    case AnyResolvedAlterActionProto::kResolvedAddToRestricteeListActionNode:
      return ResolvedAddToRestricteeListAction::RestoreFrom(
          proto.resolved_add_to_restrictee_list_action_node(), params);
    case AnyResolvedAlterActionProto::kResolvedRemoveFromRestricteeListActionNode:
      return ResolvedRemoveFromRestricteeListAction::RestoreFrom(
          proto.resolved_remove_from_restrictee_list_action_node(), params);
    case AnyResolvedAlterActionProto::kResolvedAlterColumnActionNode:
      return ResolvedAlterColumnAction::RestoreFrom(
          proto.resolved_alter_column_action_node(), params);
  case AnyResolvedAlterActionProto::NODE_NOT_SET:
    return ::zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
        << "No subnode types set in ResolvedAlterActionProto";
  }
}

absl::Status ResolvedAlterAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterAction(this);
}

absl::Status ResolvedAlterAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

ResolvedAlterColumnAction::~ResolvedAlterColumnAction() {
}

absl::Status ResolvedAlterColumnAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_column_action_node());
}

absl::Status ResolvedAlterColumnAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterColumnActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_is_if_exists(is_if_exists_);
  proto->set_column(column_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterColumnAction>> ResolvedAlterColumnAction::RestoreFrom(
    const AnyResolvedAlterColumnActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  switch (proto.node_case()) {
    case AnyResolvedAlterColumnActionProto::kResolvedAlterColumnOptionsActionNode:
      return ResolvedAlterColumnOptionsAction::RestoreFrom(
          proto.resolved_alter_column_options_action_node(), params);
    case AnyResolvedAlterColumnActionProto::kResolvedAlterColumnDropNotNullActionNode:
      return ResolvedAlterColumnDropNotNullAction::RestoreFrom(
          proto.resolved_alter_column_drop_not_null_action_node(), params);
    case AnyResolvedAlterColumnActionProto::kResolvedAlterColumnSetDataTypeActionNode:
      return ResolvedAlterColumnSetDataTypeAction::RestoreFrom(
          proto.resolved_alter_column_set_data_type_action_node(), params);
    case AnyResolvedAlterColumnActionProto::kResolvedAlterColumnSetDefaultActionNode:
      return ResolvedAlterColumnSetDefaultAction::RestoreFrom(
          proto.resolved_alter_column_set_default_action_node(), params);
    case AnyResolvedAlterColumnActionProto::kResolvedAlterColumnDropDefaultActionNode:
      return ResolvedAlterColumnDropDefaultAction::RestoreFrom(
          proto.resolved_alter_column_drop_default_action_node(), params);
  case AnyResolvedAlterColumnActionProto::NODE_NOT_SET:
    return ::zetasql_base::InvalidArgumentErrorBuilder(ZETASQL_LOC)
        << "No subnode types set in ResolvedAlterColumnActionProto";
  }
}

void ResolvedAlterColumnAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedAlterColumnAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedAlterColumnAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterColumnAction(this);
}

absl::Status ResolvedAlterColumnAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedAlterColumnAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(is_if_exists_)) {
    fields->emplace_back("is_if_exists", ToStringImpl(is_if_exists_));
  }
  {
    fields->emplace_back("column", ToStringImpl(column_));
  }
}

absl::Status ResolvedAlterColumnAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(is_if_exists_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAlterColumnAction::is_if_exists not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAlterColumnAction::column not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedAlterColumnAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAlterColumnAction::is_if_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAlterColumnAction::column is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedAlterColumnAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedAlterColumnAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedSetOptionsAction::TYPE;

ResolvedSetOptionsAction::~ResolvedSetOptionsAction() {
}

absl::Status ResolvedSetOptionsAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_set_options_action_node());
}

absl::Status ResolvedSetOptionsAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedSetOptionsActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedSetOptionsAction>> ResolvedSetOptionsAction::RestoreFrom(
    const ResolvedSetOptionsActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedSetOptionsAction(
      std::move(option_list));

  return node;
}

void ResolvedSetOptionsAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedSetOptionsAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedSetOptionsAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedSetOptionsAction(this);
}

absl::Status ResolvedSetOptionsAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedSetOptionsAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
}

absl::Status ResolvedSetOptionsAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSetOptionsAction::option_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedSetOptionsAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSetOptionsAction::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedSetOptionsAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
}

void ResolvedSetOptionsAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAddColumnAction::TYPE;

ResolvedAddColumnAction::~ResolvedAddColumnAction() {
}

absl::Status ResolvedAddColumnAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_add_column_action_node());
}

absl::Status ResolvedAddColumnAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAddColumnActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_is_if_not_exists(is_if_not_exists_);
  if (column_definition_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(column_definition_->SaveTo(
        file_descriptor_set_map, proto->mutable_column_definition()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAddColumnAction>> ResolvedAddColumnAction::RestoreFrom(
    const ResolvedAddColumnActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool is_if_not_exists =
      proto.is_if_not_exists();
  std::unique_ptr<const ResolvedColumnDefinition> column_definition;
  if (proto.
  has_column_definition()) {
    ZETASQL_ASSIGN_OR_RETURN(column_definition,
                     ResolvedColumnDefinition::RestoreFrom(
                         proto.column_definition(), params));
  }
  auto node = MakeResolvedAddColumnAction(
      std::move(is_if_not_exists),
      std::move(column_definition));

  return node;
}

void ResolvedAddColumnAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (column_definition_ != nullptr) {
    child_nodes->emplace_back(column_definition_.get());
  }
}

void ResolvedAddColumnAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (column_definition_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &column_definition_));
    static_assert(sizeof(column_definition_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedAddColumnAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAddColumnAction(this);
}

absl::Status ResolvedAddColumnAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (column_definition_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(column_definition_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAddColumnAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("is_if_not_exists", ToStringImpl(is_if_not_exists_));
  }
  if (column_definition_ != nullptr) {
    fields->emplace_back("column_definition", column_definition_.get());
  }
}

absl::Status ResolvedAddColumnAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAddColumnAction::is_if_not_exists not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAddColumnAction::column_definition not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (column_definition_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          column_definition_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAddColumnAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAddColumnAction::is_if_not_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAddColumnAction::column_definition is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (column_definition_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(column_definition_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAddColumnAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (column_definition_ != nullptr) column_definition_->ClearFieldsAccessed();
}

void ResolvedAddColumnAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (column_definition_ != nullptr) column_definition_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAddConstraintAction::TYPE;

ResolvedAddConstraintAction::~ResolvedAddConstraintAction() {
}

absl::Status ResolvedAddConstraintAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_add_constraint_action_node());
}

absl::Status ResolvedAddConstraintAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAddConstraintActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_is_if_not_exists(is_if_not_exists_);
  if (constraint_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(constraint_->SaveTo(
        file_descriptor_set_map, proto->mutable_constraint()));
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      table_, file_descriptor_set_map,
      proto->mutable_table()));
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAddConstraintAction>> ResolvedAddConstraintAction::RestoreFrom(
    const ResolvedAddConstraintActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool is_if_not_exists =
      proto.is_if_not_exists();
  std::unique_ptr<const ResolvedConstraint> constraint;
  if (proto.
  has_constraint()) {
    ZETASQL_ASSIGN_OR_RETURN(constraint,
                     ResolvedConstraint::RestoreFrom(
                         proto.constraint(), params));
  }
  ZETASQL_ASSIGN_OR_RETURN(auto table,
                   RestoreFromImpl<const Table*>(
                       proto.table(),
                       params));
  auto node = MakeResolvedAddConstraintAction(
      std::move(is_if_not_exists),
      std::move(constraint),
      std::move(table));

  return node;
}

void ResolvedAddConstraintAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (constraint_ != nullptr) {
    child_nodes->emplace_back(constraint_.get());
  }
}

void ResolvedAddConstraintAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (constraint_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &constraint_));
    static_assert(sizeof(constraint_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedAddConstraintAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAddConstraintAction(this);
}

absl::Status ResolvedAddConstraintAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (constraint_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(constraint_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAddConstraintAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("is_if_not_exists", ToStringImpl(is_if_not_exists_));
  }
  if (constraint_ != nullptr) {
    fields->emplace_back("constraint", constraint_.get());
  }
  if (!IsDefaultValue(table_)) {
    fields->emplace_back("table", ToStringImpl(table_));
  }
}

absl::Status ResolvedAddConstraintAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAddConstraintAction::is_if_not_exists not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAddConstraintAction::constraint not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(table_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAddConstraintAction::table not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (constraint_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          constraint_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAddConstraintAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAddConstraintAction::is_if_not_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAddConstraintAction::constraint is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAddConstraintAction::table is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (constraint_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(constraint_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAddConstraintAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (constraint_ != nullptr) constraint_->ClearFieldsAccessed();
}

void ResolvedAddConstraintAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (constraint_ != nullptr) constraint_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedDropConstraintAction::TYPE;

ResolvedDropConstraintAction::~ResolvedDropConstraintAction() {
}

absl::Status ResolvedDropConstraintAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_drop_constraint_action_node());
}

absl::Status ResolvedDropConstraintAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedDropConstraintActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_is_if_exists(is_if_exists_);
  proto->set_name(name_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedDropConstraintAction>> ResolvedDropConstraintAction::RestoreFrom(
    const ResolvedDropConstraintActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool is_if_exists =
      proto.is_if_exists();
  std::string name =
      proto.name();
  auto node = MakeResolvedDropConstraintAction(
      std::move(is_if_exists),
      std::move(name));

  return node;
}

void ResolvedDropConstraintAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedDropConstraintAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedDropConstraintAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedDropConstraintAction(this);
}

absl::Status ResolvedDropConstraintAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedDropConstraintAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("is_if_exists", ToStringImpl(is_if_exists_));
  }
  {
    fields->emplace_back("name", ToStringImpl(name_));
  }
}

absl::Status ResolvedDropConstraintAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropConstraintAction::is_if_exists not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropConstraintAction::name not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedDropConstraintAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropConstraintAction::is_if_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropConstraintAction::name is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedDropConstraintAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedDropConstraintAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedDropPrimaryKeyAction::TYPE;

ResolvedDropPrimaryKeyAction::~ResolvedDropPrimaryKeyAction() {
}

absl::Status ResolvedDropPrimaryKeyAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_drop_primary_key_action_node());
}

absl::Status ResolvedDropPrimaryKeyAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedDropPrimaryKeyActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_is_if_exists(is_if_exists_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedDropPrimaryKeyAction>> ResolvedDropPrimaryKeyAction::RestoreFrom(
    const ResolvedDropPrimaryKeyActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool is_if_exists =
      proto.is_if_exists();
  auto node = MakeResolvedDropPrimaryKeyAction(
      std::move(is_if_exists));

  return node;
}

void ResolvedDropPrimaryKeyAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedDropPrimaryKeyAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedDropPrimaryKeyAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedDropPrimaryKeyAction(this);
}

absl::Status ResolvedDropPrimaryKeyAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedDropPrimaryKeyAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("is_if_exists", ToStringImpl(is_if_exists_));
  }
}

absl::Status ResolvedDropPrimaryKeyAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropPrimaryKeyAction::is_if_exists not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedDropPrimaryKeyAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropPrimaryKeyAction::is_if_exists is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedDropPrimaryKeyAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedDropPrimaryKeyAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedAlterColumnOptionsAction::TYPE;

ResolvedAlterColumnOptionsAction::~ResolvedAlterColumnOptionsAction() {
}

absl::Status ResolvedAlterColumnOptionsAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterColumnActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_column_options_action_node());
}

absl::Status ResolvedAlterColumnOptionsAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterColumnOptionsActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterColumnOptionsAction>> ResolvedAlterColumnOptionsAction::RestoreFrom(
    const ResolvedAlterColumnOptionsActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  bool is_if_exists =
      proto.parent().is_if_exists();
  std::string column =
      proto.parent().column();
  auto node = MakeResolvedAlterColumnOptionsAction(
      std::move(is_if_exists),
      std::move(column),
      std::move(option_list));

  return node;
}

void ResolvedAlterColumnOptionsAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedAlterColumnOptionsAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedAlterColumnOptionsAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterColumnOptionsAction(this);
}

absl::Status ResolvedAlterColumnOptionsAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAlterColumnOptionsAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
}

absl::Status ResolvedAlterColumnOptionsAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAlterColumnOptionsAction::option_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAlterColumnOptionsAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAlterColumnOptionsAction::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAlterColumnOptionsAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
}

void ResolvedAlterColumnOptionsAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAlterColumnDropNotNullAction::TYPE;

ResolvedAlterColumnDropNotNullAction::~ResolvedAlterColumnDropNotNullAction() {
}

absl::Status ResolvedAlterColumnDropNotNullAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterColumnActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_column_drop_not_null_action_node());
}

absl::Status ResolvedAlterColumnDropNotNullAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterColumnDropNotNullActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterColumnDropNotNullAction>> ResolvedAlterColumnDropNotNullAction::RestoreFrom(
    const ResolvedAlterColumnDropNotNullActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool is_if_exists =
      proto.parent().is_if_exists();
  std::string column =
      proto.parent().column();
  auto node = MakeResolvedAlterColumnDropNotNullAction(
      std::move(is_if_exists),
      std::move(column));

  return node;
}

absl::Status ResolvedAlterColumnDropNotNullAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterColumnDropNotNullAction(this);
}

absl::Status ResolvedAlterColumnDropNotNullAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

const ResolvedNodeKind ResolvedAlterColumnSetDataTypeAction::TYPE;

ResolvedAlterColumnSetDataTypeAction::~ResolvedAlterColumnSetDataTypeAction() {
}

absl::Status ResolvedAlterColumnSetDataTypeAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterColumnActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_column_set_data_type_action_node());
}

absl::Status ResolvedAlterColumnSetDataTypeAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterColumnSetDataTypeActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      updated_type_, file_descriptor_set_map,
      proto->mutable_updated_type()));
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      updated_type_parameters_, file_descriptor_set_map,
      proto->mutable_updated_type_parameters()));
  if (updated_annotations_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(updated_annotations_->SaveTo(
        file_descriptor_set_map, proto->mutable_updated_annotations()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterColumnSetDataTypeAction>> ResolvedAlterColumnSetDataTypeAction::RestoreFrom(
    const ResolvedAlterColumnSetDataTypeActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto updated_type,
                   RestoreFromImpl<const Type*>(
                       proto.updated_type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto updated_type_parameters,
                   RestoreFromImpl<TypeParameters>(
                       proto.updated_type_parameters(),
                       params));
  std::unique_ptr<const ResolvedColumnAnnotations> updated_annotations;
  if (proto.
  has_updated_annotations()) {
    ZETASQL_ASSIGN_OR_RETURN(updated_annotations,
                     ResolvedColumnAnnotations::RestoreFrom(
                         proto.updated_annotations(), params));
  }
  bool is_if_exists =
      proto.parent().is_if_exists();
  std::string column =
      proto.parent().column();
  auto node = MakeResolvedAlterColumnSetDataTypeAction(
      std::move(is_if_exists),
      std::move(column),
      std::move(updated_type),
      std::move(updated_type_parameters),
      std::move(updated_annotations));

  return node;
}

void ResolvedAlterColumnSetDataTypeAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (updated_annotations_ != nullptr) {
    child_nodes->emplace_back(updated_annotations_.get());
  }
}

void ResolvedAlterColumnSetDataTypeAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (updated_annotations_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &updated_annotations_));
    static_assert(sizeof(updated_annotations_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedAlterColumnSetDataTypeAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterColumnSetDataTypeAction(this);
}

absl::Status ResolvedAlterColumnSetDataTypeAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (updated_annotations_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(updated_annotations_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAlterColumnSetDataTypeAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("updated_type", ToStringImpl(updated_type_));
  }
  if (!IsDefaultValue(updated_type_parameters_)) {
    fields->emplace_back("updated_type_parameters", ToStringImpl(updated_type_parameters_));
  }
  if (updated_annotations_ != nullptr) {
    fields->emplace_back("updated_annotations", updated_annotations_.get());
  }
}

absl::Status ResolvedAlterColumnSetDataTypeAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAlterColumnSetDataTypeAction::updated_type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(updated_type_parameters_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAlterColumnSetDataTypeAction::updated_type_parameters not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (updated_annotations_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          updated_annotations_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAlterColumnSetDataTypeAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAlterColumnSetDataTypeAction::updated_type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAlterColumnSetDataTypeAction::updated_type_parameters is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (updated_annotations_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(updated_annotations_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAlterColumnSetDataTypeAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (updated_annotations_ != nullptr) updated_annotations_->ClearFieldsAccessed();
}

void ResolvedAlterColumnSetDataTypeAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (updated_annotations_ != nullptr) updated_annotations_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAlterColumnSetDefaultAction::TYPE;

ResolvedAlterColumnSetDefaultAction::~ResolvedAlterColumnSetDefaultAction() {
}

absl::Status ResolvedAlterColumnSetDefaultAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterColumnActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_column_set_default_action_node());
}

absl::Status ResolvedAlterColumnSetDefaultAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterColumnSetDefaultActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (default_value_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(default_value_->SaveTo(
        file_descriptor_set_map, proto->mutable_default_value()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterColumnSetDefaultAction>> ResolvedAlterColumnSetDefaultAction::RestoreFrom(
    const ResolvedAlterColumnSetDefaultActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedColumnDefaultValue> default_value;
  if (proto.
  has_default_value()) {
    ZETASQL_ASSIGN_OR_RETURN(default_value,
                     ResolvedColumnDefaultValue::RestoreFrom(
                         proto.default_value(), params));
  }
  bool is_if_exists =
      proto.parent().is_if_exists();
  std::string column =
      proto.parent().column();
  auto node = MakeResolvedAlterColumnSetDefaultAction(
      std::move(is_if_exists),
      std::move(column),
      std::move(default_value));

  return node;
}

void ResolvedAlterColumnSetDefaultAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (default_value_ != nullptr) {
    child_nodes->emplace_back(default_value_.get());
  }
}

void ResolvedAlterColumnSetDefaultAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (default_value_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &default_value_));
    static_assert(sizeof(default_value_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedAlterColumnSetDefaultAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterColumnSetDefaultAction(this);
}

absl::Status ResolvedAlterColumnSetDefaultAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (default_value_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(default_value_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAlterColumnSetDefaultAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (default_value_ != nullptr) {
    fields->emplace_back("default_value", default_value_.get());
  }
}

absl::Status ResolvedAlterColumnSetDefaultAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAlterColumnSetDefaultAction::default_value not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (default_value_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          default_value_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAlterColumnSetDefaultAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAlterColumnSetDefaultAction::default_value is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (default_value_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(default_value_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAlterColumnSetDefaultAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (default_value_ != nullptr) default_value_->ClearFieldsAccessed();
}

void ResolvedAlterColumnSetDefaultAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (default_value_ != nullptr) default_value_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAlterColumnDropDefaultAction::TYPE;

ResolvedAlterColumnDropDefaultAction::~ResolvedAlterColumnDropDefaultAction() {
}

absl::Status ResolvedAlterColumnDropDefaultAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterColumnActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_column_drop_default_action_node());
}

absl::Status ResolvedAlterColumnDropDefaultAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterColumnDropDefaultActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterColumnDropDefaultAction>> ResolvedAlterColumnDropDefaultAction::RestoreFrom(
    const ResolvedAlterColumnDropDefaultActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool is_if_exists =
      proto.parent().is_if_exists();
  std::string column =
      proto.parent().column();
  auto node = MakeResolvedAlterColumnDropDefaultAction(
      std::move(is_if_exists),
      std::move(column));

  return node;
}

absl::Status ResolvedAlterColumnDropDefaultAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterColumnDropDefaultAction(this);
}

absl::Status ResolvedAlterColumnDropDefaultAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

const ResolvedNodeKind ResolvedDropColumnAction::TYPE;

ResolvedDropColumnAction::~ResolvedDropColumnAction() {
}

absl::Status ResolvedDropColumnAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_drop_column_action_node());
}

absl::Status ResolvedDropColumnAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedDropColumnActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_is_if_exists(is_if_exists_);
  proto->set_name(name_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedDropColumnAction>> ResolvedDropColumnAction::RestoreFrom(
    const ResolvedDropColumnActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool is_if_exists =
      proto.is_if_exists();
  std::string name =
      proto.name();
  auto node = MakeResolvedDropColumnAction(
      std::move(is_if_exists),
      std::move(name));

  return node;
}

void ResolvedDropColumnAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedDropColumnAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedDropColumnAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedDropColumnAction(this);
}

absl::Status ResolvedDropColumnAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedDropColumnAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("is_if_exists", ToStringImpl(is_if_exists_));
  }
  {
    fields->emplace_back("name", ToStringImpl(name_));
  }
}

absl::Status ResolvedDropColumnAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropColumnAction::is_if_exists not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropColumnAction::name not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedDropColumnAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropColumnAction::is_if_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropColumnAction::name is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedDropColumnAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedDropColumnAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedRenameColumnAction::TYPE;

ResolvedRenameColumnAction::~ResolvedRenameColumnAction() {
}

absl::Status ResolvedRenameColumnAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_rename_column_action_node());
}

absl::Status ResolvedRenameColumnAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedRenameColumnActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_is_if_exists(is_if_exists_);
  proto->set_name(name_);
  proto->set_new_name(new_name_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedRenameColumnAction>> ResolvedRenameColumnAction::RestoreFrom(
    const ResolvedRenameColumnActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool is_if_exists =
      proto.is_if_exists();
  std::string name =
      proto.name();
  std::string new_name =
      proto.new_name();
  auto node = MakeResolvedRenameColumnAction(
      std::move(is_if_exists),
      std::move(name),
      std::move(new_name));

  return node;
}

void ResolvedRenameColumnAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedRenameColumnAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedRenameColumnAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedRenameColumnAction(this);
}

absl::Status ResolvedRenameColumnAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedRenameColumnAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(is_if_exists_)) {
    fields->emplace_back("is_if_exists", ToStringImpl(is_if_exists_));
  }
  {
    fields->emplace_back("name", ToStringImpl(name_));
  }
  {
    fields->emplace_back("new_name", ToStringImpl(new_name_));
  }
}

absl::Status ResolvedRenameColumnAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(is_if_exists_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedRenameColumnAction::is_if_exists not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedRenameColumnAction::name not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedRenameColumnAction::new_name not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedRenameColumnAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedRenameColumnAction::is_if_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedRenameColumnAction::name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedRenameColumnAction::new_name is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedRenameColumnAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedRenameColumnAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedSetAsAction::TYPE;

ResolvedSetAsAction::~ResolvedSetAsAction() {
}

absl::Status ResolvedSetAsAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_set_as_action_node());
}

absl::Status ResolvedSetAsAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedSetAsActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_entity_body_json(entity_body_json_);
  proto->set_entity_body_text(entity_body_text_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedSetAsAction>> ResolvedSetAsAction::RestoreFrom(
    const ResolvedSetAsActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string entity_body_json =
      proto.entity_body_json();
  std::string entity_body_text =
      proto.entity_body_text();
  auto node = MakeResolvedSetAsAction(
      std::move(entity_body_json),
      std::move(entity_body_text));

  return node;
}

void ResolvedSetAsAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedSetAsAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedSetAsAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedSetAsAction(this);
}

absl::Status ResolvedSetAsAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedSetAsAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(entity_body_json_)) {
    fields->emplace_back("entity_body_json", ToStringImpl(entity_body_json_));
  }
  if (!IsDefaultValue(entity_body_text_)) {
    fields->emplace_back("entity_body_text", ToStringImpl(entity_body_text_));
  }
}

absl::Status ResolvedSetAsAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(entity_body_json_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSetAsAction::entity_body_json not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(entity_body_text_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSetAsAction::entity_body_text not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedSetAsAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSetAsAction::entity_body_json is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSetAsAction::entity_body_text is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedSetAsAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedSetAsAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedSetCollateClause::TYPE;

ResolvedSetCollateClause::~ResolvedSetCollateClause() {
}

absl::Status ResolvedSetCollateClause::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_set_collate_clause_node());
}

absl::Status ResolvedSetCollateClause::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedSetCollateClauseProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (collation_name_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(collation_name_->SaveTo(
        file_descriptor_set_map, proto->mutable_collation_name()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedSetCollateClause>> ResolvedSetCollateClause::RestoreFrom(
    const ResolvedSetCollateClauseProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> collation_name;
  if (proto.
  has_collation_name()) {
    ZETASQL_ASSIGN_OR_RETURN(collation_name,
                     ResolvedExpr::RestoreFrom(
                         proto.collation_name(), params));
  }
  auto node = MakeResolvedSetCollateClause(
      std::move(collation_name));

  return node;
}

void ResolvedSetCollateClause::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (collation_name_ != nullptr) {
    child_nodes->emplace_back(collation_name_.get());
  }
}

void ResolvedSetCollateClause::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (collation_name_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &collation_name_));
    static_assert(sizeof(collation_name_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedSetCollateClause::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedSetCollateClause(this);
}

absl::Status ResolvedSetCollateClause::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (collation_name_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(collation_name_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedSetCollateClause::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (collation_name_ != nullptr) {
    fields->emplace_back("collation_name", collation_name_.get());
  }
}

absl::Status ResolvedSetCollateClause::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedSetCollateClause::collation_name not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (collation_name_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          collation_name_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedSetCollateClause::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedSetCollateClause::collation_name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (collation_name_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(collation_name_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedSetCollateClause::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (collation_name_ != nullptr) collation_name_->ClearFieldsAccessed();
}

void ResolvedSetCollateClause::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (collation_name_ != nullptr) collation_name_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAlterTableSetOptionsStmt::TYPE;

ResolvedAlterTableSetOptionsStmt::~ResolvedAlterTableSetOptionsStmt() {
}

absl::Status ResolvedAlterTableSetOptionsStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_table_set_options_stmt_node());
}

absl::Status ResolvedAlterTableSetOptionsStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterTableSetOptionsStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  proto->set_is_if_exists(is_if_exists_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterTableSetOptionsStmt>> ResolvedAlterTableSetOptionsStmt::RestoreFrom(
    const ResolvedAlterTableSetOptionsStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::string> name_path;
  for (const auto& elem : proto.name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  bool is_if_exists =
      proto.is_if_exists();
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedAlterTableSetOptionsStmt(
      std::move(name_path),
      std::move(option_list),
      std::move(is_if_exists));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedAlterTableSetOptionsStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedAlterTableSetOptionsStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedAlterTableSetOptionsStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterTableSetOptionsStmt(this);
}

absl::Status ResolvedAlterTableSetOptionsStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAlterTableSetOptionsStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
  if (!IsDefaultValue(is_if_exists_)) {
    fields->emplace_back("is_if_exists", ToStringImpl(is_if_exists_));
  }
}

absl::Status ResolvedAlterTableSetOptionsStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAlterTableSetOptionsStmt::name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAlterTableSetOptionsStmt::option_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(is_if_exists_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAlterTableSetOptionsStmt::is_if_exists not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAlterTableSetOptionsStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAlterTableSetOptionsStmt::name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAlterTableSetOptionsStmt::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAlterTableSetOptionsStmt::is_if_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAlterTableSetOptionsStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
}

void ResolvedAlterTableSetOptionsStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedRenameStmt::TYPE;

ResolvedRenameStmt::~ResolvedRenameStmt() {
}

absl::Status ResolvedRenameStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_rename_stmt_node());
}

absl::Status ResolvedRenameStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedRenameStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_object_type(object_type_);
  for (const auto& elem : old_name_path_) {
    proto->add_old_name_path(elem);
  }
  for (const auto& elem : new_name_path_) {
    proto->add_new_name_path(elem);
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedRenameStmt>> ResolvedRenameStmt::RestoreFrom(
    const ResolvedRenameStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string object_type =
      proto.object_type();
  std::vector<std::string> old_name_path;
  for (const auto& elem : proto.old_name_path()) {
    old_name_path.push_back(elem);
  }
  std::vector<std::string> new_name_path;
  for (const auto& elem : proto.new_name_path()) {
    new_name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedRenameStmt(
      std::move(object_type),
      std::move(old_name_path),
      std::move(new_name_path));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedRenameStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedRenameStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedRenameStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedRenameStmt(this);
}

absl::Status ResolvedRenameStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedRenameStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("object_type", ToStringImpl(object_type_));
  }
  {
    fields->emplace_back("old_name_path", ToStringImpl(old_name_path_));
  }
  {
    fields->emplace_back("new_name_path", ToStringImpl(new_name_path_));
  }
}

absl::Status ResolvedRenameStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedRenameStmt::object_type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedRenameStmt::old_name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedRenameStmt::new_name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedRenameStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedRenameStmt::object_type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedRenameStmt::old_name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedRenameStmt::new_name_path is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedRenameStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedRenameStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedCreatePrivilegeRestrictionStmt::TYPE;

ResolvedCreatePrivilegeRestrictionStmt::~ResolvedCreatePrivilegeRestrictionStmt() {
}

absl::Status ResolvedCreatePrivilegeRestrictionStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedCreateStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_privilege_restriction_stmt_node());
}

absl::Status ResolvedCreatePrivilegeRestrictionStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreatePrivilegeRestrictionStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : column_privilege_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_column_privilege_list()));
  }
  proto->set_object_type(object_type_);
  for (const auto& elem : restrictee_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_restrictee_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreatePrivilegeRestrictionStmt>> ResolvedCreatePrivilegeRestrictionStmt::RestoreFrom(
    const ResolvedCreatePrivilegeRestrictionStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedPrivilege>> column_privilege_list;
  for (const auto& elem : proto.column_privilege_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedPrivilege> elem_restored,
                     ResolvedPrivilege::RestoreFrom(elem, params));
    column_privilege_list.push_back(std::move(elem_restored));
  }
  std::string object_type =
      proto.object_type();
  std::vector<std::unique_ptr<const ResolvedExpr>> restrictee_list;
  for (const auto& elem : proto.restrictee_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    restrictee_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  CreateScope create_scope =
      proto.parent().create_scope();
  CreateMode create_mode =
      proto.parent().create_mode();
  auto node = MakeResolvedCreatePrivilegeRestrictionStmt(
      std::move(name_path),
      std::move(create_scope),
      std::move(create_mode),
      std::move(column_privilege_list),
      std::move(object_type),
      std::move(restrictee_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCreatePrivilegeRestrictionStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : column_privilege_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : restrictee_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedCreatePrivilegeRestrictionStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : column_privilege_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : restrictee_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedCreatePrivilegeRestrictionStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreatePrivilegeRestrictionStmt(this);
}

absl::Status ResolvedCreatePrivilegeRestrictionStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : column_privilege_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : restrictee_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreatePrivilegeRestrictionStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!column_privilege_list_.empty()) {
    fields->emplace_back("column_privilege_list", column_privilege_list_);
  }
  {
    fields->emplace_back("object_type", ToStringImpl(object_type_));
  }
  if (!restrictee_list_.empty()) {
    fields->emplace_back("restrictee_list", restrictee_list_);
  }
}

absl::Status ResolvedCreatePrivilegeRestrictionStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreatePrivilegeRestrictionStmt::column_privilege_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreatePrivilegeRestrictionStmt::object_type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(restrictee_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreatePrivilegeRestrictionStmt::restrictee_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : column_privilege_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : restrictee_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreatePrivilegeRestrictionStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreatePrivilegeRestrictionStmt::column_privilege_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreatePrivilegeRestrictionStmt::object_type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreatePrivilegeRestrictionStmt::restrictee_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : column_privilege_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : restrictee_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreatePrivilegeRestrictionStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : column_privilege_list_) it->ClearFieldsAccessed();
  for (const auto& it : restrictee_list_) it->ClearFieldsAccessed();
}

void ResolvedCreatePrivilegeRestrictionStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : column_privilege_list_) it->MarkFieldsAccessed();
  for (const auto& it : restrictee_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCreateRowAccessPolicyStmt::TYPE;

ResolvedCreateRowAccessPolicyStmt::~ResolvedCreateRowAccessPolicyStmt() {
}

absl::Status ResolvedCreateRowAccessPolicyStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_row_access_policy_stmt_node());
}

absl::Status ResolvedCreateRowAccessPolicyStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateRowAccessPolicyStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_create_mode(create_mode_);
  proto->set_name(name_);
  for (const auto& elem : target_name_path_) {
    proto->add_target_name_path(elem);
  }
  for (const auto& elem : grantee_list_) {
    proto->add_grantee_list(elem);
  }
  for (const auto& elem : grantee_expr_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_grantee_expr_list()));
  }
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_table_scan()));
  }
  if (predicate_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(predicate_->SaveTo(
        file_descriptor_set_map, proto->mutable_predicate()));
  }
  proto->set_predicate_str(predicate_str_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateRowAccessPolicyStmt>> ResolvedCreateRowAccessPolicyStmt::RestoreFrom(
    const ResolvedCreateRowAccessPolicyStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  CreateMode create_mode =
      proto.create_mode();
  std::string name =
      proto.name();
  std::vector<std::string> target_name_path;
  for (const auto& elem : proto.target_name_path()) {
    target_name_path.push_back(elem);
  }
  std::vector<std::string> grantee_list;
  for (const auto& elem : proto.grantee_list()) {
    grantee_list.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedExpr>> grantee_expr_list;
  for (const auto& elem : proto.grantee_expr_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    grantee_expr_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedTableScan> table_scan;
  if (proto.
  has_table_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(table_scan,
                     ResolvedTableScan::RestoreFrom(
                         proto.table_scan(), params));
  }
  std::unique_ptr<const ResolvedExpr> predicate;
  if (proto.
  has_predicate()) {
    ZETASQL_ASSIGN_OR_RETURN(predicate,
                     ResolvedExpr::RestoreFrom(
                         proto.predicate(), params));
  }
  std::string predicate_str =
      proto.predicate_str();
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedCreateRowAccessPolicyStmt(
      std::move(create_mode),
      std::move(name),
      std::move(target_name_path),
      std::move(grantee_list),
      std::move(grantee_expr_list),
      std::move(table_scan),
      std::move(predicate),
      std::move(predicate_str));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCreateRowAccessPolicyStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : grantee_expr_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (table_scan_ != nullptr) {
    child_nodes->emplace_back(table_scan_.get());
  }
  if (predicate_ != nullptr) {
    child_nodes->emplace_back(predicate_.get());
  }
}

void ResolvedCreateRowAccessPolicyStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : grantee_expr_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (table_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &table_scan_));
    static_assert(sizeof(table_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (predicate_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &predicate_));
    static_assert(sizeof(predicate_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedCreateRowAccessPolicyStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateRowAccessPolicyStmt(this);
}

absl::Status ResolvedCreateRowAccessPolicyStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : grantee_expr_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_.get()->Accept(visitor));
  }
  if (predicate_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(predicate_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreateRowAccessPolicyStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(create_mode_)) {
    fields->emplace_back("create_mode", ToStringImpl(create_mode_));
  }
  if (!IsDefaultValue(name_)) {
    fields->emplace_back("name", ToStringImpl(name_));
  }
  {
    fields->emplace_back("target_name_path", ToStringImpl(target_name_path_));
  }
  if (!IsDefaultValue(grantee_list_)) {
    fields->emplace_back("grantee_list", ToStringCommaSeparated(grantee_list_));
  }
  if (!grantee_expr_list_.empty()) {
    fields->emplace_back("grantee_expr_list", grantee_expr_list_);
  }
  if (table_scan_ != nullptr) {
    fields->emplace_back("table_scan", table_scan_.get());
  }
  if (predicate_ != nullptr) {
    fields->emplace_back("predicate", predicate_.get());
  }
  if (!IsDefaultValue(predicate_str_)) {
    fields->emplace_back("predicate_str", ToStringImpl(predicate_str_));
  }
}

absl::Status ResolvedCreateRowAccessPolicyStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(create_mode_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateRowAccessPolicyStmt::create_mode not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(name_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateRowAccessPolicyStmt::name not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateRowAccessPolicyStmt::target_name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(grantee_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateRowAccessPolicyStmt::grantee_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(grantee_expr_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateRowAccessPolicyStmt::grantee_expr_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) != 0) {
    for (const auto& it : grantee_expr_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          table_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    if (predicate_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          predicate_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateRowAccessPolicyStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateRowAccessPolicyStmt::create_mode is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateRowAccessPolicyStmt::name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateRowAccessPolicyStmt::target_name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateRowAccessPolicyStmt::grantee_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateRowAccessPolicyStmt::grantee_expr_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0) {
    for (const auto& it : grantee_expr_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(table_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    if (predicate_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(predicate_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreateRowAccessPolicyStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : grantee_expr_list_) it->ClearFieldsAccessed();
  if (table_scan_ != nullptr) table_scan_->ClearFieldsAccessed();
  if (predicate_ != nullptr) predicate_->ClearFieldsAccessed();
}

void ResolvedCreateRowAccessPolicyStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : grantee_expr_list_) it->MarkFieldsAccessed();
  if (table_scan_ != nullptr) table_scan_->MarkFieldsAccessed();
  if (predicate_ != nullptr) predicate_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedDropPrivilegeRestrictionStmt::TYPE;

ResolvedDropPrivilegeRestrictionStmt::~ResolvedDropPrivilegeRestrictionStmt() {
}

absl::Status ResolvedDropPrivilegeRestrictionStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_drop_privilege_restriction_stmt_node());
}

absl::Status ResolvedDropPrivilegeRestrictionStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedDropPrivilegeRestrictionStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_object_type(object_type_);
  proto->set_is_if_exists(is_if_exists_);
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  for (const auto& elem : column_privilege_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_column_privilege_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedDropPrivilegeRestrictionStmt>> ResolvedDropPrivilegeRestrictionStmt::RestoreFrom(
    const ResolvedDropPrivilegeRestrictionStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string object_type =
      proto.object_type();
  bool is_if_exists =
      proto.is_if_exists();
  std::vector<std::string> name_path;
  for (const auto& elem : proto.name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedPrivilege>> column_privilege_list;
  for (const auto& elem : proto.column_privilege_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedPrivilege> elem_restored,
                     ResolvedPrivilege::RestoreFrom(elem, params));
    column_privilege_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedDropPrivilegeRestrictionStmt(
      std::move(object_type),
      std::move(is_if_exists),
      std::move(name_path),
      std::move(column_privilege_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedDropPrivilegeRestrictionStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : column_privilege_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedDropPrivilegeRestrictionStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : column_privilege_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedDropPrivilegeRestrictionStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedDropPrivilegeRestrictionStmt(this);
}

absl::Status ResolvedDropPrivilegeRestrictionStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : column_privilege_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedDropPrivilegeRestrictionStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("object_type", ToStringImpl(object_type_));
  }
  if (!IsDefaultValue(is_if_exists_)) {
    fields->emplace_back("is_if_exists", ToStringImpl(is_if_exists_));
  }
  {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
  if (!column_privilege_list_.empty()) {
    fields->emplace_back("column_privilege_list", column_privilege_list_);
  }
}

absl::Status ResolvedDropPrivilegeRestrictionStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropPrivilegeRestrictionStmt::object_type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(is_if_exists_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropPrivilegeRestrictionStmt::is_if_exists not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropPrivilegeRestrictionStmt::name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropPrivilegeRestrictionStmt::column_privilege_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : column_privilege_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedDropPrivilegeRestrictionStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropPrivilegeRestrictionStmt::object_type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropPrivilegeRestrictionStmt::is_if_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropPrivilegeRestrictionStmt::name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropPrivilegeRestrictionStmt::column_privilege_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : column_privilege_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedDropPrivilegeRestrictionStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : column_privilege_list_) it->ClearFieldsAccessed();
}

void ResolvedDropPrivilegeRestrictionStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : column_privilege_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedDropRowAccessPolicyStmt::TYPE;

ResolvedDropRowAccessPolicyStmt::~ResolvedDropRowAccessPolicyStmt() {
}

absl::Status ResolvedDropRowAccessPolicyStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_drop_row_access_policy_stmt_node());
}

absl::Status ResolvedDropRowAccessPolicyStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedDropRowAccessPolicyStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_is_drop_all(is_drop_all_);
  proto->set_is_if_exists(is_if_exists_);
  proto->set_name(name_);
  for (const auto& elem : target_name_path_) {
    proto->add_target_name_path(elem);
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedDropRowAccessPolicyStmt>> ResolvedDropRowAccessPolicyStmt::RestoreFrom(
    const ResolvedDropRowAccessPolicyStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool is_drop_all =
      proto.is_drop_all();
  bool is_if_exists =
      proto.is_if_exists();
  std::string name =
      proto.name();
  std::vector<std::string> target_name_path;
  for (const auto& elem : proto.target_name_path()) {
    target_name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedDropRowAccessPolicyStmt(
      std::move(is_drop_all),
      std::move(is_if_exists),
      std::move(name),
      std::move(target_name_path));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedDropRowAccessPolicyStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedDropRowAccessPolicyStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedDropRowAccessPolicyStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedDropRowAccessPolicyStmt(this);
}

absl::Status ResolvedDropRowAccessPolicyStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedDropRowAccessPolicyStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(is_drop_all_)) {
    fields->emplace_back("is_drop_all", ToStringImpl(is_drop_all_));
  }
  if (!IsDefaultValue(is_if_exists_)) {
    fields->emplace_back("is_if_exists", ToStringImpl(is_if_exists_));
  }
  if (!IsDefaultValue(name_)) {
    fields->emplace_back("name", ToStringImpl(name_));
  }
  {
    fields->emplace_back("target_name_path", ToStringImpl(target_name_path_));
  }
}

absl::Status ResolvedDropRowAccessPolicyStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(is_drop_all_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropRowAccessPolicyStmt::is_drop_all not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(is_if_exists_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropRowAccessPolicyStmt::is_if_exists not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(name_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropRowAccessPolicyStmt::name not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropRowAccessPolicyStmt::target_name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedDropRowAccessPolicyStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropRowAccessPolicyStmt::is_drop_all is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropRowAccessPolicyStmt::is_if_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropRowAccessPolicyStmt::name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropRowAccessPolicyStmt::target_name_path is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedDropRowAccessPolicyStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedDropRowAccessPolicyStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedDropSearchIndexStmt::TYPE;

ResolvedDropSearchIndexStmt::~ResolvedDropSearchIndexStmt() {
}

absl::Status ResolvedDropSearchIndexStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_drop_search_index_stmt_node());
}

absl::Status ResolvedDropSearchIndexStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedDropSearchIndexStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_is_if_exists(is_if_exists_);
  proto->set_name(name_);
  for (const auto& elem : table_name_path_) {
    proto->add_table_name_path(elem);
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedDropSearchIndexStmt>> ResolvedDropSearchIndexStmt::RestoreFrom(
    const ResolvedDropSearchIndexStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool is_if_exists =
      proto.is_if_exists();
  std::string name =
      proto.name();
  std::vector<std::string> table_name_path;
  for (const auto& elem : proto.table_name_path()) {
    table_name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedDropSearchIndexStmt(
      std::move(is_if_exists),
      std::move(name),
      std::move(table_name_path));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedDropSearchIndexStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedDropSearchIndexStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedDropSearchIndexStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedDropSearchIndexStmt(this);
}

absl::Status ResolvedDropSearchIndexStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedDropSearchIndexStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("is_if_exists", ToStringImpl(is_if_exists_));
  }
  {
    fields->emplace_back("name", ToStringImpl(name_));
  }
  {
    fields->emplace_back("table_name_path", ToStringImpl(table_name_path_));
  }
}

absl::Status ResolvedDropSearchIndexStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropSearchIndexStmt::is_if_exists not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropSearchIndexStmt::name not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropSearchIndexStmt::table_name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedDropSearchIndexStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropSearchIndexStmt::is_if_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropSearchIndexStmt::name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropSearchIndexStmt::table_name_path is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedDropSearchIndexStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedDropSearchIndexStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedGrantToAction::TYPE;

ResolvedGrantToAction::~ResolvedGrantToAction() {
}

absl::Status ResolvedGrantToAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_grant_to_action_node());
}

absl::Status ResolvedGrantToAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedGrantToActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : grantee_expr_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_grantee_expr_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedGrantToAction>> ResolvedGrantToAction::RestoreFrom(
    const ResolvedGrantToActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedExpr>> grantee_expr_list;
  for (const auto& elem : proto.grantee_expr_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    grantee_expr_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedGrantToAction(
      std::move(grantee_expr_list));

  return node;
}

void ResolvedGrantToAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : grantee_expr_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedGrantToAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : grantee_expr_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedGrantToAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedGrantToAction(this);
}

absl::Status ResolvedGrantToAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : grantee_expr_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedGrantToAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!grantee_expr_list_.empty()) {
    fields->emplace_back("grantee_expr_list", grantee_expr_list_);
  }
}

absl::Status ResolvedGrantToAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedGrantToAction::grantee_expr_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : grantee_expr_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedGrantToAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedGrantToAction::grantee_expr_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : grantee_expr_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedGrantToAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : grantee_expr_list_) it->ClearFieldsAccessed();
}

void ResolvedGrantToAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : grantee_expr_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedRestrictToAction::TYPE;

ResolvedRestrictToAction::~ResolvedRestrictToAction() {
}

absl::Status ResolvedRestrictToAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_restrict_to_action_node());
}

absl::Status ResolvedRestrictToAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedRestrictToActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : restrictee_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_restrictee_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedRestrictToAction>> ResolvedRestrictToAction::RestoreFrom(
    const ResolvedRestrictToActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedExpr>> restrictee_list;
  for (const auto& elem : proto.restrictee_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    restrictee_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedRestrictToAction(
      std::move(restrictee_list));

  return node;
}

void ResolvedRestrictToAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : restrictee_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedRestrictToAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : restrictee_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedRestrictToAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedRestrictToAction(this);
}

absl::Status ResolvedRestrictToAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : restrictee_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedRestrictToAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!restrictee_list_.empty()) {
    fields->emplace_back("restrictee_list", restrictee_list_);
  }
}

absl::Status ResolvedRestrictToAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(restrictee_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedRestrictToAction::restrictee_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : restrictee_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedRestrictToAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedRestrictToAction::restrictee_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : restrictee_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedRestrictToAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : restrictee_list_) it->ClearFieldsAccessed();
}

void ResolvedRestrictToAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : restrictee_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAddToRestricteeListAction::TYPE;

ResolvedAddToRestricteeListAction::~ResolvedAddToRestricteeListAction() {
}

absl::Status ResolvedAddToRestricteeListAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_add_to_restrictee_list_action_node());
}

absl::Status ResolvedAddToRestricteeListAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAddToRestricteeListActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_is_if_not_exists(is_if_not_exists_);
  for (const auto& elem : restrictee_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_restrictee_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAddToRestricteeListAction>> ResolvedAddToRestricteeListAction::RestoreFrom(
    const ResolvedAddToRestricteeListActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool is_if_not_exists =
      proto.is_if_not_exists();
  std::vector<std::unique_ptr<const ResolvedExpr>> restrictee_list;
  for (const auto& elem : proto.restrictee_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    restrictee_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedAddToRestricteeListAction(
      std::move(is_if_not_exists),
      std::move(restrictee_list));

  return node;
}

void ResolvedAddToRestricteeListAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : restrictee_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedAddToRestricteeListAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : restrictee_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedAddToRestricteeListAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAddToRestricteeListAction(this);
}

absl::Status ResolvedAddToRestricteeListAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : restrictee_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAddToRestricteeListAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(is_if_not_exists_)) {
    fields->emplace_back("is_if_not_exists", ToStringImpl(is_if_not_exists_));
  }
  if (!restrictee_list_.empty()) {
    fields->emplace_back("restrictee_list", restrictee_list_);
  }
}

absl::Status ResolvedAddToRestricteeListAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(is_if_not_exists_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAddToRestricteeListAction::is_if_not_exists not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(restrictee_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAddToRestricteeListAction::restrictee_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : restrictee_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAddToRestricteeListAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAddToRestricteeListAction::is_if_not_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAddToRestricteeListAction::restrictee_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : restrictee_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAddToRestricteeListAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : restrictee_list_) it->ClearFieldsAccessed();
}

void ResolvedAddToRestricteeListAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : restrictee_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedRemoveFromRestricteeListAction::TYPE;

ResolvedRemoveFromRestricteeListAction::~ResolvedRemoveFromRestricteeListAction() {
}

absl::Status ResolvedRemoveFromRestricteeListAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_remove_from_restrictee_list_action_node());
}

absl::Status ResolvedRemoveFromRestricteeListAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedRemoveFromRestricteeListActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_is_if_exists(is_if_exists_);
  for (const auto& elem : restrictee_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_restrictee_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedRemoveFromRestricteeListAction>> ResolvedRemoveFromRestricteeListAction::RestoreFrom(
    const ResolvedRemoveFromRestricteeListActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool is_if_exists =
      proto.is_if_exists();
  std::vector<std::unique_ptr<const ResolvedExpr>> restrictee_list;
  for (const auto& elem : proto.restrictee_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    restrictee_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedRemoveFromRestricteeListAction(
      std::move(is_if_exists),
      std::move(restrictee_list));

  return node;
}

void ResolvedRemoveFromRestricteeListAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : restrictee_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedRemoveFromRestricteeListAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : restrictee_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedRemoveFromRestricteeListAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedRemoveFromRestricteeListAction(this);
}

absl::Status ResolvedRemoveFromRestricteeListAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : restrictee_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedRemoveFromRestricteeListAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(is_if_exists_)) {
    fields->emplace_back("is_if_exists", ToStringImpl(is_if_exists_));
  }
  if (!restrictee_list_.empty()) {
    fields->emplace_back("restrictee_list", restrictee_list_);
  }
}

absl::Status ResolvedRemoveFromRestricteeListAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(is_if_exists_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedRemoveFromRestricteeListAction::is_if_exists not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(restrictee_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedRemoveFromRestricteeListAction::restrictee_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : restrictee_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedRemoveFromRestricteeListAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedRemoveFromRestricteeListAction::is_if_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedRemoveFromRestricteeListAction::restrictee_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : restrictee_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedRemoveFromRestricteeListAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : restrictee_list_) it->ClearFieldsAccessed();
}

void ResolvedRemoveFromRestricteeListAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : restrictee_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedFilterUsingAction::TYPE;

ResolvedFilterUsingAction::~ResolvedFilterUsingAction() {
}

absl::Status ResolvedFilterUsingAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_filter_using_action_node());
}

absl::Status ResolvedFilterUsingAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedFilterUsingActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (predicate_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(predicate_->SaveTo(
        file_descriptor_set_map, proto->mutable_predicate()));
  }
  proto->set_predicate_str(predicate_str_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedFilterUsingAction>> ResolvedFilterUsingAction::RestoreFrom(
    const ResolvedFilterUsingActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> predicate;
  if (proto.
  has_predicate()) {
    ZETASQL_ASSIGN_OR_RETURN(predicate,
                     ResolvedExpr::RestoreFrom(
                         proto.predicate(), params));
  }
  std::string predicate_str =
      proto.predicate_str();
  auto node = MakeResolvedFilterUsingAction(
      std::move(predicate),
      std::move(predicate_str));

  return node;
}

void ResolvedFilterUsingAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (predicate_ != nullptr) {
    child_nodes->emplace_back(predicate_.get());
  }
}

void ResolvedFilterUsingAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (predicate_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &predicate_));
    static_assert(sizeof(predicate_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedFilterUsingAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedFilterUsingAction(this);
}

absl::Status ResolvedFilterUsingAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (predicate_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(predicate_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedFilterUsingAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (predicate_ != nullptr) {
    fields->emplace_back("predicate", predicate_.get());
  }
  {
    fields->emplace_back("predicate_str", ToStringImpl(predicate_str_));
  }
}

absl::Status ResolvedFilterUsingAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFilterUsingAction::predicate_str not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (predicate_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          predicate_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedFilterUsingAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFilterUsingAction::predicate_str is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (predicate_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(predicate_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedFilterUsingAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (predicate_ != nullptr) predicate_->ClearFieldsAccessed();
}

void ResolvedFilterUsingAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (predicate_ != nullptr) predicate_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedRevokeFromAction::TYPE;

ResolvedRevokeFromAction::~ResolvedRevokeFromAction() {
}

absl::Status ResolvedRevokeFromAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_revoke_from_action_node());
}

absl::Status ResolvedRevokeFromAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedRevokeFromActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : revokee_expr_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_revokee_expr_list()));
  }
  proto->set_is_revoke_from_all(is_revoke_from_all_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedRevokeFromAction>> ResolvedRevokeFromAction::RestoreFrom(
    const ResolvedRevokeFromActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedExpr>> revokee_expr_list;
  for (const auto& elem : proto.revokee_expr_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    revokee_expr_list.push_back(std::move(elem_restored));
  }
  bool is_revoke_from_all =
      proto.is_revoke_from_all();
  auto node = MakeResolvedRevokeFromAction(
      std::move(revokee_expr_list),
      std::move(is_revoke_from_all));

  return node;
}

void ResolvedRevokeFromAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : revokee_expr_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedRevokeFromAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : revokee_expr_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedRevokeFromAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedRevokeFromAction(this);
}

absl::Status ResolvedRevokeFromAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : revokee_expr_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedRevokeFromAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!revokee_expr_list_.empty()) {
    fields->emplace_back("revokee_expr_list", revokee_expr_list_);
  }
  if (!IsDefaultValue(is_revoke_from_all_)) {
    fields->emplace_back("is_revoke_from_all", ToStringImpl(is_revoke_from_all_));
  }
}

absl::Status ResolvedRevokeFromAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(revokee_expr_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedRevokeFromAction::revokee_expr_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(is_revoke_from_all_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedRevokeFromAction::is_revoke_from_all not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : revokee_expr_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedRevokeFromAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedRevokeFromAction::revokee_expr_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedRevokeFromAction::is_revoke_from_all is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : revokee_expr_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedRevokeFromAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : revokee_expr_list_) it->ClearFieldsAccessed();
}

void ResolvedRevokeFromAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : revokee_expr_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedRenameToAction::TYPE;

ResolvedRenameToAction::~ResolvedRenameToAction() {
}

absl::Status ResolvedRenameToAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterActionProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_rename_to_action_node());
}

absl::Status ResolvedRenameToAction::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedRenameToActionProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : new_path_) {
    proto->add_new_path(elem);
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedRenameToAction>> ResolvedRenameToAction::RestoreFrom(
    const ResolvedRenameToActionProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::string> new_path;
  for (const auto& elem : proto.new_path()) {
    new_path.push_back(elem);
  }
  auto node = MakeResolvedRenameToAction(
      std::move(new_path));

  return node;
}

void ResolvedRenameToAction::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedRenameToAction::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedRenameToAction::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedRenameToAction(this);
}

absl::Status ResolvedRenameToAction::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedRenameToAction::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("new_path", ToStringImpl(new_path_));
  }
}

absl::Status ResolvedRenameToAction::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedRenameToAction::new_path not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedRenameToAction::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedRenameToAction::new_path is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedRenameToAction::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedRenameToAction::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedAlterPrivilegeRestrictionStmt::TYPE;

ResolvedAlterPrivilegeRestrictionStmt::~ResolvedAlterPrivilegeRestrictionStmt() {
}

absl::Status ResolvedAlterPrivilegeRestrictionStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterObjectStmtProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_privilege_restriction_stmt_node());
}

absl::Status ResolvedAlterPrivilegeRestrictionStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterPrivilegeRestrictionStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : column_privilege_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_column_privilege_list()));
  }
  proto->set_object_type(object_type_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterPrivilegeRestrictionStmt>> ResolvedAlterPrivilegeRestrictionStmt::RestoreFrom(
    const ResolvedAlterPrivilegeRestrictionStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedPrivilege>> column_privilege_list;
  for (const auto& elem : proto.column_privilege_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedPrivilege> elem_restored,
                     ResolvedPrivilege::RestoreFrom(elem, params));
    column_privilege_list.push_back(std::move(elem_restored));
  }
  std::string object_type =
      proto.object_type();
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedAlterAction>> alter_action_list;
  for (const auto& elem : proto.parent().alter_action_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedAlterAction> elem_restored,
                     ResolvedAlterAction::RestoreFrom(elem, params));
    alter_action_list.push_back(std::move(elem_restored));
  }
  bool is_if_exists =
      proto.parent().is_if_exists();
  auto node = MakeResolvedAlterPrivilegeRestrictionStmt(
      std::move(name_path),
      std::move(alter_action_list),
      std::move(is_if_exists),
      std::move(column_privilege_list),
      std::move(object_type));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedAlterPrivilegeRestrictionStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : column_privilege_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedAlterPrivilegeRestrictionStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : column_privilege_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedAlterPrivilegeRestrictionStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterPrivilegeRestrictionStmt(this);
}

absl::Status ResolvedAlterPrivilegeRestrictionStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : column_privilege_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAlterPrivilegeRestrictionStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!column_privilege_list_.empty()) {
    fields->emplace_back("column_privilege_list", column_privilege_list_);
  }
  {
    fields->emplace_back("object_type", ToStringImpl(object_type_));
  }
}

absl::Status ResolvedAlterPrivilegeRestrictionStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAlterPrivilegeRestrictionStmt::column_privilege_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAlterPrivilegeRestrictionStmt::object_type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : column_privilege_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAlterPrivilegeRestrictionStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAlterPrivilegeRestrictionStmt::column_privilege_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAlterPrivilegeRestrictionStmt::object_type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : column_privilege_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAlterPrivilegeRestrictionStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : column_privilege_list_) it->ClearFieldsAccessed();
}

void ResolvedAlterPrivilegeRestrictionStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : column_privilege_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAlterRowAccessPolicyStmt::TYPE;

ResolvedAlterRowAccessPolicyStmt::~ResolvedAlterRowAccessPolicyStmt() {
}

absl::Status ResolvedAlterRowAccessPolicyStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterObjectStmtProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_row_access_policy_stmt_node());
}

absl::Status ResolvedAlterRowAccessPolicyStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterRowAccessPolicyStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_name(name_);
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_table_scan()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterRowAccessPolicyStmt>> ResolvedAlterRowAccessPolicyStmt::RestoreFrom(
    const ResolvedAlterRowAccessPolicyStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string name =
      proto.name();
  std::unique_ptr<const ResolvedTableScan> table_scan;
  if (proto.
  has_table_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(table_scan,
                     ResolvedTableScan::RestoreFrom(
                         proto.table_scan(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedAlterAction>> alter_action_list;
  for (const auto& elem : proto.parent().alter_action_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedAlterAction> elem_restored,
                     ResolvedAlterAction::RestoreFrom(elem, params));
    alter_action_list.push_back(std::move(elem_restored));
  }
  bool is_if_exists =
      proto.parent().is_if_exists();
  auto node = MakeResolvedAlterRowAccessPolicyStmt(
      std::move(name_path),
      std::move(alter_action_list),
      std::move(is_if_exists),
      std::move(name),
      std::move(table_scan));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedAlterRowAccessPolicyStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (table_scan_ != nullptr) {
    child_nodes->emplace_back(table_scan_.get());
  }
}

void ResolvedAlterRowAccessPolicyStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (table_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &table_scan_));
    static_assert(sizeof(table_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedAlterRowAccessPolicyStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterRowAccessPolicyStmt(this);
}

absl::Status ResolvedAlterRowAccessPolicyStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAlterRowAccessPolicyStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("name", ToStringImpl(name_));
  }
  if (table_scan_ != nullptr) {
    fields->emplace_back("table_scan", table_scan_.get());
  }
}

absl::Status ResolvedAlterRowAccessPolicyStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAlterRowAccessPolicyStmt::name not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          table_scan_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAlterRowAccessPolicyStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAlterRowAccessPolicyStmt::name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(table_scan_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAlterRowAccessPolicyStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (table_scan_ != nullptr) table_scan_->ClearFieldsAccessed();
}

void ResolvedAlterRowAccessPolicyStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (table_scan_ != nullptr) table_scan_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAlterAllRowAccessPoliciesStmt::TYPE;

ResolvedAlterAllRowAccessPoliciesStmt::~ResolvedAlterAllRowAccessPoliciesStmt() {
}

absl::Status ResolvedAlterAllRowAccessPoliciesStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterObjectStmtProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_all_row_access_policies_stmt_node());
}

absl::Status ResolvedAlterAllRowAccessPoliciesStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterAllRowAccessPoliciesStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_table_scan()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterAllRowAccessPoliciesStmt>> ResolvedAlterAllRowAccessPoliciesStmt::RestoreFrom(
    const ResolvedAlterAllRowAccessPoliciesStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedTableScan> table_scan;
  if (proto.
  has_table_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(table_scan,
                     ResolvedTableScan::RestoreFrom(
                         proto.table_scan(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedAlterAction>> alter_action_list;
  for (const auto& elem : proto.parent().alter_action_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedAlterAction> elem_restored,
                     ResolvedAlterAction::RestoreFrom(elem, params));
    alter_action_list.push_back(std::move(elem_restored));
  }
  bool is_if_exists =
      proto.parent().is_if_exists();
  auto node = MakeResolvedAlterAllRowAccessPoliciesStmt(
      std::move(name_path),
      std::move(alter_action_list),
      std::move(is_if_exists),
      std::move(table_scan));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedAlterAllRowAccessPoliciesStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (table_scan_ != nullptr) {
    child_nodes->emplace_back(table_scan_.get());
  }
}

void ResolvedAlterAllRowAccessPoliciesStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (table_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &table_scan_));
    static_assert(sizeof(table_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedAlterAllRowAccessPoliciesStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterAllRowAccessPoliciesStmt(this);
}

absl::Status ResolvedAlterAllRowAccessPoliciesStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (table_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(table_scan_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAlterAllRowAccessPoliciesStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (table_scan_ != nullptr) {
    fields->emplace_back("table_scan", table_scan_.get());
  }
}

absl::Status ResolvedAlterAllRowAccessPoliciesStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          table_scan_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAlterAllRowAccessPoliciesStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    if (table_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(table_scan_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAlterAllRowAccessPoliciesStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (table_scan_ != nullptr) table_scan_->ClearFieldsAccessed();
}

void ResolvedAlterAllRowAccessPoliciesStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (table_scan_ != nullptr) table_scan_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCreateConstantStmt::TYPE;

ResolvedCreateConstantStmt::~ResolvedCreateConstantStmt() {
}

absl::Status ResolvedCreateConstantStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedCreateStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_constant_stmt_node());
}

absl::Status ResolvedCreateConstantStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateConstantStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_expr()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateConstantStmt>> ResolvedCreateConstantStmt::RestoreFrom(
    const ResolvedCreateConstantStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> expr;
  if (proto.
  has_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(expr,
                     ResolvedExpr::RestoreFrom(
                         proto.expr(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  CreateScope create_scope =
      proto.parent().create_scope();
  CreateMode create_mode =
      proto.parent().create_mode();
  auto node = MakeResolvedCreateConstantStmt(
      std::move(name_path),
      std::move(create_scope),
      std::move(create_mode),
      std::move(expr));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCreateConstantStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expr_ != nullptr) {
    child_nodes->emplace_back(expr_.get());
  }
}

void ResolvedCreateConstantStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expr_));
    static_assert(sizeof(expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedCreateConstantStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateConstantStmt(this);
}

absl::Status ResolvedCreateConstantStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreateConstantStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (expr_ != nullptr) {
    fields->emplace_back("expr", expr_.get());
  }
}

absl::Status ResolvedCreateConstantStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateConstantStmt::expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateConstantStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateConstantStmt::expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreateConstantStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expr_ != nullptr) expr_->ClearFieldsAccessed();
}

void ResolvedCreateConstantStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expr_ != nullptr) expr_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCreateFunctionStmt::TYPE;

ResolvedCreateFunctionStmt::~ResolvedCreateFunctionStmt() {
}

absl::Status ResolvedCreateFunctionStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedCreateStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_function_stmt_node());
}

absl::Status ResolvedCreateFunctionStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateFunctionStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_has_explicit_return_type(has_explicit_return_type_);
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      return_type_, file_descriptor_set_map,
      proto->mutable_return_type()));
  for (const auto& elem : argument_name_list_) {
    proto->add_argument_name_list(elem);
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      signature_, file_descriptor_set_map,
      proto->mutable_signature()));
  proto->set_is_aggregate(is_aggregate_);
  proto->set_language(language_);
  proto->set_code(code_);
  for (const auto& elem : aggregate_expression_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_aggregate_expression_list()));
  }
  if (function_expression_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(function_expression_->SaveTo(
        file_descriptor_set_map, proto->mutable_function_expression()));
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  proto->set_sql_security(sql_security_);
  proto->set_determinism_level(determinism_level_);
  proto->set_is_remote(is_remote_);
  if (connection_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(connection_->SaveTo(
        file_descriptor_set_map, proto->mutable_connection()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateFunctionStmt>> ResolvedCreateFunctionStmt::RestoreFrom(
    const ResolvedCreateFunctionStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool has_explicit_return_type =
      proto.has_explicit_return_type();
  ZETASQL_ASSIGN_OR_RETURN(auto return_type,
                   RestoreFromImpl<const Type*>(
                       proto.return_type(),
                       params));
  std::vector<std::string> argument_name_list;
  for (const auto& elem : proto.argument_name_list()) {
    argument_name_list.push_back(elem);
  }
  ZETASQL_ASSIGN_OR_RETURN(auto signature,
                   RestoreFromImpl<FunctionSignature>(
                       proto.signature(),
                       params));
  bool is_aggregate =
      proto.is_aggregate();
  std::string language =
      proto.language();
  std::string code =
      proto.code();
  std::vector<std::unique_ptr<const ResolvedComputedColumn>> aggregate_expression_list;
  for (const auto& elem : proto.aggregate_expression_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedComputedColumn> elem_restored,
                     ResolvedComputedColumn::RestoreFrom(elem, params));
    aggregate_expression_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedExpr> function_expression;
  if (proto.
  has_function_expression()) {
    ZETASQL_ASSIGN_OR_RETURN(function_expression,
                     ResolvedExpr::RestoreFrom(
                         proto.function_expression(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  SqlSecurity sql_security =
      proto.sql_security();
  DeterminismLevel determinism_level =
      proto.determinism_level();
  bool is_remote =
      proto.is_remote();
  std::unique_ptr<const ResolvedConnection> connection;
  if (proto.
  has_connection()) {
    ZETASQL_ASSIGN_OR_RETURN(connection,
                     ResolvedConnection::RestoreFrom(
                         proto.connection(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  CreateScope create_scope =
      proto.parent().create_scope();
  CreateMode create_mode =
      proto.parent().create_mode();
  auto node = MakeResolvedCreateFunctionStmt(
      std::move(name_path),
      std::move(create_scope),
      std::move(create_mode),
      std::move(has_explicit_return_type),
      std::move(return_type),
      std::move(argument_name_list),
      std::move(signature),
      std::move(is_aggregate),
      std::move(language),
      std::move(code),
      std::move(aggregate_expression_list),
      std::move(function_expression),
      std::move(option_list),
      std::move(sql_security),
      std::move(determinism_level),
      std::move(is_remote),
      std::move(connection));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCreateFunctionStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : aggregate_expression_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (function_expression_ != nullptr) {
    child_nodes->emplace_back(function_expression_.get());
  }
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (connection_ != nullptr) {
    child_nodes->emplace_back(connection_.get());
  }
}

void ResolvedCreateFunctionStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : aggregate_expression_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (function_expression_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &function_expression_));
    static_assert(sizeof(function_expression_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (connection_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &connection_));
    static_assert(sizeof(connection_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedCreateFunctionStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateFunctionStmt(this);
}

absl::Status ResolvedCreateFunctionStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : aggregate_expression_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (function_expression_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(function_expression_.get()->Accept(visitor));
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (connection_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(connection_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreateFunctionStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(has_explicit_return_type_)) {
    fields->emplace_back("has_explicit_return_type", ToStringImpl(has_explicit_return_type_));
  }
  if (!IsDefaultValue(return_type_)) {
    fields->emplace_back("return_type", ToStringImpl(return_type_));
  }
  if (!IsDefaultValue(argument_name_list_)) {
    fields->emplace_back("argument_name_list", ToStringCommaSeparated(argument_name_list_));
  }
  if (!IsDefaultValue(signature_)) {
    fields->emplace_back("signature", ToStringVerbose(signature_));
  }
  if (!IsDefaultValue(is_aggregate_)) {
    fields->emplace_back("is_aggregate", ToStringImpl(is_aggregate_));
  }
  if (!IsDefaultValue(language_)) {
    fields->emplace_back("language", ToStringImpl(language_));
  }
  if (!IsDefaultValue(code_)) {
    fields->emplace_back("code", ToStringImpl(code_));
  }
  if (!aggregate_expression_list_.empty()) {
    fields->emplace_back("aggregate_expression_list", aggregate_expression_list_);
  }
  if (function_expression_ != nullptr) {
    fields->emplace_back("function_expression", function_expression_.get());
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
  if (!IsDefaultValue(sql_security_)) {
    fields->emplace_back("sql_security", ToStringImpl(sql_security_));
  }
  if (!IsDefaultValue(determinism_level_)) {
    fields->emplace_back("determinism_level", ToStringImpl(determinism_level_));
  }
  if (!IsDefaultValue(is_remote_)) {
    fields->emplace_back("is_remote", ToStringImpl(is_remote_));
  }
  if (connection_ != nullptr) {
    fields->emplace_back("connection", connection_.get());
  }
}

absl::Status ResolvedCreateFunctionStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(is_aggregate_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateFunctionStmt::is_aggregate not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0 &&
      !IsDefaultValue(language_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateFunctionStmt::language not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<7)) == 0 &&
      !IsDefaultValue(aggregate_expression_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateFunctionStmt::aggregate_expression_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<9)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateFunctionStmt::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<10)) == 0 &&
      !IsDefaultValue(sql_security_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateFunctionStmt::sql_security not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<11)) == 0 &&
      !IsDefaultValue(determinism_level_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateFunctionStmt::determinism_level not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<13)) == 0 &&
      !IsDefaultValue(connection_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateFunctionStmt::connection not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<7)) != 0) {
    for (const auto& it : aggregate_expression_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<8)) != 0) {
    if (function_expression_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          function_expression_.get(), root));
    }
  }
  if ((accessed_ & (1<<9)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<13)) != 0) {
    if (connection_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          connection_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateFunctionStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateFunctionStmt::is_aggregate is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateFunctionStmt::language is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<7)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateFunctionStmt::aggregate_expression_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<9)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateFunctionStmt::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<10)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateFunctionStmt::sql_security is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<11)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateFunctionStmt::determinism_level is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<13)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateFunctionStmt::connection is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<7)) != 0) {
    for (const auto& it : aggregate_expression_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<8)) != 0) {
    if (function_expression_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(function_expression_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<9)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<13)) != 0) {
    if (connection_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(connection_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreateFunctionStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : aggregate_expression_list_) it->ClearFieldsAccessed();
  if (function_expression_ != nullptr) function_expression_->ClearFieldsAccessed();
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
  if (connection_ != nullptr) connection_->ClearFieldsAccessed();
}

void ResolvedCreateFunctionStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : aggregate_expression_list_) it->MarkFieldsAccessed();
  if (function_expression_ != nullptr) function_expression_->MarkFieldsAccessed();
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
  if (connection_ != nullptr) connection_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedArgumentDef::TYPE;

const ResolvedArgumentDef::ArgumentKind ResolvedArgumentDef::SCALAR;
const ResolvedArgumentDef::ArgumentKind ResolvedArgumentDef::AGGREGATE;
const ResolvedArgumentDef::ArgumentKind ResolvedArgumentDef::NOT_AGGREGATE;

ResolvedArgumentDef::~ResolvedArgumentDef() {
}

absl::Status ResolvedArgumentDef::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_argument_def_node());
}

absl::Status ResolvedArgumentDef::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedArgumentDefProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_name(name_);
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      type_, file_descriptor_set_map,
      proto->mutable_type()));
  proto->set_argument_kind(argument_kind_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedArgumentDef>> ResolvedArgumentDef::RestoreFrom(
    const ResolvedArgumentDefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string name =
      proto.name();
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.type(),
                       params));
  ArgumentKind argument_kind =
      proto.argument_kind();
  auto node = MakeResolvedArgumentDef(
      std::move(name),
      std::move(type),
      std::move(argument_kind));

  return node;
}

void ResolvedArgumentDef::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedArgumentDef::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedArgumentDef::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedArgumentDef(this);
}

absl::Status ResolvedArgumentDef::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedArgumentDef::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(name_)) {
    fields->emplace_back("name", ToStringImpl(name_));
  }
  {
    fields->emplace_back("type", ToStringImpl(type_));
  }
  if (!IsDefaultValue(argument_kind_)) {
    fields->emplace_back("argument_kind", ToStringImpl(argument_kind_));
  }
}

absl::Status ResolvedArgumentDef::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedArgumentDef::type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(argument_kind_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedArgumentDef::argument_kind not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedArgumentDef::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedArgumentDef::type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedArgumentDef::argument_kind is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedArgumentDef::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedArgumentDef::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedArgumentRef::TYPE;

const ResolvedArgumentRef::ArgumentKind ResolvedArgumentRef::SCALAR;
const ResolvedArgumentRef::ArgumentKind ResolvedArgumentRef::AGGREGATE;
const ResolvedArgumentRef::ArgumentKind ResolvedArgumentRef::NOT_AGGREGATE;

ResolvedArgumentRef::~ResolvedArgumentRef() {
}

absl::Status ResolvedArgumentRef::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedExprProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_argument_ref_node());
}

absl::Status ResolvedArgumentRef::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedArgumentRefProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_name(name_);
  proto->set_argument_kind(argument_kind_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedArgumentRef>> ResolvedArgumentRef::RestoreFrom(
    const ResolvedArgumentRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string name =
      proto.name();
  ArgumentKind argument_kind =
      proto.argument_kind();
  ZETASQL_ASSIGN_OR_RETURN(auto type,
                   RestoreFromImpl<const Type*>(
                       proto.parent().type(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto type_annotation_map,
                   RestoreFromImpl<const AnnotationMap*>(
                       proto.parent().type_annotation_map(),
                       params));
  auto node = MakeResolvedArgumentRef(
      std::move(type),
      std::move(name),
      std::move(argument_kind));

  node->set_type_annotation_map(std::move(type_annotation_map));
  return node;
}

void ResolvedArgumentRef::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedArgumentRef::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedArgumentRef::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedArgumentRef(this);
}

absl::Status ResolvedArgumentRef::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedArgumentRef::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("name", ToStringImpl(name_));
  }
  if (!IsDefaultValue(argument_kind_)) {
    fields->emplace_back("argument_kind", ToStringImpl(argument_kind_));
  }
}

absl::Status ResolvedArgumentRef::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedArgumentRef::name not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedArgumentRef::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedArgumentRef::name is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedArgumentRef::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedArgumentRef::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedCreateTableFunctionStmt::TYPE;

ResolvedCreateTableFunctionStmt::~ResolvedCreateTableFunctionStmt() {
}

absl::Status ResolvedCreateTableFunctionStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedCreateStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_table_function_stmt_node());
}

absl::Status ResolvedCreateTableFunctionStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateTableFunctionStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : argument_name_list_) {
    proto->add_argument_name_list(elem);
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      signature_, file_descriptor_set_map,
      proto->mutable_signature()));
  proto->set_has_explicit_return_schema(has_explicit_return_schema_);
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  proto->set_language(language_);
  proto->set_code(code_);
  if (query_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(query_->SaveTo(
        file_descriptor_set_map, proto->mutable_query()));
  }
  for (const auto& elem : output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_output_column_list()));
  }
  proto->set_is_value_table(is_value_table_);
  proto->set_sql_security(sql_security_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateTableFunctionStmt>> ResolvedCreateTableFunctionStmt::RestoreFrom(
    const ResolvedCreateTableFunctionStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::string> argument_name_list;
  for (const auto& elem : proto.argument_name_list()) {
    argument_name_list.push_back(elem);
  }
  ZETASQL_ASSIGN_OR_RETURN(auto signature,
                   RestoreFromImpl<FunctionSignature>(
                       proto.signature(),
                       params));
  bool has_explicit_return_schema =
      proto.has_explicit_return_schema();
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::string language =
      proto.language();
  std::string code =
      proto.code();
  std::unique_ptr<const ResolvedScan> query;
  if (proto.
  has_query()) {
    ZETASQL_ASSIGN_OR_RETURN(query,
                     ResolvedScan::RestoreFrom(
                         proto.query(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOutputColumn>> output_column_list;
  for (const auto& elem : proto.output_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOutputColumn> elem_restored,
                     ResolvedOutputColumn::RestoreFrom(elem, params));
    output_column_list.push_back(std::move(elem_restored));
  }
  bool is_value_table =
      proto.is_value_table();
  SqlSecurity sql_security =
      proto.sql_security();
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  CreateScope create_scope =
      proto.parent().create_scope();
  CreateMode create_mode =
      proto.parent().create_mode();
  auto node = MakeResolvedCreateTableFunctionStmt(
      std::move(name_path),
      std::move(create_scope),
      std::move(create_mode),
      std::move(argument_name_list),
      std::move(signature),
      std::move(has_explicit_return_schema),
      std::move(option_list),
      std::move(language),
      std::move(code),
      std::move(query),
      std::move(output_column_list),
      std::move(is_value_table),
      std::move(sql_security));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCreateTableFunctionStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (query_ != nullptr) {
    child_nodes->emplace_back(query_.get());
  }
  for (const auto& elem : output_column_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedCreateTableFunctionStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (query_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &query_));
    static_assert(sizeof(query_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : output_column_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedCreateTableFunctionStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateTableFunctionStmt(this);
}

absl::Status ResolvedCreateTableFunctionStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (query_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(query_.get()->Accept(visitor));
  }
  for (const auto& elem : output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreateTableFunctionStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(argument_name_list_)) {
    fields->emplace_back("argument_name_list", ToStringCommaSeparated(argument_name_list_));
  }
  if (!IsDefaultValue(signature_)) {
    fields->emplace_back("signature", ToStringVerbose(signature_));
  }
  if (!IsDefaultValue(has_explicit_return_schema_)) {
    fields->emplace_back("has_explicit_return_schema", ToStringImpl(has_explicit_return_schema_));
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
  if (!IsDefaultValue(language_)) {
    fields->emplace_back("language", ToStringImpl(language_));
  }
  if (!IsDefaultValue(code_)) {
    fields->emplace_back("code", ToStringImpl(code_));
  }
  if (query_ != nullptr) {
    fields->emplace_back("query", query_.get());
  }
  if (!output_column_list_.empty()) {
    fields->emplace_back("output_column_list", output_column_list_);
  }
  if (!IsDefaultValue(is_value_table_)) {
    fields->emplace_back("is_value_table", ToStringImpl(is_value_table_));
  }
  if (!IsDefaultValue(sql_security_)) {
    fields->emplace_back("sql_security", ToStringImpl(sql_security_));
  }
}

absl::Status ResolvedCreateTableFunctionStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableFunctionStmt::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(language_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableFunctionStmt::language not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<6)) == 0 &&
      !IsDefaultValue(query_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableFunctionStmt::query not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<7)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableFunctionStmt::output_column_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<8)) == 0 &&
      !IsDefaultValue(is_value_table_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableFunctionStmt::is_value_table not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<9)) == 0 &&
      !IsDefaultValue(sql_security_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateTableFunctionStmt::sql_security not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    if (query_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          query_.get(), root));
    }
  }
  if ((accessed_ & (1<<7)) != 0) {
    for (const auto& it : output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateTableFunctionStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableFunctionStmt::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableFunctionStmt::language is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<6)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableFunctionStmt::query is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<7)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableFunctionStmt::output_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<8)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableFunctionStmt::is_value_table is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<9)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateTableFunctionStmt::sql_security is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    if (query_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(query_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<7)) != 0) {
    for (const auto& it : output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreateTableFunctionStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
  if (query_ != nullptr) query_->ClearFieldsAccessed();
  for (const auto& it : output_column_list_) it->ClearFieldsAccessed();
}

void ResolvedCreateTableFunctionStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
  if (query_ != nullptr) query_->MarkFieldsAccessed();
  for (const auto& it : output_column_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedRelationArgumentScan::TYPE;

ResolvedRelationArgumentScan::~ResolvedRelationArgumentScan() {
}

absl::Status ResolvedRelationArgumentScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_relation_argument_scan_node());
}

absl::Status ResolvedRelationArgumentScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedRelationArgumentScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_name(name_);
  proto->set_is_value_table(is_value_table_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedRelationArgumentScan>> ResolvedRelationArgumentScan::RestoreFrom(
    const ResolvedRelationArgumentScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string name =
      proto.name();
  bool is_value_table =
      proto.is_value_table();
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedRelationArgumentScan(
      std::move(column_list),
      std::move(name),
      std::move(is_value_table));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

void ResolvedRelationArgumentScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedRelationArgumentScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedRelationArgumentScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedRelationArgumentScan(this);
}

absl::Status ResolvedRelationArgumentScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedRelationArgumentScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("name", ToStringImpl(name_));
  }
  if (!IsDefaultValue(is_value_table_)) {
    fields->emplace_back("is_value_table", ToStringImpl(is_value_table_));
  }
}

absl::Status ResolvedRelationArgumentScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedRelationArgumentScan::name not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(is_value_table_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedRelationArgumentScan::is_value_table not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedRelationArgumentScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedRelationArgumentScan::name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedRelationArgumentScan::is_value_table is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedRelationArgumentScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedRelationArgumentScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedArgumentList::TYPE;

ResolvedArgumentList::~ResolvedArgumentList() {
}

absl::Status ResolvedArgumentList::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_argument_list_node());
}

absl::Status ResolvedArgumentList::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedArgumentListProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : arg_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_arg_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedArgumentList>> ResolvedArgumentList::RestoreFrom(
    const ResolvedArgumentListProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedArgumentDef>> arg_list;
  for (const auto& elem : proto.arg_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedArgumentDef> elem_restored,
                     ResolvedArgumentDef::RestoreFrom(elem, params));
    arg_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedArgumentList(
      std::move(arg_list));

  return node;
}

void ResolvedArgumentList::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : arg_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedArgumentList::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : arg_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedArgumentList::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedArgumentList(this);
}

absl::Status ResolvedArgumentList::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : arg_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedArgumentList::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!arg_list_.empty()) {
    fields->emplace_back("arg_list", arg_list_);
  }
}

absl::Status ResolvedArgumentList::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : arg_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedArgumentList::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : arg_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedArgumentList::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : arg_list_) it->ClearFieldsAccessed();
}

void ResolvedArgumentList::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : arg_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedFunctionSignatureHolder::TYPE;

ResolvedFunctionSignatureHolder::~ResolvedFunctionSignatureHolder() {
}

absl::Status ResolvedFunctionSignatureHolder::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_function_signature_holder_node());
}

absl::Status ResolvedFunctionSignatureHolder::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedFunctionSignatureHolderProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      signature_, file_descriptor_set_map,
      proto->mutable_signature()));
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedFunctionSignatureHolder>> ResolvedFunctionSignatureHolder::RestoreFrom(
    const ResolvedFunctionSignatureHolderProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto signature,
                   RestoreFromImpl<FunctionSignature>(
                       proto.signature(),
                       params));
  auto node = MakeResolvedFunctionSignatureHolder(
      std::move(signature));

  return node;
}

void ResolvedFunctionSignatureHolder::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedFunctionSignatureHolder::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedFunctionSignatureHolder::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedFunctionSignatureHolder(this);
}

absl::Status ResolvedFunctionSignatureHolder::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedFunctionSignatureHolder::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("signature", ToStringVerbose(signature_));
  }
}

absl::Status ResolvedFunctionSignatureHolder::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedFunctionSignatureHolder::signature not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedFunctionSignatureHolder::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedFunctionSignatureHolder::signature is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedFunctionSignatureHolder::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedFunctionSignatureHolder::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedDropFunctionStmt::TYPE;

ResolvedDropFunctionStmt::~ResolvedDropFunctionStmt() {
}

absl::Status ResolvedDropFunctionStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_drop_function_stmt_node());
}

absl::Status ResolvedDropFunctionStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedDropFunctionStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_is_if_exists(is_if_exists_);
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  if (arguments_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(arguments_->SaveTo(
        file_descriptor_set_map, proto->mutable_arguments()));
  }
  if (signature_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(signature_->SaveTo(
        file_descriptor_set_map, proto->mutable_signature()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedDropFunctionStmt>> ResolvedDropFunctionStmt::RestoreFrom(
    const ResolvedDropFunctionStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool is_if_exists =
      proto.is_if_exists();
  std::vector<std::string> name_path;
  for (const auto& elem : proto.name_path()) {
    name_path.push_back(elem);
  }
  std::unique_ptr<const ResolvedArgumentList> arguments;
  if (proto.
  has_arguments()) {
    ZETASQL_ASSIGN_OR_RETURN(arguments,
                     ResolvedArgumentList::RestoreFrom(
                         proto.arguments(), params));
  }
  std::unique_ptr<const ResolvedFunctionSignatureHolder> signature;
  if (proto.
  has_signature()) {
    ZETASQL_ASSIGN_OR_RETURN(signature,
                     ResolvedFunctionSignatureHolder::RestoreFrom(
                         proto.signature(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedDropFunctionStmt(
      std::move(is_if_exists),
      std::move(name_path),
      std::move(arguments),
      std::move(signature));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedDropFunctionStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (arguments_ != nullptr) {
    child_nodes->emplace_back(arguments_.get());
  }
  if (signature_ != nullptr) {
    child_nodes->emplace_back(signature_.get());
  }
}

void ResolvedDropFunctionStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (arguments_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &arguments_));
    static_assert(sizeof(arguments_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (signature_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &signature_));
    static_assert(sizeof(signature_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedDropFunctionStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedDropFunctionStmt(this);
}

absl::Status ResolvedDropFunctionStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (arguments_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(arguments_.get()->Accept(visitor));
  }
  if (signature_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(signature_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedDropFunctionStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("is_if_exists", ToStringImpl(is_if_exists_));
  }
  {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
  if (arguments_ != nullptr) {
    fields->emplace_back("arguments", arguments_.get());
  }
  if (signature_ != nullptr) {
    fields->emplace_back("signature", signature_.get());
  }
}

absl::Status ResolvedDropFunctionStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropFunctionStmt::is_if_exists not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropFunctionStmt::name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (arguments_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          arguments_.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (signature_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          signature_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedDropFunctionStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropFunctionStmt::is_if_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropFunctionStmt::name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    if (arguments_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(arguments_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (signature_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(signature_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedDropFunctionStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (arguments_ != nullptr) arguments_->ClearFieldsAccessed();
  if (signature_ != nullptr) signature_->ClearFieldsAccessed();
}

void ResolvedDropFunctionStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (arguments_ != nullptr) arguments_->MarkFieldsAccessed();
  if (signature_ != nullptr) signature_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedDropTableFunctionStmt::TYPE;

ResolvedDropTableFunctionStmt::~ResolvedDropTableFunctionStmt() {
}

absl::Status ResolvedDropTableFunctionStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_drop_table_function_stmt_node());
}

absl::Status ResolvedDropTableFunctionStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedDropTableFunctionStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_is_if_exists(is_if_exists_);
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedDropTableFunctionStmt>> ResolvedDropTableFunctionStmt::RestoreFrom(
    const ResolvedDropTableFunctionStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  bool is_if_exists =
      proto.is_if_exists();
  std::vector<std::string> name_path;
  for (const auto& elem : proto.name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedDropTableFunctionStmt(
      std::move(is_if_exists),
      std::move(name_path));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedDropTableFunctionStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedDropTableFunctionStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedDropTableFunctionStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedDropTableFunctionStmt(this);
}

absl::Status ResolvedDropTableFunctionStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedDropTableFunctionStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("is_if_exists", ToStringImpl(is_if_exists_));
  }
  {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
}

absl::Status ResolvedDropTableFunctionStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropTableFunctionStmt::is_if_exists not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedDropTableFunctionStmt::name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedDropTableFunctionStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropTableFunctionStmt::is_if_exists is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedDropTableFunctionStmt::name_path is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedDropTableFunctionStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedDropTableFunctionStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedCallStmt::TYPE;

ResolvedCallStmt::~ResolvedCallStmt() {
}

absl::Status ResolvedCallStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_call_stmt_node());
}

absl::Status ResolvedCallStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCallStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      procedure_, file_descriptor_set_map,
      proto->mutable_procedure()));
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      signature_, file_descriptor_set_map,
      proto->mutable_signature()));
  for (const auto& elem : argument_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_argument_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCallStmt>> ResolvedCallStmt::RestoreFrom(
    const ResolvedCallStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto procedure,
                   RestoreFromImpl<const Procedure*>(
                       proto.procedure(),
                       params));
  ZETASQL_ASSIGN_OR_RETURN(auto signature,
                   RestoreFromImpl<FunctionSignature>(
                       proto.signature(),
                       params));
  std::vector<std::unique_ptr<const ResolvedExpr>> argument_list;
  for (const auto& elem : proto.argument_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    argument_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedCallStmt(
      std::move(procedure),
      std::move(signature),
      std::move(argument_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCallStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : argument_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedCallStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : argument_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedCallStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCallStmt(this);
}

absl::Status ResolvedCallStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : argument_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCallStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("procedure", ToStringImpl(procedure_));
  }
  if (!IsDefaultValue(signature_)) {
    fields->emplace_back("signature", ToStringImpl(signature_));
  }
  if (!argument_list_.empty()) {
    fields->emplace_back("argument_list", argument_list_);
  }
}

absl::Status ResolvedCallStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCallStmt::procedure not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCallStmt::argument_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : argument_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCallStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCallStmt::procedure is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCallStmt::argument_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : argument_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCallStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : argument_list_) it->ClearFieldsAccessed();
}

void ResolvedCallStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : argument_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedImportStmt::TYPE;

const ResolvedImportStmt::ImportKind ResolvedImportStmt::MODULE;
const ResolvedImportStmt::ImportKind ResolvedImportStmt::PROTO;
const ResolvedImportStmt::ImportKind ResolvedImportStmt::__ImportKind__switch_must_have_a_default__;

ResolvedImportStmt::~ResolvedImportStmt() {
}

absl::Status ResolvedImportStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_import_stmt_node());
}

absl::Status ResolvedImportStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedImportStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_import_kind(import_kind_);
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  proto->set_file_path(file_path_);
  for (const auto& elem : alias_path_) {
    proto->add_alias_path(elem);
  }
  for (const auto& elem : into_alias_path_) {
    proto->add_into_alias_path(elem);
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedImportStmt>> ResolvedImportStmt::RestoreFrom(
    const ResolvedImportStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ImportKind import_kind =
      proto.import_kind();
  std::vector<std::string> name_path;
  for (const auto& elem : proto.name_path()) {
    name_path.push_back(elem);
  }
  std::string file_path =
      proto.file_path();
  std::vector<std::string> alias_path;
  for (const auto& elem : proto.alias_path()) {
    alias_path.push_back(elem);
  }
  std::vector<std::string> into_alias_path;
  for (const auto& elem : proto.into_alias_path()) {
    into_alias_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedImportStmt(
      std::move(import_kind),
      std::move(name_path),
      std::move(file_path),
      std::move(alias_path),
      std::move(into_alias_path),
      std::move(option_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedImportStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedImportStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedImportStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedImportStmt(this);
}

absl::Status ResolvedImportStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedImportStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("import_kind", ToStringImpl(import_kind_));
  }
  if (!IsDefaultValue(name_path_)) {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
  if (!IsDefaultValue(file_path_)) {
    fields->emplace_back("file_path", ToStringImpl(file_path_));
  }
  if (!IsDefaultValue(alias_path_)) {
    fields->emplace_back("alias_path", ToStringImpl(alias_path_));
  }
  if (!IsDefaultValue(into_alias_path_)) {
    fields->emplace_back("into_alias_path", ToStringImpl(into_alias_path_));
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
}

absl::Status ResolvedImportStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedImportStmt::import_kind not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(name_path_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedImportStmt::name_path not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(file_path_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedImportStmt::file_path not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(alias_path_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedImportStmt::alias_path not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0 &&
      !IsDefaultValue(into_alias_path_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedImportStmt::into_alias_path not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedImportStmt::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedImportStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedImportStmt::import_kind is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedImportStmt::name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedImportStmt::file_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedImportStmt::alias_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedImportStmt::into_alias_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedImportStmt::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedImportStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
}

void ResolvedImportStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedModuleStmt::TYPE;

ResolvedModuleStmt::~ResolvedModuleStmt() {
}

absl::Status ResolvedModuleStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_module_stmt_node());
}

absl::Status ResolvedModuleStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedModuleStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedModuleStmt>> ResolvedModuleStmt::RestoreFrom(
    const ResolvedModuleStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::string> name_path;
  for (const auto& elem : proto.name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedModuleStmt(
      std::move(name_path),
      std::move(option_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedModuleStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedModuleStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedModuleStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedModuleStmt(this);
}

absl::Status ResolvedModuleStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedModuleStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
}

absl::Status ResolvedModuleStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedModuleStmt::name_path not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedModuleStmt::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedModuleStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedModuleStmt::name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedModuleStmt::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedModuleStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
}

void ResolvedModuleStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAggregateHavingModifier::TYPE;

const ResolvedAggregateHavingModifier::HavingModifierKind ResolvedAggregateHavingModifier::INVALID;
const ResolvedAggregateHavingModifier::HavingModifierKind ResolvedAggregateHavingModifier::MAX;
const ResolvedAggregateHavingModifier::HavingModifierKind ResolvedAggregateHavingModifier::MIN;

ResolvedAggregateHavingModifier::~ResolvedAggregateHavingModifier() {
}

absl::Status ResolvedAggregateHavingModifier::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_aggregate_having_modifier_node());
}

absl::Status ResolvedAggregateHavingModifier::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAggregateHavingModifierProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_kind(kind_);
  if (having_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(having_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_having_expr()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAggregateHavingModifier>> ResolvedAggregateHavingModifier::RestoreFrom(
    const ResolvedAggregateHavingModifierProto& proto,
    const ResolvedNode::RestoreParams& params) {
  HavingModifierKind kind =
      proto.kind();
  std::unique_ptr<const ResolvedExpr> having_expr;
  if (proto.
  has_having_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(having_expr,
                     ResolvedExpr::RestoreFrom(
                         proto.having_expr(), params));
  }
  auto node = MakeResolvedAggregateHavingModifier(
      std::move(kind),
      std::move(having_expr));

  return node;
}

void ResolvedAggregateHavingModifier::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (having_expr_ != nullptr) {
    child_nodes->emplace_back(having_expr_.get());
  }
}

void ResolvedAggregateHavingModifier::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (having_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &having_expr_));
    static_assert(sizeof(having_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedAggregateHavingModifier::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAggregateHavingModifier(this);
}

absl::Status ResolvedAggregateHavingModifier::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (having_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(having_expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAggregateHavingModifier::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("kind", ToStringImpl(kind_));
  }
  if (having_expr_ != nullptr) {
    fields->emplace_back("having_expr", having_expr_.get());
  }
}

absl::Status ResolvedAggregateHavingModifier::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAggregateHavingModifier::kind not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAggregateHavingModifier::having_expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (having_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          having_expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAggregateHavingModifier::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAggregateHavingModifier::kind is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAggregateHavingModifier::having_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (having_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(having_expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAggregateHavingModifier::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (having_expr_ != nullptr) having_expr_->ClearFieldsAccessed();
}

void ResolvedAggregateHavingModifier::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (having_expr_ != nullptr) having_expr_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCreateMaterializedViewStmt::TYPE;

ResolvedCreateMaterializedViewStmt::~ResolvedCreateMaterializedViewStmt() {
}

absl::Status ResolvedCreateMaterializedViewStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedCreateViewBaseProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_materialized_view_stmt_node());
}

absl::Status ResolvedCreateMaterializedViewStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateMaterializedViewStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : column_definition_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_column_definition_list()));
  }
  for (const auto& elem : partition_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_partition_by_list()));
  }
  for (const auto& elem : cluster_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_cluster_by_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateMaterializedViewStmt>> ResolvedCreateMaterializedViewStmt::RestoreFrom(
    const ResolvedCreateMaterializedViewStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedColumnDefinition>> column_definition_list;
  for (const auto& elem : proto.column_definition_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedColumnDefinition> elem_restored,
                     ResolvedColumnDefinition::RestoreFrom(elem, params));
    column_definition_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedExpr>> partition_by_list;
  for (const auto& elem : proto.partition_by_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    partition_by_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedExpr>> cluster_by_list;
  for (const auto& elem : proto.cluster_by_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    cluster_by_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().parent().name_path()) {
    name_path.push_back(elem);
  }
  CreateScope create_scope =
      proto.parent().parent().create_scope();
  CreateMode create_mode =
      proto.parent().parent().create_mode();
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.parent().option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOutputColumn>> output_column_list;
  for (const auto& elem : proto.parent().output_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOutputColumn> elem_restored,
                     ResolvedOutputColumn::RestoreFrom(elem, params));
    output_column_list.push_back(std::move(elem_restored));
  }
  bool has_explicit_columns =
      proto.parent().has_explicit_columns();
  std::unique_ptr<const ResolvedScan> query;
  if (proto.parent().
  has_query()) {
    ZETASQL_ASSIGN_OR_RETURN(query,
                     ResolvedScan::RestoreFrom(
                         proto.parent().query(), params));
  }
  std::string sql =
      proto.parent().sql();
  SqlSecurity sql_security =
      proto.parent().sql_security();
  bool is_value_table =
      proto.parent().is_value_table();
  bool recursive =
      proto.parent().recursive();
  auto node = MakeResolvedCreateMaterializedViewStmt(
      std::move(name_path),
      std::move(create_scope),
      std::move(create_mode),
      std::move(option_list),
      std::move(output_column_list),
      std::move(has_explicit_columns),
      std::move(query),
      std::move(sql),
      std::move(sql_security),
      std::move(is_value_table),
      std::move(recursive),
      std::move(column_definition_list),
      std::move(partition_by_list),
      std::move(cluster_by_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCreateMaterializedViewStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : column_definition_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : partition_by_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : cluster_by_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedCreateMaterializedViewStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : column_definition_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : partition_by_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : cluster_by_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedCreateMaterializedViewStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateMaterializedViewStmt(this);
}

absl::Status ResolvedCreateMaterializedViewStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : column_definition_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : partition_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : cluster_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreateMaterializedViewStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!column_definition_list_.empty()) {
    fields->emplace_back("column_definition_list", column_definition_list_);
  }
  if (!partition_by_list_.empty()) {
    fields->emplace_back("partition_by_list", partition_by_list_);
  }
  if (!cluster_by_list_.empty()) {
    fields->emplace_back("cluster_by_list", cluster_by_list_);
  }
}

absl::Status ResolvedCreateMaterializedViewStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(partition_by_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateMaterializedViewStmt::partition_by_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(cluster_by_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateMaterializedViewStmt::cluster_by_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : column_definition_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : partition_by_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : cluster_by_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateMaterializedViewStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateMaterializedViewStmt::partition_by_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateMaterializedViewStmt::cluster_by_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : column_definition_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : partition_by_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : cluster_by_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreateMaterializedViewStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : column_definition_list_) it->ClearFieldsAccessed();
  for (const auto& it : partition_by_list_) it->ClearFieldsAccessed();
  for (const auto& it : cluster_by_list_) it->ClearFieldsAccessed();
}

void ResolvedCreateMaterializedViewStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : column_definition_list_) it->MarkFieldsAccessed();
  for (const auto& it : partition_by_list_) it->MarkFieldsAccessed();
  for (const auto& it : cluster_by_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCreateProcedureStmt::TYPE;

ResolvedCreateProcedureStmt::~ResolvedCreateProcedureStmt() {
}

absl::Status ResolvedCreateProcedureStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedCreateStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_procedure_stmt_node());
}

absl::Status ResolvedCreateProcedureStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateProcedureStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : argument_name_list_) {
    proto->add_argument_name_list(elem);
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      signature_, file_descriptor_set_map,
      proto->mutable_signature()));
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  proto->set_procedure_body(procedure_body_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateProcedureStmt>> ResolvedCreateProcedureStmt::RestoreFrom(
    const ResolvedCreateProcedureStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::string> argument_name_list;
  for (const auto& elem : proto.argument_name_list()) {
    argument_name_list.push_back(elem);
  }
  ZETASQL_ASSIGN_OR_RETURN(auto signature,
                   RestoreFromImpl<FunctionSignature>(
                       proto.signature(),
                       params));
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::string procedure_body =
      proto.procedure_body();
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  CreateScope create_scope =
      proto.parent().create_scope();
  CreateMode create_mode =
      proto.parent().create_mode();
  auto node = MakeResolvedCreateProcedureStmt(
      std::move(name_path),
      std::move(create_scope),
      std::move(create_mode),
      std::move(argument_name_list),
      std::move(signature),
      std::move(option_list),
      std::move(procedure_body));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCreateProcedureStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedCreateProcedureStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedCreateProcedureStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateProcedureStmt(this);
}

absl::Status ResolvedCreateProcedureStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreateProcedureStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("argument_name_list", ToStringCommaSeparated(argument_name_list_));
  }
  {
    fields->emplace_back("signature", ToStringVerbose(signature_));
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
  {
    fields->emplace_back("procedure_body", ToStringImpl(procedure_body_));
  }
}

absl::Status ResolvedCreateProcedureStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateProcedureStmt::argument_name_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateProcedureStmt::signature not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateProcedureStmt::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateProcedureStmt::procedure_body not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateProcedureStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateProcedureStmt::argument_name_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateProcedureStmt::signature is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateProcedureStmt::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateProcedureStmt::procedure_body is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreateProcedureStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
}

void ResolvedCreateProcedureStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedExecuteImmediateArgument::TYPE;

ResolvedExecuteImmediateArgument::~ResolvedExecuteImmediateArgument() {
}

absl::Status ResolvedExecuteImmediateArgument::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_execute_immediate_argument_node());
}

absl::Status ResolvedExecuteImmediateArgument::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedExecuteImmediateArgumentProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_name(name_);
  if (expression_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expression_->SaveTo(
        file_descriptor_set_map, proto->mutable_expression()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedExecuteImmediateArgument>> ResolvedExecuteImmediateArgument::RestoreFrom(
    const ResolvedExecuteImmediateArgumentProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string name =
      proto.name();
  std::unique_ptr<const ResolvedExpr> expression;
  if (proto.
  has_expression()) {
    ZETASQL_ASSIGN_OR_RETURN(expression,
                     ResolvedExpr::RestoreFrom(
                         proto.expression(), params));
  }
  auto node = MakeResolvedExecuteImmediateArgument(
      std::move(name),
      std::move(expression));

  return node;
}

void ResolvedExecuteImmediateArgument::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (expression_ != nullptr) {
    child_nodes->emplace_back(expression_.get());
  }
}

void ResolvedExecuteImmediateArgument::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (expression_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expression_));
    static_assert(sizeof(expression_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedExecuteImmediateArgument::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedExecuteImmediateArgument(this);
}

absl::Status ResolvedExecuteImmediateArgument::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (expression_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expression_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedExecuteImmediateArgument::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("name", ToStringImpl(name_));
  }
  if (expression_ != nullptr) {
    fields->emplace_back("expression", expression_.get());
  }
}

absl::Status ResolvedExecuteImmediateArgument::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedExecuteImmediateArgument::name not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedExecuteImmediateArgument::expression not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (expression_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expression_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedExecuteImmediateArgument::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedExecuteImmediateArgument::name is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedExecuteImmediateArgument::expression is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (expression_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expression_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedExecuteImmediateArgument::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (expression_ != nullptr) expression_->ClearFieldsAccessed();
}

void ResolvedExecuteImmediateArgument::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (expression_ != nullptr) expression_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedExecuteImmediateStmt::TYPE;

ResolvedExecuteImmediateStmt::~ResolvedExecuteImmediateStmt() {
}

absl::Status ResolvedExecuteImmediateStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_execute_immediate_stmt_node());
}

absl::Status ResolvedExecuteImmediateStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedExecuteImmediateStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (sql_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(sql_->SaveTo(
        file_descriptor_set_map, proto->mutable_sql()));
  }
  for (const auto& elem : into_identifier_list_) {
    proto->add_into_identifier_list(elem);
  }
  for (const auto& elem : using_argument_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_using_argument_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedExecuteImmediateStmt>> ResolvedExecuteImmediateStmt::RestoreFrom(
    const ResolvedExecuteImmediateStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> sql;
  if (proto.
  has_sql()) {
    ZETASQL_ASSIGN_OR_RETURN(sql,
                     ResolvedExpr::RestoreFrom(
                         proto.sql(), params));
  }
  std::vector<std::string> into_identifier_list;
  for (const auto& elem : proto.into_identifier_list()) {
    into_identifier_list.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedExecuteImmediateArgument>> using_argument_list;
  for (const auto& elem : proto.using_argument_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExecuteImmediateArgument> elem_restored,
                     ResolvedExecuteImmediateArgument::RestoreFrom(elem, params));
    using_argument_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedExecuteImmediateStmt(
      std::move(sql),
      std::move(into_identifier_list),
      std::move(using_argument_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedExecuteImmediateStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (sql_ != nullptr) {
    child_nodes->emplace_back(sql_.get());
  }
  for (const auto& elem : using_argument_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedExecuteImmediateStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (sql_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &sql_));
    static_assert(sizeof(sql_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : using_argument_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedExecuteImmediateStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedExecuteImmediateStmt(this);
}

absl::Status ResolvedExecuteImmediateStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (sql_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(sql_.get()->Accept(visitor));
  }
  for (const auto& elem : using_argument_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedExecuteImmediateStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (sql_ != nullptr) {
    fields->emplace_back("sql", sql_.get());
  }
  {
    fields->emplace_back("into_identifier_list", ToStringCommaSeparated(into_identifier_list_));
  }
  if (!using_argument_list_.empty()) {
    fields->emplace_back("using_argument_list", using_argument_list_);
  }
}

absl::Status ResolvedExecuteImmediateStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedExecuteImmediateStmt::sql not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedExecuteImmediateStmt::into_identifier_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedExecuteImmediateStmt::using_argument_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (sql_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          sql_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : using_argument_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedExecuteImmediateStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedExecuteImmediateStmt::sql is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedExecuteImmediateStmt::into_identifier_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedExecuteImmediateStmt::using_argument_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (sql_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(sql_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : using_argument_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedExecuteImmediateStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (sql_ != nullptr) sql_->ClearFieldsAccessed();
  for (const auto& it : using_argument_list_) it->ClearFieldsAccessed();
}

void ResolvedExecuteImmediateStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (sql_ != nullptr) sql_->MarkFieldsAccessed();
  for (const auto& it : using_argument_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAssignmentStmt::TYPE;

ResolvedAssignmentStmt::~ResolvedAssignmentStmt() {
}

absl::Status ResolvedAssignmentStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_assignment_stmt_node());
}

absl::Status ResolvedAssignmentStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAssignmentStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (target_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(target_->SaveTo(
        file_descriptor_set_map, proto->mutable_target()));
  }
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_expr()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAssignmentStmt>> ResolvedAssignmentStmt::RestoreFrom(
    const ResolvedAssignmentStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedExpr> target;
  if (proto.
  has_target()) {
    ZETASQL_ASSIGN_OR_RETURN(target,
                     ResolvedExpr::RestoreFrom(
                         proto.target(), params));
  }
  std::unique_ptr<const ResolvedExpr> expr;
  if (proto.
  has_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(expr,
                     ResolvedExpr::RestoreFrom(
                         proto.expr(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedAssignmentStmt(
      std::move(target),
      std::move(expr));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedAssignmentStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (target_ != nullptr) {
    child_nodes->emplace_back(target_.get());
  }
  if (expr_ != nullptr) {
    child_nodes->emplace_back(expr_.get());
  }
}

void ResolvedAssignmentStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (target_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &target_));
    static_assert(sizeof(target_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &expr_));
    static_assert(sizeof(expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedAssignmentStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAssignmentStmt(this);
}

absl::Status ResolvedAssignmentStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (target_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(target_.get()->Accept(visitor));
  }
  if (expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(expr_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAssignmentStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (target_ != nullptr) {
    fields->emplace_back("target", target_.get());
  }
  if (expr_ != nullptr) {
    fields->emplace_back("expr", expr_.get());
  }
}

absl::Status ResolvedAssignmentStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAssignmentStmt::target not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAssignmentStmt::expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (target_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          target_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          expr_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAssignmentStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAssignmentStmt::target is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAssignmentStmt::expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (target_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(target_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(expr_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAssignmentStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (target_ != nullptr) target_->ClearFieldsAccessed();
  if (expr_ != nullptr) expr_->ClearFieldsAccessed();
}

void ResolvedAssignmentStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (target_ != nullptr) target_->MarkFieldsAccessed();
  if (expr_ != nullptr) expr_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCreateEntityStmt::TYPE;

ResolvedCreateEntityStmt::~ResolvedCreateEntityStmt() {
}

absl::Status ResolvedCreateEntityStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedCreateStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_create_entity_stmt_node());
}

absl::Status ResolvedCreateEntityStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCreateEntityStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_entity_type(entity_type_);
  proto->set_entity_body_json(entity_body_json_);
  proto->set_entity_body_text(entity_body_text_);
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCreateEntityStmt>> ResolvedCreateEntityStmt::RestoreFrom(
    const ResolvedCreateEntityStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string entity_type =
      proto.entity_type();
  std::string entity_body_json =
      proto.entity_body_json();
  std::string entity_body_text =
      proto.entity_body_text();
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  CreateScope create_scope =
      proto.parent().create_scope();
  CreateMode create_mode =
      proto.parent().create_mode();
  auto node = MakeResolvedCreateEntityStmt(
      std::move(name_path),
      std::move(create_scope),
      std::move(create_mode),
      std::move(entity_type),
      std::move(entity_body_json),
      std::move(entity_body_text),
      std::move(option_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCreateEntityStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedCreateEntityStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedCreateEntityStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCreateEntityStmt(this);
}

absl::Status ResolvedCreateEntityStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCreateEntityStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("entity_type", ToStringImpl(entity_type_));
  }
  if (!IsDefaultValue(entity_body_json_)) {
    fields->emplace_back("entity_body_json", ToStringImpl(entity_body_json_));
  }
  if (!IsDefaultValue(entity_body_text_)) {
    fields->emplace_back("entity_body_text", ToStringImpl(entity_body_text_));
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
}

absl::Status ResolvedCreateEntityStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateEntityStmt::entity_type not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(entity_body_json_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateEntityStmt::entity_body_json not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0 &&
      !IsDefaultValue(entity_body_text_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateEntityStmt::entity_body_text not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCreateEntityStmt::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCreateEntityStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateEntityStmt::entity_type is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateEntityStmt::entity_body_json is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateEntityStmt::entity_body_text is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCreateEntityStmt::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCreateEntityStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
}

void ResolvedCreateEntityStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAlterEntityStmt::TYPE;

ResolvedAlterEntityStmt::~ResolvedAlterEntityStmt() {
}

absl::Status ResolvedAlterEntityStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedAlterObjectStmtProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_alter_entity_stmt_node());
}

absl::Status ResolvedAlterEntityStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAlterEntityStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_entity_type(entity_type_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAlterEntityStmt>> ResolvedAlterEntityStmt::RestoreFrom(
    const ResolvedAlterEntityStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::string entity_type =
      proto.entity_type();
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::string> name_path;
  for (const auto& elem : proto.parent().name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedAlterAction>> alter_action_list;
  for (const auto& elem : proto.parent().alter_action_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedAlterAction> elem_restored,
                     ResolvedAlterAction::RestoreFrom(elem, params));
    alter_action_list.push_back(std::move(elem_restored));
  }
  bool is_if_exists =
      proto.parent().is_if_exists();
  auto node = MakeResolvedAlterEntityStmt(
      std::move(name_path),
      std::move(alter_action_list),
      std::move(is_if_exists),
      std::move(entity_type));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedAlterEntityStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedAlterEntityStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedAlterEntityStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAlterEntityStmt(this);
}

absl::Status ResolvedAlterEntityStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedAlterEntityStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("entity_type", ToStringImpl(entity_type_));
  }
}

absl::Status ResolvedAlterEntityStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAlterEntityStmt::entity_type not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedAlterEntityStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAlterEntityStmt::entity_type is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedAlterEntityStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedAlterEntityStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedPivotColumn::TYPE;

ResolvedPivotColumn::~ResolvedPivotColumn() {
}

absl::Status ResolvedPivotColumn::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_pivot_column_node());
}

absl::Status ResolvedPivotColumn::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedPivotColumnProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      column_, file_descriptor_set_map,
      proto->mutable_column()));
  proto->set_pivot_expr_index(pivot_expr_index_);
  proto->set_pivot_value_index(pivot_value_index_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedPivotColumn>> ResolvedPivotColumn::RestoreFrom(
    const ResolvedPivotColumnProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto column,
                   RestoreFromImpl<ResolvedColumn>(
                       proto.column(),
                       params));
  int pivot_expr_index =
      proto.pivot_expr_index();
  int pivot_value_index =
      proto.pivot_value_index();
  auto node = MakeResolvedPivotColumn(
      std::move(column),
      std::move(pivot_expr_index),
      std::move(pivot_value_index));

  return node;
}

void ResolvedPivotColumn::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedPivotColumn::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedPivotColumn::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedPivotColumn(this);
}

absl::Status ResolvedPivotColumn::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedPivotColumn::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("column", ToStringImpl(column_));
  }
  {
    fields->emplace_back("pivot_expr_index", ToStringImpl(pivot_expr_index_));
  }
  {
    fields->emplace_back("pivot_value_index", ToStringImpl(pivot_value_index_));
  }
}

absl::Status ResolvedPivotColumn::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedPivotColumn::column not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedPivotColumn::pivot_expr_index not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedPivotColumn::pivot_value_index not accessed)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedPivotColumn::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedPivotColumn::column is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedPivotColumn::pivot_expr_index is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedPivotColumn::pivot_value_index is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedPivotColumn::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedPivotColumn::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedPivotScan::TYPE;

ResolvedPivotScan::~ResolvedPivotScan() {
}

absl::Status ResolvedPivotScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_pivot_scan_node());
}

absl::Status ResolvedPivotScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedPivotScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_input_scan()));
  }
  for (const auto& elem : group_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_group_by_list()));
  }
  for (const auto& elem : pivot_expr_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_pivot_expr_list()));
  }
  if (for_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(for_expr_->SaveTo(
        file_descriptor_set_map, proto->mutable_for_expr()));
  }
  for (const auto& elem : pivot_value_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_pivot_value_list()));
  }
  for (const auto& elem : pivot_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_pivot_column_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedPivotScan>> ResolvedPivotScan::RestoreFrom(
    const ResolvedPivotScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedScan> input_scan;
  if (proto.
  has_input_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(input_scan,
                     ResolvedScan::RestoreFrom(
                         proto.input_scan(), params));
  }
  std::vector<std::unique_ptr<const ResolvedComputedColumn>> group_by_list;
  for (const auto& elem : proto.group_by_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedComputedColumn> elem_restored,
                     ResolvedComputedColumn::RestoreFrom(elem, params));
    group_by_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedExpr>> pivot_expr_list;
  for (const auto& elem : proto.pivot_expr_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    pivot_expr_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedExpr> for_expr;
  if (proto.
  has_for_expr()) {
    ZETASQL_ASSIGN_OR_RETURN(for_expr,
                     ResolvedExpr::RestoreFrom(
                         proto.for_expr(), params));
  }
  std::vector<std::unique_ptr<const ResolvedExpr>> pivot_value_list;
  for (const auto& elem : proto.pivot_value_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    pivot_value_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedPivotColumn>> pivot_column_list;
  for (const auto& elem : proto.pivot_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedPivotColumn> elem_restored,
                     ResolvedPivotColumn::RestoreFrom(elem, params));
    pivot_column_list.push_back(std::move(elem_restored));
  }
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedPivotScan(
      std::move(column_list),
      std::move(input_scan),
      std::move(group_by_list),
      std::move(pivot_expr_list),
      std::move(for_expr),
      std::move(pivot_value_list),
      std::move(pivot_column_list));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

void ResolvedPivotScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (input_scan_ != nullptr) {
    child_nodes->emplace_back(input_scan_.get());
  }
  for (const auto& elem : group_by_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : pivot_expr_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (for_expr_ != nullptr) {
    child_nodes->emplace_back(for_expr_.get());
  }
  for (const auto& elem : pivot_value_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : pivot_column_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedPivotScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (input_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &input_scan_));
    static_assert(sizeof(input_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : group_by_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : pivot_expr_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (for_expr_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &for_expr_));
    static_assert(sizeof(for_expr_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : pivot_value_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : pivot_column_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedPivotScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedPivotScan(this);
}

absl::Status ResolvedPivotScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_.get()->Accept(visitor));
  }
  for (const auto& elem : group_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : pivot_expr_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (for_expr_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(for_expr_.get()->Accept(visitor));
  }
  for (const auto& elem : pivot_value_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : pivot_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedPivotScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (input_scan_ != nullptr) {
    fields->emplace_back("input_scan", input_scan_.get());
  }
  if (!group_by_list_.empty()) {
    fields->emplace_back("group_by_list", group_by_list_);
  }
  if (!pivot_expr_list_.empty()) {
    fields->emplace_back("pivot_expr_list", pivot_expr_list_);
  }
  if (for_expr_ != nullptr) {
    fields->emplace_back("for_expr", for_expr_.get());
  }
  if (!pivot_value_list_.empty()) {
    fields->emplace_back("pivot_value_list", pivot_value_list_);
  }
  if (!pivot_column_list_.empty()) {
    fields->emplace_back("pivot_column_list", pivot_column_list_);
  }
}

absl::Status ResolvedPivotScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedPivotScan::input_scan not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedPivotScan::group_by_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedPivotScan::pivot_expr_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedPivotScan::for_expr not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedPivotScan::pivot_value_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedPivotScan::pivot_column_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          input_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : group_by_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : pivot_expr_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (for_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          for_expr_.get(), root));
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    for (const auto& it : pivot_value_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : pivot_column_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedPivotScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedPivotScan::input_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedPivotScan::group_by_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedPivotScan::pivot_expr_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedPivotScan::for_expr is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedPivotScan::pivot_value_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedPivotScan::pivot_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(input_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : group_by_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : pivot_expr_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    if (for_expr_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(for_expr_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    for (const auto& it : pivot_value_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : pivot_column_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedPivotScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (input_scan_ != nullptr) input_scan_->ClearFieldsAccessed();
  for (const auto& it : group_by_list_) it->ClearFieldsAccessed();
  for (const auto& it : pivot_expr_list_) it->ClearFieldsAccessed();
  if (for_expr_ != nullptr) for_expr_->ClearFieldsAccessed();
  for (const auto& it : pivot_value_list_) it->ClearFieldsAccessed();
  for (const auto& it : pivot_column_list_) it->ClearFieldsAccessed();
}

void ResolvedPivotScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (input_scan_ != nullptr) input_scan_->MarkFieldsAccessed();
  for (const auto& it : group_by_list_) it->MarkFieldsAccessed();
  for (const auto& it : pivot_expr_list_) it->MarkFieldsAccessed();
  if (for_expr_ != nullptr) for_expr_->MarkFieldsAccessed();
  for (const auto& it : pivot_value_list_) it->MarkFieldsAccessed();
  for (const auto& it : pivot_column_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedReturningClause::TYPE;

ResolvedReturningClause::~ResolvedReturningClause() {
}

absl::Status ResolvedReturningClause::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_returning_clause_node());
}

absl::Status ResolvedReturningClause::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedReturningClauseProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_output_column_list()));
  }
  if (action_column_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(action_column_->SaveTo(
        file_descriptor_set_map, proto->mutable_action_column()));
  }
  for (const auto& elem : expr_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_expr_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedReturningClause>> ResolvedReturningClause::RestoreFrom(
    const ResolvedReturningClauseProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOutputColumn>> output_column_list;
  for (const auto& elem : proto.output_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOutputColumn> elem_restored,
                     ResolvedOutputColumn::RestoreFrom(elem, params));
    output_column_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedColumnHolder> action_column;
  if (proto.
  has_action_column()) {
    ZETASQL_ASSIGN_OR_RETURN(action_column,
                     ResolvedColumnHolder::RestoreFrom(
                         proto.action_column(), params));
  }
  std::vector<std::unique_ptr<const ResolvedComputedColumn>> expr_list;
  for (const auto& elem : proto.expr_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedComputedColumn> elem_restored,
                     ResolvedComputedColumn::RestoreFrom(elem, params));
    expr_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedReturningClause(
      std::move(output_column_list),
      std::move(action_column),
      std::move(expr_list));

  return node;
}

void ResolvedReturningClause::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : output_column_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (action_column_ != nullptr) {
    child_nodes->emplace_back(action_column_.get());
  }
  for (const auto& elem : expr_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedReturningClause::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : output_column_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (action_column_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &action_column_));
    static_assert(sizeof(action_column_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : expr_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedReturningClause::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedReturningClause(this);
}

absl::Status ResolvedReturningClause::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (action_column_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(action_column_.get()->Accept(visitor));
  }
  for (const auto& elem : expr_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedReturningClause::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!output_column_list_.empty()) {
    fields->emplace_back("output_column_list", output_column_list_);
  }
  if (action_column_ != nullptr) {
    fields->emplace_back("action_column", action_column_.get());
  }
  if (!expr_list_.empty()) {
    fields->emplace_back("expr_list", expr_list_);
  }
}

absl::Status ResolvedReturningClause::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedReturningClause::output_column_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedReturningClause::action_column not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedReturningClause::expr_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (action_column_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          action_column_.get(), root));
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : expr_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedReturningClause::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedReturningClause::output_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedReturningClause::action_column is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedReturningClause::expr_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (action_column_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(action_column_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : expr_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedReturningClause::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : output_column_list_) it->ClearFieldsAccessed();
  if (action_column_ != nullptr) action_column_->ClearFieldsAccessed();
  for (const auto& it : expr_list_) it->ClearFieldsAccessed();
}

void ResolvedReturningClause::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : output_column_list_) it->MarkFieldsAccessed();
  if (action_column_ != nullptr) action_column_->MarkFieldsAccessed();
  for (const auto& it : expr_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedUnpivotArg::TYPE;

ResolvedUnpivotArg::~ResolvedUnpivotArg() {
}

absl::Status ResolvedUnpivotArg::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_unpivot_arg_node());
}

absl::Status ResolvedUnpivotArg::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedUnpivotArgProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_column_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedUnpivotArg>> ResolvedUnpivotArg::RestoreFrom(
    const ResolvedUnpivotArgProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedColumnRef>> column_list;
  for (const auto& elem : proto.column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedColumnRef> elem_restored,
                     ResolvedColumnRef::RestoreFrom(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedUnpivotArg(
      std::move(column_list));

  return node;
}

void ResolvedUnpivotArg::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : column_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedUnpivotArg::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : column_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedUnpivotArg::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedUnpivotArg(this);
}

absl::Status ResolvedUnpivotArg::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedUnpivotArg::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!column_list_.empty()) {
    fields->emplace_back("column_list", column_list_);
  }
}

absl::Status ResolvedUnpivotArg::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUnpivotArg::column_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : column_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedUnpivotArg::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUnpivotArg::column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : column_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedUnpivotArg::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : column_list_) it->ClearFieldsAccessed();
}

void ResolvedUnpivotArg::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : column_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedUnpivotScan::TYPE;

ResolvedUnpivotScan::~ResolvedUnpivotScan() {
}

absl::Status ResolvedUnpivotScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedScanProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_unpivot_scan_node());
}

absl::Status ResolvedUnpivotScan::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedUnpivotScanProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_->SaveTo(
        file_descriptor_set_map, proto->mutable_input_scan()));
  }
  for (const auto& elem : value_column_list_) {
    ZETASQL_RETURN_IF_ERROR(SaveToImpl(
        elem, file_descriptor_set_map, proto->add_value_column_list()));
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      label_column_, file_descriptor_set_map,
      proto->mutable_label_column()));
  for (const auto& elem : label_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_label_list()));
  }
  for (const auto& elem : unpivot_arg_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_unpivot_arg_list()));
  }
  for (const auto& elem : projected_input_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_projected_input_column_list()));
  }
  proto->set_include_nulls(include_nulls_);
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedUnpivotScan>> ResolvedUnpivotScan::RestoreFrom(
    const ResolvedUnpivotScanProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedScan> input_scan;
  if (proto.
  has_input_scan()) {
    ZETASQL_ASSIGN_OR_RETURN(input_scan,
                     ResolvedScan::RestoreFrom(
                         proto.input_scan(), params));
  }
  std::vector<ResolvedColumn> value_column_list;
  for (const auto& elem : proto.value_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    value_column_list.push_back(std::move(elem_restored));
  }
  ZETASQL_ASSIGN_OR_RETURN(auto label_column,
                   RestoreFromImpl<ResolvedColumn>(
                       proto.label_column(),
                       params));
  std::vector<std::unique_ptr<const ResolvedLiteral>> label_list;
  for (const auto& elem : proto.label_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedLiteral> elem_restored,
                     ResolvedLiteral::RestoreFrom(elem, params));
    label_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedUnpivotArg>> unpivot_arg_list;
  for (const auto& elem : proto.unpivot_arg_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedUnpivotArg> elem_restored,
                     ResolvedUnpivotArg::RestoreFrom(elem, params));
    unpivot_arg_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedComputedColumn>> projected_input_column_list;
  for (const auto& elem : proto.projected_input_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedComputedColumn> elem_restored,
                     ResolvedComputedColumn::RestoreFrom(elem, params));
    projected_input_column_list.push_back(std::move(elem_restored));
  }
  bool include_nulls =
      proto.include_nulls();
  std::vector<ResolvedColumn> column_list;
  for (const auto& elem : proto.parent().column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  bool is_ordered =
      proto.parent().is_ordered();
  auto node = MakeResolvedUnpivotScan(
      std::move(column_list),
      std::move(input_scan),
      std::move(value_column_list),
      std::move(label_column),
      std::move(label_list),
      std::move(unpivot_arg_list),
      std::move(projected_input_column_list),
      std::move(include_nulls));

  node->set_hint_list(std::move(hint_list));
  node->set_is_ordered(std::move(is_ordered));
  return node;
}

void ResolvedUnpivotScan::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (input_scan_ != nullptr) {
    child_nodes->emplace_back(input_scan_.get());
  }
  for (const auto& elem : label_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : unpivot_arg_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : projected_input_column_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedUnpivotScan::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (input_scan_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &input_scan_));
    static_assert(sizeof(input_scan_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : label_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : unpivot_arg_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : projected_input_column_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedUnpivotScan::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedUnpivotScan(this);
}

absl::Status ResolvedUnpivotScan::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (input_scan_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(input_scan_.get()->Accept(visitor));
  }
  for (const auto& elem : label_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : unpivot_arg_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : projected_input_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedUnpivotScan::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (input_scan_ != nullptr) {
    fields->emplace_back("input_scan", input_scan_.get());
  }
  {
    fields->emplace_back("value_column_list", ToStringImpl(value_column_list_));
  }
  {
    fields->emplace_back("label_column", ToStringImpl(label_column_));
  }
  if (!label_list_.empty()) {
    fields->emplace_back("label_list", label_list_);
  }
  if (!unpivot_arg_list_.empty()) {
    fields->emplace_back("unpivot_arg_list", unpivot_arg_list_);
  }
  if (!projected_input_column_list_.empty()) {
    fields->emplace_back("projected_input_column_list", projected_input_column_list_);
  }
  {
    fields->emplace_back("include_nulls", ToStringImpl(include_nulls_));
  }
}

absl::Status ResolvedUnpivotScan::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUnpivotScan::input_scan not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUnpivotScan::value_column_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUnpivotScan::label_column not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUnpivotScan::label_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<4)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUnpivotScan::unpivot_arg_list not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<6)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedUnpivotScan::include_nulls not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          input_scan_.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : label_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    for (const auto& it : unpivot_arg_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : projected_input_column_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedUnpivotScan::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUnpivotScan::input_scan is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUnpivotScan::value_column_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUnpivotScan::label_column is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUnpivotScan::label_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<4)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUnpivotScan::unpivot_arg_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<6)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedUnpivotScan::include_nulls is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (input_scan_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(input_scan_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : label_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<4)) != 0) {
    for (const auto& it : unpivot_arg_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    for (const auto& it : projected_input_column_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedUnpivotScan::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (input_scan_ != nullptr) input_scan_->ClearFieldsAccessed();
  for (const auto& it : label_list_) it->ClearFieldsAccessed();
  for (const auto& it : unpivot_arg_list_) it->ClearFieldsAccessed();
  for (const auto& it : projected_input_column_list_) it->ClearFieldsAccessed();
}

void ResolvedUnpivotScan::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (input_scan_ != nullptr) input_scan_->MarkFieldsAccessed();
  for (const auto& it : label_list_) it->MarkFieldsAccessed();
  for (const auto& it : unpivot_arg_list_) it->MarkFieldsAccessed();
  for (const auto& it : projected_input_column_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedCloneDataStmt::TYPE;

ResolvedCloneDataStmt::~ResolvedCloneDataStmt() {
}

absl::Status ResolvedCloneDataStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_clone_data_stmt_node());
}

absl::Status ResolvedCloneDataStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCloneDataStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  if (target_table_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(target_table_->SaveTo(
        file_descriptor_set_map, proto->mutable_target_table()));
  }
  if (clone_from_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(clone_from_->SaveTo(
        file_descriptor_set_map, proto->mutable_clone_from()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedCloneDataStmt>> ResolvedCloneDataStmt::RestoreFrom(
    const ResolvedCloneDataStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::unique_ptr<const ResolvedTableScan> target_table;
  if (proto.
  has_target_table()) {
    ZETASQL_ASSIGN_OR_RETURN(target_table,
                     ResolvedTableScan::RestoreFrom(
                         proto.target_table(), params));
  }
  std::unique_ptr<const ResolvedScan> clone_from;
  if (proto.
  has_clone_from()) {
    ZETASQL_ASSIGN_OR_RETURN(clone_from,
                     ResolvedScan::RestoreFrom(
                         proto.clone_from(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedCloneDataStmt(
      std::move(target_table),
      std::move(clone_from));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedCloneDataStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  if (target_table_ != nullptr) {
    child_nodes->emplace_back(target_table_.get());
  }
  if (clone_from_ != nullptr) {
    child_nodes->emplace_back(clone_from_.get());
  }
}

void ResolvedCloneDataStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  if (target_table_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &target_table_));
    static_assert(sizeof(target_table_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (clone_from_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &clone_from_));
    static_assert(sizeof(clone_from_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
}

absl::Status ResolvedCloneDataStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedCloneDataStmt(this);
}

absl::Status ResolvedCloneDataStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  if (target_table_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(target_table_.get()->Accept(visitor));
  }
  if (clone_from_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(clone_from_.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedCloneDataStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (target_table_ != nullptr) {
    fields->emplace_back("target_table", target_table_.get());
  }
  if (clone_from_ != nullptr) {
    fields->emplace_back("clone_from", clone_from_.get());
  }
}

absl::Status ResolvedCloneDataStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCloneDataStmt::target_table not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedCloneDataStmt::clone_from not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (target_table_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          target_table_.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (clone_from_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          clone_from_.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedCloneDataStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCloneDataStmt::target_table is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedCloneDataStmt::clone_from is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    if (target_table_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(target_table_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    if (clone_from_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(clone_from_->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedCloneDataStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  if (target_table_ != nullptr) target_table_->ClearFieldsAccessed();
  if (clone_from_ != nullptr) clone_from_->ClearFieldsAccessed();
}

void ResolvedCloneDataStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  if (target_table_ != nullptr) target_table_->MarkFieldsAccessed();
  if (clone_from_ != nullptr) clone_from_->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedTableAndColumnInfo::TYPE;

ResolvedTableAndColumnInfo::~ResolvedTableAndColumnInfo() {
}

absl::Status ResolvedTableAndColumnInfo::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedArgumentProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_table_and_column_info_node());
}

absl::Status ResolvedTableAndColumnInfo::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedTableAndColumnInfoProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      table_, file_descriptor_set_map,
      proto->mutable_table()));
  for (const auto& elem : column_index_list_) {
    proto->add_column_index_list(elem);
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedTableAndColumnInfo>> ResolvedTableAndColumnInfo::RestoreFrom(
    const ResolvedTableAndColumnInfoProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(auto table,
                   RestoreFromImpl<const Table*>(
                       proto.table(),
                       params));
  std::vector<int> column_index_list;
  for (const auto& elem : proto.column_index_list()) {
    column_index_list.push_back(elem);
  }
  auto node = MakeResolvedTableAndColumnInfo(
      std::move(table));

  node->set_column_index_list(std::move(column_index_list));
  return node;
}

void ResolvedTableAndColumnInfo::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
}

void ResolvedTableAndColumnInfo::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
}

absl::Status ResolvedTableAndColumnInfo::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedTableAndColumnInfo(this);
}

absl::Status ResolvedTableAndColumnInfo::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  return absl::OkStatus();
}

void ResolvedTableAndColumnInfo::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!IsDefaultValue(table_)) {
    fields->emplace_back("table", ToStringImpl(table_));
  }
  if (!IsDefaultValue(column_index_list_)) {
    fields->emplace_back("column_index_list", ToStringCommaSeparated(column_index_list_));
  }
}

absl::Status ResolvedTableAndColumnInfo::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(table_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedTableAndColumnInfo::table not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(column_index_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedTableAndColumnInfo::column_index_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  return absl::OkStatus();
}

absl::Status ResolvedTableAndColumnInfo::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedTableAndColumnInfo::table is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedTableAndColumnInfo::column_index_list is accessed, but shouldn't be)";
  }
  return absl::OkStatus();
}

void ResolvedTableAndColumnInfo::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
}

void ResolvedTableAndColumnInfo::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
}

const ResolvedNodeKind ResolvedAnalyzeStmt::TYPE;

ResolvedAnalyzeStmt::~ResolvedAnalyzeStmt() {
}

absl::Status ResolvedAnalyzeStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_analyze_stmt_node());
}

absl::Status ResolvedAnalyzeStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAnalyzeStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  for (const auto& elem : table_and_column_index_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_table_and_column_index_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAnalyzeStmt>> ResolvedAnalyzeStmt::RestoreFrom(
    const ResolvedAnalyzeStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedTableAndColumnInfo>> table_and_column_index_list;
  for (const auto& elem : proto.table_and_column_index_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedTableAndColumnInfo> elem_restored,
                     ResolvedTableAndColumnInfo::RestoreFrom(elem, params));
    table_and_column_index_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedAnalyzeStmt(
      std::move(option_list),
      std::move(table_and_column_index_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedAnalyzeStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : table_and_column_index_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedAnalyzeStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : table_and_column_index_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedAnalyzeStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAnalyzeStmt(this);
}

absl::Status ResolvedAnalyzeStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : table_and_column_index_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAnalyzeStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
  if (!table_and_column_index_list_.empty()) {
    fields->emplace_back("table_and_column_index_list", table_and_column_index_list_);
  }
}

absl::Status ResolvedAnalyzeStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAnalyzeStmt::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(table_and_column_index_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAnalyzeStmt::table_and_column_index_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : table_and_column_index_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAnalyzeStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAnalyzeStmt::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAnalyzeStmt::table_and_column_index_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<0)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<1)) != 0) {
    for (const auto& it : table_and_column_index_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAnalyzeStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
  for (const auto& it : table_and_column_index_list_) it->ClearFieldsAccessed();
}

void ResolvedAnalyzeStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
  for (const auto& it : table_and_column_index_list_) it->MarkFieldsAccessed();
}

const ResolvedNodeKind ResolvedAuxLoadDataStmt::TYPE;

const ResolvedAuxLoadDataStmt::InsertionMode ResolvedAuxLoadDataStmt::NONE;
const ResolvedAuxLoadDataStmt::InsertionMode ResolvedAuxLoadDataStmt::APPEND;
const ResolvedAuxLoadDataStmt::InsertionMode ResolvedAuxLoadDataStmt::OVERWRITE;

ResolvedAuxLoadDataStmt::~ResolvedAuxLoadDataStmt() {
}

absl::Status ResolvedAuxLoadDataStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    AnyResolvedStatementProto* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_resolved_aux_load_data_stmt_node());
}

absl::Status ResolvedAuxLoadDataStmt::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedAuxLoadDataStmtProto* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSize() == 0) {
    proto->clear_parent();
  }
  proto->set_insertion_mode(insertion_mode_);
  for (const auto& elem : name_path_) {
    proto->add_name_path(elem);
  }
  for (const auto& elem : output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_output_column_list()));
  }
  for (const auto& elem : column_definition_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_column_definition_list()));
  }
  for (const auto& elem : pseudo_column_list_) {
    ZETASQL_RETURN_IF_ERROR(SaveToImpl(
        elem, file_descriptor_set_map, proto->add_pseudo_column_list()));
  }
  if (primary_key_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(primary_key_->SaveTo(
        file_descriptor_set_map, proto->mutable_primary_key()));
  }
  for (const auto& elem : foreign_key_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_foreign_key_list()));
  }
  for (const auto& elem : check_constraint_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_check_constraint_list()));
  }
  for (const auto& elem : partition_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_partition_by_list()));
  }
  for (const auto& elem : cluster_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_cluster_by_list()));
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_option_list()));
  }
  if (with_partition_columns_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(with_partition_columns_->SaveTo(
        file_descriptor_set_map, proto->mutable_with_partition_columns()));
  }
  if (connection_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(connection_->SaveTo(
        file_descriptor_set_map, proto->mutable_connection()));
  }
  for (const auto& elem : from_files_option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_from_files_option_list()));
  }
  return absl::OkStatus();
}

absl::StatusOr<std::unique_ptr<ResolvedAuxLoadDataStmt>> ResolvedAuxLoadDataStmt::RestoreFrom(
    const ResolvedAuxLoadDataStmtProto& proto,
    const ResolvedNode::RestoreParams& params) {
  InsertionMode insertion_mode =
      proto.insertion_mode();
  std::vector<std::string> name_path;
  for (const auto& elem : proto.name_path()) {
    name_path.push_back(elem);
  }
  std::vector<std::unique_ptr<const ResolvedOutputColumn>> output_column_list;
  for (const auto& elem : proto.output_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOutputColumn> elem_restored,
                     ResolvedOutputColumn::RestoreFrom(elem, params));
    output_column_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedColumnDefinition>> column_definition_list;
  for (const auto& elem : proto.column_definition_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedColumnDefinition> elem_restored,
                     ResolvedColumnDefinition::RestoreFrom(elem, params));
    column_definition_list.push_back(std::move(elem_restored));
  }
  std::vector<ResolvedColumn> pseudo_column_list;
  for (const auto& elem : proto.pseudo_column_list()) {
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<std::vector<ResolvedColumn>::value_type>(elem, params));
    pseudo_column_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedPrimaryKey> primary_key;
  if (proto.
  has_primary_key()) {
    ZETASQL_ASSIGN_OR_RETURN(primary_key,
                     ResolvedPrimaryKey::RestoreFrom(
                         proto.primary_key(), params));
  }
  std::vector<std::unique_ptr<const ResolvedForeignKey>> foreign_key_list;
  for (const auto& elem : proto.foreign_key_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedForeignKey> elem_restored,
                     ResolvedForeignKey::RestoreFrom(elem, params));
    foreign_key_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedCheckConstraint>> check_constraint_list;
  for (const auto& elem : proto.check_constraint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedCheckConstraint> elem_restored,
                     ResolvedCheckConstraint::RestoreFrom(elem, params));
    check_constraint_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedExpr>> partition_by_list;
  for (const auto& elem : proto.partition_by_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    partition_by_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedExpr>> cluster_by_list;
  for (const auto& elem : proto.cluster_by_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedExpr> elem_restored,
                     ResolvedExpr::RestoreFrom(elem, params));
    cluster_by_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> option_list;
  for (const auto& elem : proto.option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    option_list.push_back(std::move(elem_restored));
  }
  std::unique_ptr<const ResolvedWithPartitionColumns> with_partition_columns;
  if (proto.
  has_with_partition_columns()) {
    ZETASQL_ASSIGN_OR_RETURN(with_partition_columns,
                     ResolvedWithPartitionColumns::RestoreFrom(
                         proto.with_partition_columns(), params));
  }
  std::unique_ptr<const ResolvedConnection> connection;
  if (proto.
  has_connection()) {
    ZETASQL_ASSIGN_OR_RETURN(connection,
                     ResolvedConnection::RestoreFrom(
                         proto.connection(), params));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> from_files_option_list;
  for (const auto& elem : proto.from_files_option_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    from_files_option_list.push_back(std::move(elem_restored));
  }
  std::vector<std::unique_ptr<const ResolvedOption>> hint_list;
  for (const auto& elem : proto.parent().hint_list()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const ResolvedOption> elem_restored,
                     ResolvedOption::RestoreFrom(elem, params));
    hint_list.push_back(std::move(elem_restored));
  }
  auto node = MakeResolvedAuxLoadDataStmt(
      std::move(insertion_mode),
      std::move(name_path),
      std::move(output_column_list),
      std::move(column_definition_list),
      std::move(pseudo_column_list),
      std::move(primary_key),
      std::move(foreign_key_list),
      std::move(check_constraint_list),
      std::move(partition_by_list),
      std::move(cluster_by_list),
      std::move(option_list),
      std::move(with_partition_columns),
      std::move(connection),
      std::move(from_files_option_list));

  node->set_hint_list(std::move(hint_list));
  return node;
}

void ResolvedAuxLoadDataStmt::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
  for (const auto& elem : output_column_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : column_definition_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (primary_key_ != nullptr) {
    child_nodes->emplace_back(primary_key_.get());
  }
  for (const auto& elem : foreign_key_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : check_constraint_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : partition_by_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : cluster_by_list_) {
    child_nodes->emplace_back(elem.get());
  }
  for (const auto& elem : option_list_) {
    child_nodes->emplace_back(elem.get());
  }
  if (with_partition_columns_ != nullptr) {
    child_nodes->emplace_back(with_partition_columns_.get());
  }
  if (connection_ != nullptr) {
    child_nodes->emplace_back(connection_.get());
  }
  for (const auto& elem : from_files_option_list_) {
    child_nodes->emplace_back(elem.get());
  }
}

void ResolvedAuxLoadDataStmt::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
  for (auto& elem : output_column_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : column_definition_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (primary_key_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &primary_key_));
    static_assert(sizeof(primary_key_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : foreign_key_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : check_constraint_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : partition_by_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : cluster_by_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  for (auto& elem : option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  if (with_partition_columns_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &with_partition_columns_));
    static_assert(sizeof(with_partition_columns_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  if (connection_ != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &connection_));
    static_assert(sizeof(connection_) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  for (auto& elem : from_files_option_list_) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
}

absl::Status ResolvedAuxLoadDataStmt::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->VisitResolvedAuxLoadDataStmt(this);
}

absl::Status ResolvedAuxLoadDataStmt::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
  for (const auto& elem : output_column_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : column_definition_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (primary_key_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(primary_key_.get()->Accept(visitor));
  }
  for (const auto& elem : foreign_key_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : check_constraint_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : partition_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : cluster_by_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  for (const auto& elem : option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  if (with_partition_columns_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(with_partition_columns_.get()->Accept(visitor));
  }
  if (connection_ != nullptr) {
    ZETASQL_RETURN_IF_ERROR(connection_.get()->Accept(visitor));
  }
  for (const auto& elem : from_files_option_list_) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  return absl::OkStatus();
}

void ResolvedAuxLoadDataStmt::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
  {
    fields->emplace_back("insertion_mode", ToStringImpl(insertion_mode_));
  }
  if (!IsDefaultValue(name_path_)) {
    fields->emplace_back("name_path", ToStringImpl(name_path_));
  }
  if (!output_column_list_.empty()) {
    fields->emplace_back("output_column_list", output_column_list_);
  }
  if (!column_definition_list_.empty()) {
    fields->emplace_back("column_definition_list", column_definition_list_);
  }
  if (!IsDefaultValue(pseudo_column_list_)) {
    fields->emplace_back("pseudo_column_list", ToStringImpl(pseudo_column_list_));
  }
  if (primary_key_ != nullptr) {
    fields->emplace_back("primary_key", primary_key_.get());
  }
  if (!foreign_key_list_.empty()) {
    fields->emplace_back("foreign_key_list", foreign_key_list_);
  }
  if (!check_constraint_list_.empty()) {
    fields->emplace_back("check_constraint_list", check_constraint_list_);
  }
  if (!partition_by_list_.empty()) {
    fields->emplace_back("partition_by_list", partition_by_list_);
  }
  if (!cluster_by_list_.empty()) {
    fields->emplace_back("cluster_by_list", cluster_by_list_);
  }
  if (!option_list_.empty()) {
    fields->emplace_back("option_list", option_list_);
  }
  if (with_partition_columns_ != nullptr) {
    fields->emplace_back("with_partition_columns", with_partition_columns_.get());
  }
  if (connection_ != nullptr) {
    fields->emplace_back("connection", connection_.get());
  }
  if (!from_files_option_list_.empty()) {
    fields->emplace_back("from_files_option_list", from_files_option_list_);
  }
}

absl::Status ResolvedAuxLoadDataStmt::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  if ((accessed_ & (1<<0)) == 0) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAuxLoadDataStmt::insertion_mode not accessed)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<1)) == 0 &&
      !IsDefaultValue(name_path_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAuxLoadDataStmt::name_path not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<3)) == 0 &&
      !IsDefaultValue(column_definition_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAuxLoadDataStmt::column_definition_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<5)) == 0 &&
      !IsDefaultValue(primary_key_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAuxLoadDataStmt::primary_key not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<6)) == 0 &&
      !IsDefaultValue(foreign_key_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAuxLoadDataStmt::foreign_key_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<7)) == 0 &&
      !IsDefaultValue(check_constraint_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAuxLoadDataStmt::check_constraint_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<8)) == 0 &&
      !IsDefaultValue(partition_by_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAuxLoadDataStmt::partition_by_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<9)) == 0 &&
      !IsDefaultValue(cluster_by_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAuxLoadDataStmt::cluster_by_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<10)) == 0 &&
      !IsDefaultValue(option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAuxLoadDataStmt::option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<11)) == 0 &&
      !IsDefaultValue(with_partition_columns_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAuxLoadDataStmt::with_partition_columns not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<12)) == 0 &&
      !IsDefaultValue(connection_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAuxLoadDataStmt::connection not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<13)) == 0 &&
      !IsDefaultValue(from_files_option_list_)) {
    NodeAnnotation annotation = {
      .node = this,
      .annotation = "(*** This node has unaccessed field ***)"
    };
    return ::zetasql_base::UnimplementedErrorBuilder(ZETASQL_LOC).LogError()
        << "Unimplemented feature "
           "(ResolvedAuxLoadDataStmt::from_files_option_list not accessed "
           "and has non-default value)\n"
        << root->DebugString({annotation});
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : column_definition_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    if (primary_key_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          primary_key_.get(), root));
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    for (const auto& it : foreign_key_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<7)) != 0) {
    for (const auto& it : check_constraint_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<8)) != 0) {
    for (const auto& it : partition_by_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<9)) != 0) {
    for (const auto& it : cluster_by_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<10)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  if ((accessed_ & (1<<11)) != 0) {
    if (with_partition_columns_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          with_partition_columns_.get(), root));
    }
  }
  if ((accessed_ & (1<<12)) != 0) {
    if (connection_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          connection_.get(), root));
    }
  }
  if ((accessed_ & (1<<13)) != 0) {
    for (const auto& it : from_files_option_list_) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
  }
  return absl::OkStatus();
}

absl::Status ResolvedAuxLoadDataStmt::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

  if ((accessed_ & (1<<0)) != 0) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAuxLoadDataStmt::insertion_mode is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<1)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAuxLoadDataStmt::name_path is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<3)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAuxLoadDataStmt::column_definition_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<5)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAuxLoadDataStmt::primary_key is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<6)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAuxLoadDataStmt::foreign_key_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<7)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAuxLoadDataStmt::check_constraint_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<8)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAuxLoadDataStmt::partition_by_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<9)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAuxLoadDataStmt::cluster_by_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<10)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAuxLoadDataStmt::option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<11)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAuxLoadDataStmt::with_partition_columns is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<12)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAuxLoadDataStmt::connection is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<13)) != 0 ) {
    return ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
        << "(ResolvedAuxLoadDataStmt::from_files_option_list is accessed, but shouldn't be)";
  }
  if ((accessed_ & (1<<2)) != 0) {
    for (const auto& it : output_column_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<3)) != 0) {
    for (const auto& it : column_definition_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<5)) != 0) {
    if (primary_key_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(primary_key_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<6)) != 0) {
    for (const auto& it : foreign_key_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<7)) != 0) {
    for (const auto& it : check_constraint_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<8)) != 0) {
    for (const auto& it : partition_by_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<9)) != 0) {
    for (const auto& it : cluster_by_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<10)) != 0) {
    for (const auto& it : option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<11)) != 0) {
    if (with_partition_columns_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(with_partition_columns_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<12)) != 0) {
    if (connection_ != nullptr) {
      ZETASQL_RETURN_IF_ERROR(connection_->CheckNoFieldsAccessed());
    }
  }
  if ((accessed_ & (1<<13)) != 0) {
    for (const auto& it : from_files_option_list_) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
  }
  return absl::OkStatus();
}

void ResolvedAuxLoadDataStmt::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
  for (const auto& it : output_column_list_) it->ClearFieldsAccessed();
  for (const auto& it : column_definition_list_) it->ClearFieldsAccessed();
  if (primary_key_ != nullptr) primary_key_->ClearFieldsAccessed();
  for (const auto& it : foreign_key_list_) it->ClearFieldsAccessed();
  for (const auto& it : check_constraint_list_) it->ClearFieldsAccessed();
  for (const auto& it : partition_by_list_) it->ClearFieldsAccessed();
  for (const auto& it : cluster_by_list_) it->ClearFieldsAccessed();
  for (const auto& it : option_list_) it->ClearFieldsAccessed();
  if (with_partition_columns_ != nullptr) with_partition_columns_->ClearFieldsAccessed();
  if (connection_ != nullptr) connection_->ClearFieldsAccessed();
  for (const auto& it : from_files_option_list_) it->ClearFieldsAccessed();
}

void ResolvedAuxLoadDataStmt::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
  for (const auto& it : output_column_list_) it->MarkFieldsAccessed();
  for (const auto& it : column_definition_list_) it->MarkFieldsAccessed();
  if (primary_key_ != nullptr) primary_key_->MarkFieldsAccessed();
  for (const auto& it : foreign_key_list_) it->MarkFieldsAccessed();
  for (const auto& it : check_constraint_list_) it->MarkFieldsAccessed();
  for (const auto& it : partition_by_list_) it->MarkFieldsAccessed();
  for (const auto& it : cluster_by_list_) it->MarkFieldsAccessed();
  for (const auto& it : option_list_) it->MarkFieldsAccessed();
  if (with_partition_columns_ != nullptr) with_partition_columns_->MarkFieldsAccessed();
  if (connection_ != nullptr) connection_->MarkFieldsAccessed();
  for (const auto& it : from_files_option_list_) it->MarkFieldsAccessed();
}

}  // namespace zetasql