// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zetasql/resolved_ast/resolved_ast_enums.proto

#ifndef PROTOBUF_INCLUDED_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto
#define PROTOBUF_INCLUDED_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto 

namespace protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[22];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto
namespace zetasql {
class ResolvedAggregateHavingModifierEnums;
class ResolvedAggregateHavingModifierEnumsDefaultTypeInternal;
extern ResolvedAggregateHavingModifierEnumsDefaultTypeInternal _ResolvedAggregateHavingModifierEnums_default_instance_;
class ResolvedArgumentDefEnums;
class ResolvedArgumentDefEnumsDefaultTypeInternal;
extern ResolvedArgumentDefEnumsDefaultTypeInternal _ResolvedArgumentDefEnums_default_instance_;
class ResolvedAuxLoadDataStmtEnums;
class ResolvedAuxLoadDataStmtEnumsDefaultTypeInternal;
extern ResolvedAuxLoadDataStmtEnumsDefaultTypeInternal _ResolvedAuxLoadDataStmtEnums_default_instance_;
class ResolvedBeginStmtEnums;
class ResolvedBeginStmtEnumsDefaultTypeInternal;
extern ResolvedBeginStmtEnumsDefaultTypeInternal _ResolvedBeginStmtEnums_default_instance_;
class ResolvedCreateStatementEnums;
class ResolvedCreateStatementEnumsDefaultTypeInternal;
extern ResolvedCreateStatementEnumsDefaultTypeInternal _ResolvedCreateStatementEnums_default_instance_;
class ResolvedDropStmtEnums;
class ResolvedDropStmtEnumsDefaultTypeInternal;
extern ResolvedDropStmtEnumsDefaultTypeInternal _ResolvedDropStmtEnums_default_instance_;
class ResolvedForeignKeyEnums;
class ResolvedForeignKeyEnumsDefaultTypeInternal;
extern ResolvedForeignKeyEnumsDefaultTypeInternal _ResolvedForeignKeyEnums_default_instance_;
class ResolvedFunctionCallBaseEnums;
class ResolvedFunctionCallBaseEnumsDefaultTypeInternal;
extern ResolvedFunctionCallBaseEnumsDefaultTypeInternal _ResolvedFunctionCallBaseEnums_default_instance_;
class ResolvedGeneratedColumnInfoEnums;
class ResolvedGeneratedColumnInfoEnumsDefaultTypeInternal;
extern ResolvedGeneratedColumnInfoEnumsDefaultTypeInternal _ResolvedGeneratedColumnInfoEnums_default_instance_;
class ResolvedImportStmtEnums;
class ResolvedImportStmtEnumsDefaultTypeInternal;
extern ResolvedImportStmtEnumsDefaultTypeInternal _ResolvedImportStmtEnums_default_instance_;
class ResolvedInsertStmtEnums;
class ResolvedInsertStmtEnumsDefaultTypeInternal;
extern ResolvedInsertStmtEnumsDefaultTypeInternal _ResolvedInsertStmtEnums_default_instance_;
class ResolvedJoinScanEnums;
class ResolvedJoinScanEnumsDefaultTypeInternal;
extern ResolvedJoinScanEnumsDefaultTypeInternal _ResolvedJoinScanEnums_default_instance_;
class ResolvedMergeWhenEnums;
class ResolvedMergeWhenEnumsDefaultTypeInternal;
extern ResolvedMergeWhenEnumsDefaultTypeInternal _ResolvedMergeWhenEnums_default_instance_;
class ResolvedNonScalarFunctionCallBaseEnums;
class ResolvedNonScalarFunctionCallBaseEnumsDefaultTypeInternal;
extern ResolvedNonScalarFunctionCallBaseEnumsDefaultTypeInternal _ResolvedNonScalarFunctionCallBaseEnums_default_instance_;
class ResolvedOrderByItemEnums;
class ResolvedOrderByItemEnumsDefaultTypeInternal;
extern ResolvedOrderByItemEnumsDefaultTypeInternal _ResolvedOrderByItemEnums_default_instance_;
class ResolvedRecursiveScanEnums;
class ResolvedRecursiveScanEnumsDefaultTypeInternal;
extern ResolvedRecursiveScanEnumsDefaultTypeInternal _ResolvedRecursiveScanEnums_default_instance_;
class ResolvedSampleScanEnums;
class ResolvedSampleScanEnumsDefaultTypeInternal;
extern ResolvedSampleScanEnumsDefaultTypeInternal _ResolvedSampleScanEnums_default_instance_;
class ResolvedSetOperationScanEnums;
class ResolvedSetOperationScanEnumsDefaultTypeInternal;
extern ResolvedSetOperationScanEnumsDefaultTypeInternal _ResolvedSetOperationScanEnums_default_instance_;
class ResolvedStatementEnums;
class ResolvedStatementEnumsDefaultTypeInternal;
extern ResolvedStatementEnumsDefaultTypeInternal _ResolvedStatementEnums_default_instance_;
class ResolvedSubqueryExprEnums;
class ResolvedSubqueryExprEnumsDefaultTypeInternal;
extern ResolvedSubqueryExprEnumsDefaultTypeInternal _ResolvedSubqueryExprEnums_default_instance_;
class ResolvedWindowFrameEnums;
class ResolvedWindowFrameEnumsDefaultTypeInternal;
extern ResolvedWindowFrameEnumsDefaultTypeInternal _ResolvedWindowFrameEnums_default_instance_;
class ResolvedWindowFrameExprEnums;
class ResolvedWindowFrameExprEnumsDefaultTypeInternal;
extern ResolvedWindowFrameExprEnumsDefaultTypeInternal _ResolvedWindowFrameExprEnums_default_instance_;
}  // namespace zetasql
namespace google {
namespace protobuf {
template<> ::zetasql::ResolvedAggregateHavingModifierEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedAggregateHavingModifierEnums>(Arena*);
template<> ::zetasql::ResolvedArgumentDefEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedArgumentDefEnums>(Arena*);
template<> ::zetasql::ResolvedAuxLoadDataStmtEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedAuxLoadDataStmtEnums>(Arena*);
template<> ::zetasql::ResolvedBeginStmtEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedBeginStmtEnums>(Arena*);
template<> ::zetasql::ResolvedCreateStatementEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedCreateStatementEnums>(Arena*);
template<> ::zetasql::ResolvedDropStmtEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedDropStmtEnums>(Arena*);
template<> ::zetasql::ResolvedForeignKeyEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedForeignKeyEnums>(Arena*);
template<> ::zetasql::ResolvedFunctionCallBaseEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedFunctionCallBaseEnums>(Arena*);
template<> ::zetasql::ResolvedGeneratedColumnInfoEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedGeneratedColumnInfoEnums>(Arena*);
template<> ::zetasql::ResolvedImportStmtEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedImportStmtEnums>(Arena*);
template<> ::zetasql::ResolvedInsertStmtEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedInsertStmtEnums>(Arena*);
template<> ::zetasql::ResolvedJoinScanEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedJoinScanEnums>(Arena*);
template<> ::zetasql::ResolvedMergeWhenEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedMergeWhenEnums>(Arena*);
template<> ::zetasql::ResolvedNonScalarFunctionCallBaseEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedNonScalarFunctionCallBaseEnums>(Arena*);
template<> ::zetasql::ResolvedOrderByItemEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedOrderByItemEnums>(Arena*);
template<> ::zetasql::ResolvedRecursiveScanEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedRecursiveScanEnums>(Arena*);
template<> ::zetasql::ResolvedSampleScanEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedSampleScanEnums>(Arena*);
template<> ::zetasql::ResolvedSetOperationScanEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedSetOperationScanEnums>(Arena*);
template<> ::zetasql::ResolvedStatementEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedStatementEnums>(Arena*);
template<> ::zetasql::ResolvedSubqueryExprEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedSubqueryExprEnums>(Arena*);
template<> ::zetasql::ResolvedWindowFrameEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedWindowFrameEnums>(Arena*);
template<> ::zetasql::ResolvedWindowFrameExprEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedWindowFrameExprEnums>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace zetasql {

enum ResolvedSubqueryExprEnums_SubqueryType {
  ResolvedSubqueryExprEnums_SubqueryType_SCALAR = 0,
  ResolvedSubqueryExprEnums_SubqueryType_ARRAY = 1,
  ResolvedSubqueryExprEnums_SubqueryType_EXISTS = 2,
  ResolvedSubqueryExprEnums_SubqueryType_IN = 3,
  ResolvedSubqueryExprEnums_SubqueryType_LIKE_ANY = 4,
  ResolvedSubqueryExprEnums_SubqueryType_LIKE_ALL = 5
};
bool ResolvedSubqueryExprEnums_SubqueryType_IsValid(int value);
const ResolvedSubqueryExprEnums_SubqueryType ResolvedSubqueryExprEnums_SubqueryType_SubqueryType_MIN = ResolvedSubqueryExprEnums_SubqueryType_SCALAR;
const ResolvedSubqueryExprEnums_SubqueryType ResolvedSubqueryExprEnums_SubqueryType_SubqueryType_MAX = ResolvedSubqueryExprEnums_SubqueryType_LIKE_ALL;
const int ResolvedSubqueryExprEnums_SubqueryType_SubqueryType_ARRAYSIZE = ResolvedSubqueryExprEnums_SubqueryType_SubqueryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedSubqueryExprEnums_SubqueryType_descriptor();
inline const ::std::string& ResolvedSubqueryExprEnums_SubqueryType_Name(ResolvedSubqueryExprEnums_SubqueryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedSubqueryExprEnums_SubqueryType_descriptor(), value);
}
inline bool ResolvedSubqueryExprEnums_SubqueryType_Parse(
    const ::std::string& name, ResolvedSubqueryExprEnums_SubqueryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedSubqueryExprEnums_SubqueryType>(
    ResolvedSubqueryExprEnums_SubqueryType_descriptor(), name, value);
}
enum ResolvedJoinScanEnums_JoinType {
  ResolvedJoinScanEnums_JoinType_INNER = 0,
  ResolvedJoinScanEnums_JoinType_LEFT = 1,
  ResolvedJoinScanEnums_JoinType_RIGHT = 2,
  ResolvedJoinScanEnums_JoinType_FULL = 3
};
bool ResolvedJoinScanEnums_JoinType_IsValid(int value);
const ResolvedJoinScanEnums_JoinType ResolvedJoinScanEnums_JoinType_JoinType_MIN = ResolvedJoinScanEnums_JoinType_INNER;
const ResolvedJoinScanEnums_JoinType ResolvedJoinScanEnums_JoinType_JoinType_MAX = ResolvedJoinScanEnums_JoinType_FULL;
const int ResolvedJoinScanEnums_JoinType_JoinType_ARRAYSIZE = ResolvedJoinScanEnums_JoinType_JoinType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedJoinScanEnums_JoinType_descriptor();
inline const ::std::string& ResolvedJoinScanEnums_JoinType_Name(ResolvedJoinScanEnums_JoinType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedJoinScanEnums_JoinType_descriptor(), value);
}
inline bool ResolvedJoinScanEnums_JoinType_Parse(
    const ::std::string& name, ResolvedJoinScanEnums_JoinType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedJoinScanEnums_JoinType>(
    ResolvedJoinScanEnums_JoinType_descriptor(), name, value);
}
enum ResolvedSetOperationScanEnums_SetOperationType {
  ResolvedSetOperationScanEnums_SetOperationType_UNION_ALL = 0,
  ResolvedSetOperationScanEnums_SetOperationType_UNION_DISTINCT = 1,
  ResolvedSetOperationScanEnums_SetOperationType_INTERSECT_ALL = 2,
  ResolvedSetOperationScanEnums_SetOperationType_INTERSECT_DISTINCT = 3,
  ResolvedSetOperationScanEnums_SetOperationType_EXCEPT_ALL = 4,
  ResolvedSetOperationScanEnums_SetOperationType_EXCEPT_DISTINCT = 5
};
bool ResolvedSetOperationScanEnums_SetOperationType_IsValid(int value);
const ResolvedSetOperationScanEnums_SetOperationType ResolvedSetOperationScanEnums_SetOperationType_SetOperationType_MIN = ResolvedSetOperationScanEnums_SetOperationType_UNION_ALL;
const ResolvedSetOperationScanEnums_SetOperationType ResolvedSetOperationScanEnums_SetOperationType_SetOperationType_MAX = ResolvedSetOperationScanEnums_SetOperationType_EXCEPT_DISTINCT;
const int ResolvedSetOperationScanEnums_SetOperationType_SetOperationType_ARRAYSIZE = ResolvedSetOperationScanEnums_SetOperationType_SetOperationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedSetOperationScanEnums_SetOperationType_descriptor();
inline const ::std::string& ResolvedSetOperationScanEnums_SetOperationType_Name(ResolvedSetOperationScanEnums_SetOperationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedSetOperationScanEnums_SetOperationType_descriptor(), value);
}
inline bool ResolvedSetOperationScanEnums_SetOperationType_Parse(
    const ::std::string& name, ResolvedSetOperationScanEnums_SetOperationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedSetOperationScanEnums_SetOperationType>(
    ResolvedSetOperationScanEnums_SetOperationType_descriptor(), name, value);
}
enum ResolvedRecursiveScanEnums_RecursiveSetOperationType {
  ResolvedRecursiveScanEnums_RecursiveSetOperationType_UNION_ALL = 0,
  ResolvedRecursiveScanEnums_RecursiveSetOperationType_UNION_DISTINCT = 1
};
bool ResolvedRecursiveScanEnums_RecursiveSetOperationType_IsValid(int value);
const ResolvedRecursiveScanEnums_RecursiveSetOperationType ResolvedRecursiveScanEnums_RecursiveSetOperationType_RecursiveSetOperationType_MIN = ResolvedRecursiveScanEnums_RecursiveSetOperationType_UNION_ALL;
const ResolvedRecursiveScanEnums_RecursiveSetOperationType ResolvedRecursiveScanEnums_RecursiveSetOperationType_RecursiveSetOperationType_MAX = ResolvedRecursiveScanEnums_RecursiveSetOperationType_UNION_DISTINCT;
const int ResolvedRecursiveScanEnums_RecursiveSetOperationType_RecursiveSetOperationType_ARRAYSIZE = ResolvedRecursiveScanEnums_RecursiveSetOperationType_RecursiveSetOperationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedRecursiveScanEnums_RecursiveSetOperationType_descriptor();
inline const ::std::string& ResolvedRecursiveScanEnums_RecursiveSetOperationType_Name(ResolvedRecursiveScanEnums_RecursiveSetOperationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedRecursiveScanEnums_RecursiveSetOperationType_descriptor(), value);
}
inline bool ResolvedRecursiveScanEnums_RecursiveSetOperationType_Parse(
    const ::std::string& name, ResolvedRecursiveScanEnums_RecursiveSetOperationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedRecursiveScanEnums_RecursiveSetOperationType>(
    ResolvedRecursiveScanEnums_RecursiveSetOperationType_descriptor(), name, value);
}
enum ResolvedSampleScanEnums_SampleUnit {
  ResolvedSampleScanEnums_SampleUnit_ROWS = 0,
  ResolvedSampleScanEnums_SampleUnit_PERCENT = 1
};
bool ResolvedSampleScanEnums_SampleUnit_IsValid(int value);
const ResolvedSampleScanEnums_SampleUnit ResolvedSampleScanEnums_SampleUnit_SampleUnit_MIN = ResolvedSampleScanEnums_SampleUnit_ROWS;
const ResolvedSampleScanEnums_SampleUnit ResolvedSampleScanEnums_SampleUnit_SampleUnit_MAX = ResolvedSampleScanEnums_SampleUnit_PERCENT;
const int ResolvedSampleScanEnums_SampleUnit_SampleUnit_ARRAYSIZE = ResolvedSampleScanEnums_SampleUnit_SampleUnit_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedSampleScanEnums_SampleUnit_descriptor();
inline const ::std::string& ResolvedSampleScanEnums_SampleUnit_Name(ResolvedSampleScanEnums_SampleUnit value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedSampleScanEnums_SampleUnit_descriptor(), value);
}
inline bool ResolvedSampleScanEnums_SampleUnit_Parse(
    const ::std::string& name, ResolvedSampleScanEnums_SampleUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedSampleScanEnums_SampleUnit>(
    ResolvedSampleScanEnums_SampleUnit_descriptor(), name, value);
}
enum ResolvedOrderByItemEnums_NullOrderMode {
  ResolvedOrderByItemEnums_NullOrderMode_ORDER_UNSPECIFIED = 0,
  ResolvedOrderByItemEnums_NullOrderMode_NULLS_FIRST = 1,
  ResolvedOrderByItemEnums_NullOrderMode_NULLS_LAST = 2
};
bool ResolvedOrderByItemEnums_NullOrderMode_IsValid(int value);
const ResolvedOrderByItemEnums_NullOrderMode ResolvedOrderByItemEnums_NullOrderMode_NullOrderMode_MIN = ResolvedOrderByItemEnums_NullOrderMode_ORDER_UNSPECIFIED;
const ResolvedOrderByItemEnums_NullOrderMode ResolvedOrderByItemEnums_NullOrderMode_NullOrderMode_MAX = ResolvedOrderByItemEnums_NullOrderMode_NULLS_LAST;
const int ResolvedOrderByItemEnums_NullOrderMode_NullOrderMode_ARRAYSIZE = ResolvedOrderByItemEnums_NullOrderMode_NullOrderMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedOrderByItemEnums_NullOrderMode_descriptor();
inline const ::std::string& ResolvedOrderByItemEnums_NullOrderMode_Name(ResolvedOrderByItemEnums_NullOrderMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedOrderByItemEnums_NullOrderMode_descriptor(), value);
}
inline bool ResolvedOrderByItemEnums_NullOrderMode_Parse(
    const ::std::string& name, ResolvedOrderByItemEnums_NullOrderMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedOrderByItemEnums_NullOrderMode>(
    ResolvedOrderByItemEnums_NullOrderMode_descriptor(), name, value);
}
enum ResolvedCreateStatementEnums_CreateScope {
  ResolvedCreateStatementEnums_CreateScope_CREATE_DEFAULT_SCOPE = 0,
  ResolvedCreateStatementEnums_CreateScope_CREATE_PRIVATE = 1,
  ResolvedCreateStatementEnums_CreateScope_CREATE_PUBLIC = 2,
  ResolvedCreateStatementEnums_CreateScope_CREATE_TEMP = 3
};
bool ResolvedCreateStatementEnums_CreateScope_IsValid(int value);
const ResolvedCreateStatementEnums_CreateScope ResolvedCreateStatementEnums_CreateScope_CreateScope_MIN = ResolvedCreateStatementEnums_CreateScope_CREATE_DEFAULT_SCOPE;
const ResolvedCreateStatementEnums_CreateScope ResolvedCreateStatementEnums_CreateScope_CreateScope_MAX = ResolvedCreateStatementEnums_CreateScope_CREATE_TEMP;
const int ResolvedCreateStatementEnums_CreateScope_CreateScope_ARRAYSIZE = ResolvedCreateStatementEnums_CreateScope_CreateScope_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedCreateStatementEnums_CreateScope_descriptor();
inline const ::std::string& ResolvedCreateStatementEnums_CreateScope_Name(ResolvedCreateStatementEnums_CreateScope value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedCreateStatementEnums_CreateScope_descriptor(), value);
}
inline bool ResolvedCreateStatementEnums_CreateScope_Parse(
    const ::std::string& name, ResolvedCreateStatementEnums_CreateScope* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedCreateStatementEnums_CreateScope>(
    ResolvedCreateStatementEnums_CreateScope_descriptor(), name, value);
}
enum ResolvedCreateStatementEnums_CreateMode {
  ResolvedCreateStatementEnums_CreateMode_CREATE_DEFAULT = 0,
  ResolvedCreateStatementEnums_CreateMode_CREATE_OR_REPLACE = 1,
  ResolvedCreateStatementEnums_CreateMode_CREATE_IF_NOT_EXISTS = 2
};
bool ResolvedCreateStatementEnums_CreateMode_IsValid(int value);
const ResolvedCreateStatementEnums_CreateMode ResolvedCreateStatementEnums_CreateMode_CreateMode_MIN = ResolvedCreateStatementEnums_CreateMode_CREATE_DEFAULT;
const ResolvedCreateStatementEnums_CreateMode ResolvedCreateStatementEnums_CreateMode_CreateMode_MAX = ResolvedCreateStatementEnums_CreateMode_CREATE_IF_NOT_EXISTS;
const int ResolvedCreateStatementEnums_CreateMode_CreateMode_ARRAYSIZE = ResolvedCreateStatementEnums_CreateMode_CreateMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedCreateStatementEnums_CreateMode_descriptor();
inline const ::std::string& ResolvedCreateStatementEnums_CreateMode_Name(ResolvedCreateStatementEnums_CreateMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedCreateStatementEnums_CreateMode_descriptor(), value);
}
inline bool ResolvedCreateStatementEnums_CreateMode_Parse(
    const ::std::string& name, ResolvedCreateStatementEnums_CreateMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedCreateStatementEnums_CreateMode>(
    ResolvedCreateStatementEnums_CreateMode_descriptor(), name, value);
}
enum ResolvedCreateStatementEnums_SqlSecurity {
  ResolvedCreateStatementEnums_SqlSecurity_SQL_SECURITY_UNSPECIFIED = 0,
  ResolvedCreateStatementEnums_SqlSecurity_SQL_SECURITY_DEFINER = 1,
  ResolvedCreateStatementEnums_SqlSecurity_SQL_SECURITY_INVOKER = 2
};
bool ResolvedCreateStatementEnums_SqlSecurity_IsValid(int value);
const ResolvedCreateStatementEnums_SqlSecurity ResolvedCreateStatementEnums_SqlSecurity_SqlSecurity_MIN = ResolvedCreateStatementEnums_SqlSecurity_SQL_SECURITY_UNSPECIFIED;
const ResolvedCreateStatementEnums_SqlSecurity ResolvedCreateStatementEnums_SqlSecurity_SqlSecurity_MAX = ResolvedCreateStatementEnums_SqlSecurity_SQL_SECURITY_INVOKER;
const int ResolvedCreateStatementEnums_SqlSecurity_SqlSecurity_ARRAYSIZE = ResolvedCreateStatementEnums_SqlSecurity_SqlSecurity_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedCreateStatementEnums_SqlSecurity_descriptor();
inline const ::std::string& ResolvedCreateStatementEnums_SqlSecurity_Name(ResolvedCreateStatementEnums_SqlSecurity value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedCreateStatementEnums_SqlSecurity_descriptor(), value);
}
inline bool ResolvedCreateStatementEnums_SqlSecurity_Parse(
    const ::std::string& name, ResolvedCreateStatementEnums_SqlSecurity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedCreateStatementEnums_SqlSecurity>(
    ResolvedCreateStatementEnums_SqlSecurity_descriptor(), name, value);
}
enum ResolvedCreateStatementEnums_DeterminismLevel {
  ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_UNSPECIFIED = 0,
  ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_DETERMINISTIC = 1,
  ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_NOT_DETERMINISTIC = 2,
  ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_IMMUTABLE = 3,
  ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_STABLE = 4,
  ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_VOLATILE = 5
};
bool ResolvedCreateStatementEnums_DeterminismLevel_IsValid(int value);
const ResolvedCreateStatementEnums_DeterminismLevel ResolvedCreateStatementEnums_DeterminismLevel_DeterminismLevel_MIN = ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_UNSPECIFIED;
const ResolvedCreateStatementEnums_DeterminismLevel ResolvedCreateStatementEnums_DeterminismLevel_DeterminismLevel_MAX = ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_VOLATILE;
const int ResolvedCreateStatementEnums_DeterminismLevel_DeterminismLevel_ARRAYSIZE = ResolvedCreateStatementEnums_DeterminismLevel_DeterminismLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedCreateStatementEnums_DeterminismLevel_descriptor();
inline const ::std::string& ResolvedCreateStatementEnums_DeterminismLevel_Name(ResolvedCreateStatementEnums_DeterminismLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedCreateStatementEnums_DeterminismLevel_descriptor(), value);
}
inline bool ResolvedCreateStatementEnums_DeterminismLevel_Parse(
    const ::std::string& name, ResolvedCreateStatementEnums_DeterminismLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedCreateStatementEnums_DeterminismLevel>(
    ResolvedCreateStatementEnums_DeterminismLevel_descriptor(), name, value);
}
enum ResolvedGeneratedColumnInfoEnums_StoredMode {
  ResolvedGeneratedColumnInfoEnums_StoredMode_NON_STORED = 0,
  ResolvedGeneratedColumnInfoEnums_StoredMode_STORED = 1,
  ResolvedGeneratedColumnInfoEnums_StoredMode_STORED_VOLATILE = 2
};
bool ResolvedGeneratedColumnInfoEnums_StoredMode_IsValid(int value);
const ResolvedGeneratedColumnInfoEnums_StoredMode ResolvedGeneratedColumnInfoEnums_StoredMode_StoredMode_MIN = ResolvedGeneratedColumnInfoEnums_StoredMode_NON_STORED;
const ResolvedGeneratedColumnInfoEnums_StoredMode ResolvedGeneratedColumnInfoEnums_StoredMode_StoredMode_MAX = ResolvedGeneratedColumnInfoEnums_StoredMode_STORED_VOLATILE;
const int ResolvedGeneratedColumnInfoEnums_StoredMode_StoredMode_ARRAYSIZE = ResolvedGeneratedColumnInfoEnums_StoredMode_StoredMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedGeneratedColumnInfoEnums_StoredMode_descriptor();
inline const ::std::string& ResolvedGeneratedColumnInfoEnums_StoredMode_Name(ResolvedGeneratedColumnInfoEnums_StoredMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedGeneratedColumnInfoEnums_StoredMode_descriptor(), value);
}
inline bool ResolvedGeneratedColumnInfoEnums_StoredMode_Parse(
    const ::std::string& name, ResolvedGeneratedColumnInfoEnums_StoredMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedGeneratedColumnInfoEnums_StoredMode>(
    ResolvedGeneratedColumnInfoEnums_StoredMode_descriptor(), name, value);
}
enum ResolvedDropStmtEnums_DropMode {
  ResolvedDropStmtEnums_DropMode_DROP_MODE_UNSPECIFIED = 0,
  ResolvedDropStmtEnums_DropMode_RESTRICT = 1,
  ResolvedDropStmtEnums_DropMode_CASCADE = 2
};
bool ResolvedDropStmtEnums_DropMode_IsValid(int value);
const ResolvedDropStmtEnums_DropMode ResolvedDropStmtEnums_DropMode_DropMode_MIN = ResolvedDropStmtEnums_DropMode_DROP_MODE_UNSPECIFIED;
const ResolvedDropStmtEnums_DropMode ResolvedDropStmtEnums_DropMode_DropMode_MAX = ResolvedDropStmtEnums_DropMode_CASCADE;
const int ResolvedDropStmtEnums_DropMode_DropMode_ARRAYSIZE = ResolvedDropStmtEnums_DropMode_DropMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedDropStmtEnums_DropMode_descriptor();
inline const ::std::string& ResolvedDropStmtEnums_DropMode_Name(ResolvedDropStmtEnums_DropMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedDropStmtEnums_DropMode_descriptor(), value);
}
inline bool ResolvedDropStmtEnums_DropMode_Parse(
    const ::std::string& name, ResolvedDropStmtEnums_DropMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedDropStmtEnums_DropMode>(
    ResolvedDropStmtEnums_DropMode_descriptor(), name, value);
}
enum ResolvedBeginStmtEnums_ReadWriteMode {
  ResolvedBeginStmtEnums_ReadWriteMode_MODE_UNSPECIFIED = 0,
  ResolvedBeginStmtEnums_ReadWriteMode_MODE_READ_ONLY = 1,
  ResolvedBeginStmtEnums_ReadWriteMode_MODE_READ_WRITE = 2
};
bool ResolvedBeginStmtEnums_ReadWriteMode_IsValid(int value);
const ResolvedBeginStmtEnums_ReadWriteMode ResolvedBeginStmtEnums_ReadWriteMode_ReadWriteMode_MIN = ResolvedBeginStmtEnums_ReadWriteMode_MODE_UNSPECIFIED;
const ResolvedBeginStmtEnums_ReadWriteMode ResolvedBeginStmtEnums_ReadWriteMode_ReadWriteMode_MAX = ResolvedBeginStmtEnums_ReadWriteMode_MODE_READ_WRITE;
const int ResolvedBeginStmtEnums_ReadWriteMode_ReadWriteMode_ARRAYSIZE = ResolvedBeginStmtEnums_ReadWriteMode_ReadWriteMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedBeginStmtEnums_ReadWriteMode_descriptor();
inline const ::std::string& ResolvedBeginStmtEnums_ReadWriteMode_Name(ResolvedBeginStmtEnums_ReadWriteMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedBeginStmtEnums_ReadWriteMode_descriptor(), value);
}
inline bool ResolvedBeginStmtEnums_ReadWriteMode_Parse(
    const ::std::string& name, ResolvedBeginStmtEnums_ReadWriteMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedBeginStmtEnums_ReadWriteMode>(
    ResolvedBeginStmtEnums_ReadWriteMode_descriptor(), name, value);
}
enum ResolvedWindowFrameEnums_FrameUnit {
  ResolvedWindowFrameEnums_FrameUnit_ROWS = 0,
  ResolvedWindowFrameEnums_FrameUnit_RANGE = 1
};
bool ResolvedWindowFrameEnums_FrameUnit_IsValid(int value);
const ResolvedWindowFrameEnums_FrameUnit ResolvedWindowFrameEnums_FrameUnit_FrameUnit_MIN = ResolvedWindowFrameEnums_FrameUnit_ROWS;
const ResolvedWindowFrameEnums_FrameUnit ResolvedWindowFrameEnums_FrameUnit_FrameUnit_MAX = ResolvedWindowFrameEnums_FrameUnit_RANGE;
const int ResolvedWindowFrameEnums_FrameUnit_FrameUnit_ARRAYSIZE = ResolvedWindowFrameEnums_FrameUnit_FrameUnit_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedWindowFrameEnums_FrameUnit_descriptor();
inline const ::std::string& ResolvedWindowFrameEnums_FrameUnit_Name(ResolvedWindowFrameEnums_FrameUnit value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedWindowFrameEnums_FrameUnit_descriptor(), value);
}
inline bool ResolvedWindowFrameEnums_FrameUnit_Parse(
    const ::std::string& name, ResolvedWindowFrameEnums_FrameUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedWindowFrameEnums_FrameUnit>(
    ResolvedWindowFrameEnums_FrameUnit_descriptor(), name, value);
}
enum ResolvedWindowFrameExprEnums_BoundaryType {
  ResolvedWindowFrameExprEnums_BoundaryType_UNBOUNDED_PRECEDING = 0,
  ResolvedWindowFrameExprEnums_BoundaryType_OFFSET_PRECEDING = 1,
  ResolvedWindowFrameExprEnums_BoundaryType_CURRENT_ROW = 2,
  ResolvedWindowFrameExprEnums_BoundaryType_OFFSET_FOLLOWING = 3,
  ResolvedWindowFrameExprEnums_BoundaryType_UNBOUNDED_FOLLOWING = 4
};
bool ResolvedWindowFrameExprEnums_BoundaryType_IsValid(int value);
const ResolvedWindowFrameExprEnums_BoundaryType ResolvedWindowFrameExprEnums_BoundaryType_BoundaryType_MIN = ResolvedWindowFrameExprEnums_BoundaryType_UNBOUNDED_PRECEDING;
const ResolvedWindowFrameExprEnums_BoundaryType ResolvedWindowFrameExprEnums_BoundaryType_BoundaryType_MAX = ResolvedWindowFrameExprEnums_BoundaryType_UNBOUNDED_FOLLOWING;
const int ResolvedWindowFrameExprEnums_BoundaryType_BoundaryType_ARRAYSIZE = ResolvedWindowFrameExprEnums_BoundaryType_BoundaryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedWindowFrameExprEnums_BoundaryType_descriptor();
inline const ::std::string& ResolvedWindowFrameExprEnums_BoundaryType_Name(ResolvedWindowFrameExprEnums_BoundaryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedWindowFrameExprEnums_BoundaryType_descriptor(), value);
}
inline bool ResolvedWindowFrameExprEnums_BoundaryType_Parse(
    const ::std::string& name, ResolvedWindowFrameExprEnums_BoundaryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedWindowFrameExprEnums_BoundaryType>(
    ResolvedWindowFrameExprEnums_BoundaryType_descriptor(), name, value);
}
enum ResolvedInsertStmtEnums_InsertMode {
  ResolvedInsertStmtEnums_InsertMode_OR_ERROR = 0,
  ResolvedInsertStmtEnums_InsertMode_OR_IGNORE = 1,
  ResolvedInsertStmtEnums_InsertMode_OR_REPLACE = 2,
  ResolvedInsertStmtEnums_InsertMode_OR_UPDATE = 3
};
bool ResolvedInsertStmtEnums_InsertMode_IsValid(int value);
const ResolvedInsertStmtEnums_InsertMode ResolvedInsertStmtEnums_InsertMode_InsertMode_MIN = ResolvedInsertStmtEnums_InsertMode_OR_ERROR;
const ResolvedInsertStmtEnums_InsertMode ResolvedInsertStmtEnums_InsertMode_InsertMode_MAX = ResolvedInsertStmtEnums_InsertMode_OR_UPDATE;
const int ResolvedInsertStmtEnums_InsertMode_InsertMode_ARRAYSIZE = ResolvedInsertStmtEnums_InsertMode_InsertMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedInsertStmtEnums_InsertMode_descriptor();
inline const ::std::string& ResolvedInsertStmtEnums_InsertMode_Name(ResolvedInsertStmtEnums_InsertMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedInsertStmtEnums_InsertMode_descriptor(), value);
}
inline bool ResolvedInsertStmtEnums_InsertMode_Parse(
    const ::std::string& name, ResolvedInsertStmtEnums_InsertMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedInsertStmtEnums_InsertMode>(
    ResolvedInsertStmtEnums_InsertMode_descriptor(), name, value);
}
enum ResolvedMergeWhenEnums_MatchType {
  ResolvedMergeWhenEnums_MatchType_MATCHED = 0,
  ResolvedMergeWhenEnums_MatchType_NOT_MATCHED_BY_SOURCE = 1,
  ResolvedMergeWhenEnums_MatchType_NOT_MATCHED_BY_TARGET = 2
};
bool ResolvedMergeWhenEnums_MatchType_IsValid(int value);
const ResolvedMergeWhenEnums_MatchType ResolvedMergeWhenEnums_MatchType_MatchType_MIN = ResolvedMergeWhenEnums_MatchType_MATCHED;
const ResolvedMergeWhenEnums_MatchType ResolvedMergeWhenEnums_MatchType_MatchType_MAX = ResolvedMergeWhenEnums_MatchType_NOT_MATCHED_BY_TARGET;
const int ResolvedMergeWhenEnums_MatchType_MatchType_ARRAYSIZE = ResolvedMergeWhenEnums_MatchType_MatchType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedMergeWhenEnums_MatchType_descriptor();
inline const ::std::string& ResolvedMergeWhenEnums_MatchType_Name(ResolvedMergeWhenEnums_MatchType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedMergeWhenEnums_MatchType_descriptor(), value);
}
inline bool ResolvedMergeWhenEnums_MatchType_Parse(
    const ::std::string& name, ResolvedMergeWhenEnums_MatchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedMergeWhenEnums_MatchType>(
    ResolvedMergeWhenEnums_MatchType_descriptor(), name, value);
}
enum ResolvedMergeWhenEnums_ActionType {
  ResolvedMergeWhenEnums_ActionType_INSERT = 0,
  ResolvedMergeWhenEnums_ActionType_UPDATE = 1,
  ResolvedMergeWhenEnums_ActionType_DELETE = 2
};
bool ResolvedMergeWhenEnums_ActionType_IsValid(int value);
const ResolvedMergeWhenEnums_ActionType ResolvedMergeWhenEnums_ActionType_ActionType_MIN = ResolvedMergeWhenEnums_ActionType_INSERT;
const ResolvedMergeWhenEnums_ActionType ResolvedMergeWhenEnums_ActionType_ActionType_MAX = ResolvedMergeWhenEnums_ActionType_DELETE;
const int ResolvedMergeWhenEnums_ActionType_ActionType_ARRAYSIZE = ResolvedMergeWhenEnums_ActionType_ActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedMergeWhenEnums_ActionType_descriptor();
inline const ::std::string& ResolvedMergeWhenEnums_ActionType_Name(ResolvedMergeWhenEnums_ActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedMergeWhenEnums_ActionType_descriptor(), value);
}
inline bool ResolvedMergeWhenEnums_ActionType_Parse(
    const ::std::string& name, ResolvedMergeWhenEnums_ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedMergeWhenEnums_ActionType>(
    ResolvedMergeWhenEnums_ActionType_descriptor(), name, value);
}
enum ResolvedArgumentDefEnums_ArgumentKind {
  ResolvedArgumentDefEnums_ArgumentKind_SCALAR = 0,
  ResolvedArgumentDefEnums_ArgumentKind_AGGREGATE = 1,
  ResolvedArgumentDefEnums_ArgumentKind_NOT_AGGREGATE = 2
};
bool ResolvedArgumentDefEnums_ArgumentKind_IsValid(int value);
const ResolvedArgumentDefEnums_ArgumentKind ResolvedArgumentDefEnums_ArgumentKind_ArgumentKind_MIN = ResolvedArgumentDefEnums_ArgumentKind_SCALAR;
const ResolvedArgumentDefEnums_ArgumentKind ResolvedArgumentDefEnums_ArgumentKind_ArgumentKind_MAX = ResolvedArgumentDefEnums_ArgumentKind_NOT_AGGREGATE;
const int ResolvedArgumentDefEnums_ArgumentKind_ArgumentKind_ARRAYSIZE = ResolvedArgumentDefEnums_ArgumentKind_ArgumentKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedArgumentDefEnums_ArgumentKind_descriptor();
inline const ::std::string& ResolvedArgumentDefEnums_ArgumentKind_Name(ResolvedArgumentDefEnums_ArgumentKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedArgumentDefEnums_ArgumentKind_descriptor(), value);
}
inline bool ResolvedArgumentDefEnums_ArgumentKind_Parse(
    const ::std::string& name, ResolvedArgumentDefEnums_ArgumentKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedArgumentDefEnums_ArgumentKind>(
    ResolvedArgumentDefEnums_ArgumentKind_descriptor(), name, value);
}
enum ResolvedFunctionCallBaseEnums_ErrorMode {
  ResolvedFunctionCallBaseEnums_ErrorMode_DEFAULT_ERROR_MODE = 0,
  ResolvedFunctionCallBaseEnums_ErrorMode_SAFE_ERROR_MODE = 1
};
bool ResolvedFunctionCallBaseEnums_ErrorMode_IsValid(int value);
const ResolvedFunctionCallBaseEnums_ErrorMode ResolvedFunctionCallBaseEnums_ErrorMode_ErrorMode_MIN = ResolvedFunctionCallBaseEnums_ErrorMode_DEFAULT_ERROR_MODE;
const ResolvedFunctionCallBaseEnums_ErrorMode ResolvedFunctionCallBaseEnums_ErrorMode_ErrorMode_MAX = ResolvedFunctionCallBaseEnums_ErrorMode_SAFE_ERROR_MODE;
const int ResolvedFunctionCallBaseEnums_ErrorMode_ErrorMode_ARRAYSIZE = ResolvedFunctionCallBaseEnums_ErrorMode_ErrorMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedFunctionCallBaseEnums_ErrorMode_descriptor();
inline const ::std::string& ResolvedFunctionCallBaseEnums_ErrorMode_Name(ResolvedFunctionCallBaseEnums_ErrorMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedFunctionCallBaseEnums_ErrorMode_descriptor(), value);
}
inline bool ResolvedFunctionCallBaseEnums_ErrorMode_Parse(
    const ::std::string& name, ResolvedFunctionCallBaseEnums_ErrorMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedFunctionCallBaseEnums_ErrorMode>(
    ResolvedFunctionCallBaseEnums_ErrorMode_descriptor(), name, value);
}
enum ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier {
  ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_DEFAULT_NULL_HANDLING = 0,
  ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_IGNORE_NULLS = 1,
  ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_RESPECT_NULLS = 2
};
bool ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_IsValid(int value);
const ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_NullHandlingModifier_MIN = ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_DEFAULT_NULL_HANDLING;
const ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_NullHandlingModifier_MAX = ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_RESPECT_NULLS;
const int ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_NullHandlingModifier_ARRAYSIZE = ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_NullHandlingModifier_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_descriptor();
inline const ::std::string& ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_Name(ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_descriptor(), value);
}
inline bool ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_Parse(
    const ::std::string& name, ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier>(
    ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_descriptor(), name, value);
}
enum ResolvedAggregateHavingModifierEnums_HavingModifierKind {
  ResolvedAggregateHavingModifierEnums_HavingModifierKind_INVALID = 0,
  ResolvedAggregateHavingModifierEnums_HavingModifierKind_MAX = 1,
  ResolvedAggregateHavingModifierEnums_HavingModifierKind_MIN = 2
};
bool ResolvedAggregateHavingModifierEnums_HavingModifierKind_IsValid(int value);
const ResolvedAggregateHavingModifierEnums_HavingModifierKind ResolvedAggregateHavingModifierEnums_HavingModifierKind_HavingModifierKind_MIN = ResolvedAggregateHavingModifierEnums_HavingModifierKind_INVALID;
const ResolvedAggregateHavingModifierEnums_HavingModifierKind ResolvedAggregateHavingModifierEnums_HavingModifierKind_HavingModifierKind_MAX = ResolvedAggregateHavingModifierEnums_HavingModifierKind_MIN;
const int ResolvedAggregateHavingModifierEnums_HavingModifierKind_HavingModifierKind_ARRAYSIZE = ResolvedAggregateHavingModifierEnums_HavingModifierKind_HavingModifierKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedAggregateHavingModifierEnums_HavingModifierKind_descriptor();
inline const ::std::string& ResolvedAggregateHavingModifierEnums_HavingModifierKind_Name(ResolvedAggregateHavingModifierEnums_HavingModifierKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedAggregateHavingModifierEnums_HavingModifierKind_descriptor(), value);
}
inline bool ResolvedAggregateHavingModifierEnums_HavingModifierKind_Parse(
    const ::std::string& name, ResolvedAggregateHavingModifierEnums_HavingModifierKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedAggregateHavingModifierEnums_HavingModifierKind>(
    ResolvedAggregateHavingModifierEnums_HavingModifierKind_descriptor(), name, value);
}
enum ResolvedStatementEnums_ObjectAccess {
  ResolvedStatementEnums_ObjectAccess_NONE = 0,
  ResolvedStatementEnums_ObjectAccess_READ = 1,
  ResolvedStatementEnums_ObjectAccess_WRITE = 2,
  ResolvedStatementEnums_ObjectAccess_READ_WRITE = 3
};
bool ResolvedStatementEnums_ObjectAccess_IsValid(int value);
const ResolvedStatementEnums_ObjectAccess ResolvedStatementEnums_ObjectAccess_ObjectAccess_MIN = ResolvedStatementEnums_ObjectAccess_NONE;
const ResolvedStatementEnums_ObjectAccess ResolvedStatementEnums_ObjectAccess_ObjectAccess_MAX = ResolvedStatementEnums_ObjectAccess_READ_WRITE;
const int ResolvedStatementEnums_ObjectAccess_ObjectAccess_ARRAYSIZE = ResolvedStatementEnums_ObjectAccess_ObjectAccess_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedStatementEnums_ObjectAccess_descriptor();
inline const ::std::string& ResolvedStatementEnums_ObjectAccess_Name(ResolvedStatementEnums_ObjectAccess value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedStatementEnums_ObjectAccess_descriptor(), value);
}
inline bool ResolvedStatementEnums_ObjectAccess_Parse(
    const ::std::string& name, ResolvedStatementEnums_ObjectAccess* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedStatementEnums_ObjectAccess>(
    ResolvedStatementEnums_ObjectAccess_descriptor(), name, value);
}
enum ResolvedImportStmtEnums_ImportKind {
  ResolvedImportStmtEnums_ImportKind_MODULE = 0,
  ResolvedImportStmtEnums_ImportKind_PROTO = 1,
  ResolvedImportStmtEnums_ImportKind___ImportKind__switch_must_have_a_default__ = -1
};
bool ResolvedImportStmtEnums_ImportKind_IsValid(int value);
const ResolvedImportStmtEnums_ImportKind ResolvedImportStmtEnums_ImportKind_ImportKind_MIN = ResolvedImportStmtEnums_ImportKind___ImportKind__switch_must_have_a_default__;
const ResolvedImportStmtEnums_ImportKind ResolvedImportStmtEnums_ImportKind_ImportKind_MAX = ResolvedImportStmtEnums_ImportKind_PROTO;
const int ResolvedImportStmtEnums_ImportKind_ImportKind_ARRAYSIZE = ResolvedImportStmtEnums_ImportKind_ImportKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedImportStmtEnums_ImportKind_descriptor();
inline const ::std::string& ResolvedImportStmtEnums_ImportKind_Name(ResolvedImportStmtEnums_ImportKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedImportStmtEnums_ImportKind_descriptor(), value);
}
inline bool ResolvedImportStmtEnums_ImportKind_Parse(
    const ::std::string& name, ResolvedImportStmtEnums_ImportKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedImportStmtEnums_ImportKind>(
    ResolvedImportStmtEnums_ImportKind_descriptor(), name, value);
}
enum ResolvedForeignKeyEnums_MatchMode {
  ResolvedForeignKeyEnums_MatchMode_SIMPLE = 0,
  ResolvedForeignKeyEnums_MatchMode_FULL = 1,
  ResolvedForeignKeyEnums_MatchMode_NOT_DISTINCT = 2
};
bool ResolvedForeignKeyEnums_MatchMode_IsValid(int value);
const ResolvedForeignKeyEnums_MatchMode ResolvedForeignKeyEnums_MatchMode_MatchMode_MIN = ResolvedForeignKeyEnums_MatchMode_SIMPLE;
const ResolvedForeignKeyEnums_MatchMode ResolvedForeignKeyEnums_MatchMode_MatchMode_MAX = ResolvedForeignKeyEnums_MatchMode_NOT_DISTINCT;
const int ResolvedForeignKeyEnums_MatchMode_MatchMode_ARRAYSIZE = ResolvedForeignKeyEnums_MatchMode_MatchMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedForeignKeyEnums_MatchMode_descriptor();
inline const ::std::string& ResolvedForeignKeyEnums_MatchMode_Name(ResolvedForeignKeyEnums_MatchMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedForeignKeyEnums_MatchMode_descriptor(), value);
}
inline bool ResolvedForeignKeyEnums_MatchMode_Parse(
    const ::std::string& name, ResolvedForeignKeyEnums_MatchMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedForeignKeyEnums_MatchMode>(
    ResolvedForeignKeyEnums_MatchMode_descriptor(), name, value);
}
enum ResolvedForeignKeyEnums_ActionOperation {
  ResolvedForeignKeyEnums_ActionOperation_NO_ACTION = 0,
  ResolvedForeignKeyEnums_ActionOperation_RESTRICT = 1,
  ResolvedForeignKeyEnums_ActionOperation_CASCADE = 2,
  ResolvedForeignKeyEnums_ActionOperation_SET_NULL = 3
};
bool ResolvedForeignKeyEnums_ActionOperation_IsValid(int value);
const ResolvedForeignKeyEnums_ActionOperation ResolvedForeignKeyEnums_ActionOperation_ActionOperation_MIN = ResolvedForeignKeyEnums_ActionOperation_NO_ACTION;
const ResolvedForeignKeyEnums_ActionOperation ResolvedForeignKeyEnums_ActionOperation_ActionOperation_MAX = ResolvedForeignKeyEnums_ActionOperation_SET_NULL;
const int ResolvedForeignKeyEnums_ActionOperation_ActionOperation_ARRAYSIZE = ResolvedForeignKeyEnums_ActionOperation_ActionOperation_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedForeignKeyEnums_ActionOperation_descriptor();
inline const ::std::string& ResolvedForeignKeyEnums_ActionOperation_Name(ResolvedForeignKeyEnums_ActionOperation value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedForeignKeyEnums_ActionOperation_descriptor(), value);
}
inline bool ResolvedForeignKeyEnums_ActionOperation_Parse(
    const ::std::string& name, ResolvedForeignKeyEnums_ActionOperation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedForeignKeyEnums_ActionOperation>(
    ResolvedForeignKeyEnums_ActionOperation_descriptor(), name, value);
}
enum ResolvedAuxLoadDataStmtEnums_InsertionMode {
  ResolvedAuxLoadDataStmtEnums_InsertionMode_NONE = 0,
  ResolvedAuxLoadDataStmtEnums_InsertionMode_APPEND = 1,
  ResolvedAuxLoadDataStmtEnums_InsertionMode_OVERWRITE = 2
};
bool ResolvedAuxLoadDataStmtEnums_InsertionMode_IsValid(int value);
const ResolvedAuxLoadDataStmtEnums_InsertionMode ResolvedAuxLoadDataStmtEnums_InsertionMode_InsertionMode_MIN = ResolvedAuxLoadDataStmtEnums_InsertionMode_NONE;
const ResolvedAuxLoadDataStmtEnums_InsertionMode ResolvedAuxLoadDataStmtEnums_InsertionMode_InsertionMode_MAX = ResolvedAuxLoadDataStmtEnums_InsertionMode_OVERWRITE;
const int ResolvedAuxLoadDataStmtEnums_InsertionMode_InsertionMode_ARRAYSIZE = ResolvedAuxLoadDataStmtEnums_InsertionMode_InsertionMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResolvedAuxLoadDataStmtEnums_InsertionMode_descriptor();
inline const ::std::string& ResolvedAuxLoadDataStmtEnums_InsertionMode_Name(ResolvedAuxLoadDataStmtEnums_InsertionMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResolvedAuxLoadDataStmtEnums_InsertionMode_descriptor(), value);
}
inline bool ResolvedAuxLoadDataStmtEnums_InsertionMode_Parse(
    const ::std::string& name, ResolvedAuxLoadDataStmtEnums_InsertionMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResolvedAuxLoadDataStmtEnums_InsertionMode>(
    ResolvedAuxLoadDataStmtEnums_InsertionMode_descriptor(), name, value);
}
// ===================================================================

class ResolvedSubqueryExprEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedSubqueryExprEnums) */ {
 public:
  ResolvedSubqueryExprEnums();
  virtual ~ResolvedSubqueryExprEnums();

  ResolvedSubqueryExprEnums(const ResolvedSubqueryExprEnums& from);

  inline ResolvedSubqueryExprEnums& operator=(const ResolvedSubqueryExprEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedSubqueryExprEnums(ResolvedSubqueryExprEnums&& from) noexcept
    : ResolvedSubqueryExprEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedSubqueryExprEnums& operator=(ResolvedSubqueryExprEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedSubqueryExprEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedSubqueryExprEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedSubqueryExprEnums*>(
               &_ResolvedSubqueryExprEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ResolvedSubqueryExprEnums* other);
  friend void swap(ResolvedSubqueryExprEnums& a, ResolvedSubqueryExprEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedSubqueryExprEnums* New() const final {
    return CreateMaybeMessage<ResolvedSubqueryExprEnums>(NULL);
  }

  ResolvedSubqueryExprEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedSubqueryExprEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedSubqueryExprEnums& from);
  void MergeFrom(const ResolvedSubqueryExprEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedSubqueryExprEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedSubqueryExprEnums_SubqueryType SubqueryType;
  static const SubqueryType SCALAR =
    ResolvedSubqueryExprEnums_SubqueryType_SCALAR;
  static const SubqueryType ARRAY =
    ResolvedSubqueryExprEnums_SubqueryType_ARRAY;
  static const SubqueryType EXISTS =
    ResolvedSubqueryExprEnums_SubqueryType_EXISTS;
  static const SubqueryType IN =
    ResolvedSubqueryExprEnums_SubqueryType_IN;
  static const SubqueryType LIKE_ANY =
    ResolvedSubqueryExprEnums_SubqueryType_LIKE_ANY;
  static const SubqueryType LIKE_ALL =
    ResolvedSubqueryExprEnums_SubqueryType_LIKE_ALL;
  static inline bool SubqueryType_IsValid(int value) {
    return ResolvedSubqueryExprEnums_SubqueryType_IsValid(value);
  }
  static const SubqueryType SubqueryType_MIN =
    ResolvedSubqueryExprEnums_SubqueryType_SubqueryType_MIN;
  static const SubqueryType SubqueryType_MAX =
    ResolvedSubqueryExprEnums_SubqueryType_SubqueryType_MAX;
  static const int SubqueryType_ARRAYSIZE =
    ResolvedSubqueryExprEnums_SubqueryType_SubqueryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SubqueryType_descriptor() {
    return ResolvedSubqueryExprEnums_SubqueryType_descriptor();
  }
  static inline const ::std::string& SubqueryType_Name(SubqueryType value) {
    return ResolvedSubqueryExprEnums_SubqueryType_Name(value);
  }
  static inline bool SubqueryType_Parse(const ::std::string& name,
      SubqueryType* value) {
    return ResolvedSubqueryExprEnums_SubqueryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedSubqueryExprEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedJoinScanEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedJoinScanEnums) */ {
 public:
  ResolvedJoinScanEnums();
  virtual ~ResolvedJoinScanEnums();

  ResolvedJoinScanEnums(const ResolvedJoinScanEnums& from);

  inline ResolvedJoinScanEnums& operator=(const ResolvedJoinScanEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedJoinScanEnums(ResolvedJoinScanEnums&& from) noexcept
    : ResolvedJoinScanEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedJoinScanEnums& operator=(ResolvedJoinScanEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedJoinScanEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedJoinScanEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedJoinScanEnums*>(
               &_ResolvedJoinScanEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ResolvedJoinScanEnums* other);
  friend void swap(ResolvedJoinScanEnums& a, ResolvedJoinScanEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedJoinScanEnums* New() const final {
    return CreateMaybeMessage<ResolvedJoinScanEnums>(NULL);
  }

  ResolvedJoinScanEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedJoinScanEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedJoinScanEnums& from);
  void MergeFrom(const ResolvedJoinScanEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedJoinScanEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedJoinScanEnums_JoinType JoinType;
  static const JoinType INNER =
    ResolvedJoinScanEnums_JoinType_INNER;
  static const JoinType LEFT =
    ResolvedJoinScanEnums_JoinType_LEFT;
  static const JoinType RIGHT =
    ResolvedJoinScanEnums_JoinType_RIGHT;
  static const JoinType FULL =
    ResolvedJoinScanEnums_JoinType_FULL;
  static inline bool JoinType_IsValid(int value) {
    return ResolvedJoinScanEnums_JoinType_IsValid(value);
  }
  static const JoinType JoinType_MIN =
    ResolvedJoinScanEnums_JoinType_JoinType_MIN;
  static const JoinType JoinType_MAX =
    ResolvedJoinScanEnums_JoinType_JoinType_MAX;
  static const int JoinType_ARRAYSIZE =
    ResolvedJoinScanEnums_JoinType_JoinType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  JoinType_descriptor() {
    return ResolvedJoinScanEnums_JoinType_descriptor();
  }
  static inline const ::std::string& JoinType_Name(JoinType value) {
    return ResolvedJoinScanEnums_JoinType_Name(value);
  }
  static inline bool JoinType_Parse(const ::std::string& name,
      JoinType* value) {
    return ResolvedJoinScanEnums_JoinType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedJoinScanEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedSetOperationScanEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedSetOperationScanEnums) */ {
 public:
  ResolvedSetOperationScanEnums();
  virtual ~ResolvedSetOperationScanEnums();

  ResolvedSetOperationScanEnums(const ResolvedSetOperationScanEnums& from);

  inline ResolvedSetOperationScanEnums& operator=(const ResolvedSetOperationScanEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedSetOperationScanEnums(ResolvedSetOperationScanEnums&& from) noexcept
    : ResolvedSetOperationScanEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedSetOperationScanEnums& operator=(ResolvedSetOperationScanEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedSetOperationScanEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedSetOperationScanEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedSetOperationScanEnums*>(
               &_ResolvedSetOperationScanEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ResolvedSetOperationScanEnums* other);
  friend void swap(ResolvedSetOperationScanEnums& a, ResolvedSetOperationScanEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedSetOperationScanEnums* New() const final {
    return CreateMaybeMessage<ResolvedSetOperationScanEnums>(NULL);
  }

  ResolvedSetOperationScanEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedSetOperationScanEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedSetOperationScanEnums& from);
  void MergeFrom(const ResolvedSetOperationScanEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedSetOperationScanEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedSetOperationScanEnums_SetOperationType SetOperationType;
  static const SetOperationType UNION_ALL =
    ResolvedSetOperationScanEnums_SetOperationType_UNION_ALL;
  static const SetOperationType UNION_DISTINCT =
    ResolvedSetOperationScanEnums_SetOperationType_UNION_DISTINCT;
  static const SetOperationType INTERSECT_ALL =
    ResolvedSetOperationScanEnums_SetOperationType_INTERSECT_ALL;
  static const SetOperationType INTERSECT_DISTINCT =
    ResolvedSetOperationScanEnums_SetOperationType_INTERSECT_DISTINCT;
  static const SetOperationType EXCEPT_ALL =
    ResolvedSetOperationScanEnums_SetOperationType_EXCEPT_ALL;
  static const SetOperationType EXCEPT_DISTINCT =
    ResolvedSetOperationScanEnums_SetOperationType_EXCEPT_DISTINCT;
  static inline bool SetOperationType_IsValid(int value) {
    return ResolvedSetOperationScanEnums_SetOperationType_IsValid(value);
  }
  static const SetOperationType SetOperationType_MIN =
    ResolvedSetOperationScanEnums_SetOperationType_SetOperationType_MIN;
  static const SetOperationType SetOperationType_MAX =
    ResolvedSetOperationScanEnums_SetOperationType_SetOperationType_MAX;
  static const int SetOperationType_ARRAYSIZE =
    ResolvedSetOperationScanEnums_SetOperationType_SetOperationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SetOperationType_descriptor() {
    return ResolvedSetOperationScanEnums_SetOperationType_descriptor();
  }
  static inline const ::std::string& SetOperationType_Name(SetOperationType value) {
    return ResolvedSetOperationScanEnums_SetOperationType_Name(value);
  }
  static inline bool SetOperationType_Parse(const ::std::string& name,
      SetOperationType* value) {
    return ResolvedSetOperationScanEnums_SetOperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedSetOperationScanEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedRecursiveScanEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedRecursiveScanEnums) */ {
 public:
  ResolvedRecursiveScanEnums();
  virtual ~ResolvedRecursiveScanEnums();

  ResolvedRecursiveScanEnums(const ResolvedRecursiveScanEnums& from);

  inline ResolvedRecursiveScanEnums& operator=(const ResolvedRecursiveScanEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedRecursiveScanEnums(ResolvedRecursiveScanEnums&& from) noexcept
    : ResolvedRecursiveScanEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedRecursiveScanEnums& operator=(ResolvedRecursiveScanEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedRecursiveScanEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedRecursiveScanEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedRecursiveScanEnums*>(
               &_ResolvedRecursiveScanEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ResolvedRecursiveScanEnums* other);
  friend void swap(ResolvedRecursiveScanEnums& a, ResolvedRecursiveScanEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedRecursiveScanEnums* New() const final {
    return CreateMaybeMessage<ResolvedRecursiveScanEnums>(NULL);
  }

  ResolvedRecursiveScanEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedRecursiveScanEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedRecursiveScanEnums& from);
  void MergeFrom(const ResolvedRecursiveScanEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedRecursiveScanEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedRecursiveScanEnums_RecursiveSetOperationType RecursiveSetOperationType;
  static const RecursiveSetOperationType UNION_ALL =
    ResolvedRecursiveScanEnums_RecursiveSetOperationType_UNION_ALL;
  static const RecursiveSetOperationType UNION_DISTINCT =
    ResolvedRecursiveScanEnums_RecursiveSetOperationType_UNION_DISTINCT;
  static inline bool RecursiveSetOperationType_IsValid(int value) {
    return ResolvedRecursiveScanEnums_RecursiveSetOperationType_IsValid(value);
  }
  static const RecursiveSetOperationType RecursiveSetOperationType_MIN =
    ResolvedRecursiveScanEnums_RecursiveSetOperationType_RecursiveSetOperationType_MIN;
  static const RecursiveSetOperationType RecursiveSetOperationType_MAX =
    ResolvedRecursiveScanEnums_RecursiveSetOperationType_RecursiveSetOperationType_MAX;
  static const int RecursiveSetOperationType_ARRAYSIZE =
    ResolvedRecursiveScanEnums_RecursiveSetOperationType_RecursiveSetOperationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RecursiveSetOperationType_descriptor() {
    return ResolvedRecursiveScanEnums_RecursiveSetOperationType_descriptor();
  }
  static inline const ::std::string& RecursiveSetOperationType_Name(RecursiveSetOperationType value) {
    return ResolvedRecursiveScanEnums_RecursiveSetOperationType_Name(value);
  }
  static inline bool RecursiveSetOperationType_Parse(const ::std::string& name,
      RecursiveSetOperationType* value) {
    return ResolvedRecursiveScanEnums_RecursiveSetOperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedRecursiveScanEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedSampleScanEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedSampleScanEnums) */ {
 public:
  ResolvedSampleScanEnums();
  virtual ~ResolvedSampleScanEnums();

  ResolvedSampleScanEnums(const ResolvedSampleScanEnums& from);

  inline ResolvedSampleScanEnums& operator=(const ResolvedSampleScanEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedSampleScanEnums(ResolvedSampleScanEnums&& from) noexcept
    : ResolvedSampleScanEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedSampleScanEnums& operator=(ResolvedSampleScanEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedSampleScanEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedSampleScanEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedSampleScanEnums*>(
               &_ResolvedSampleScanEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ResolvedSampleScanEnums* other);
  friend void swap(ResolvedSampleScanEnums& a, ResolvedSampleScanEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedSampleScanEnums* New() const final {
    return CreateMaybeMessage<ResolvedSampleScanEnums>(NULL);
  }

  ResolvedSampleScanEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedSampleScanEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedSampleScanEnums& from);
  void MergeFrom(const ResolvedSampleScanEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedSampleScanEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedSampleScanEnums_SampleUnit SampleUnit;
  static const SampleUnit ROWS =
    ResolvedSampleScanEnums_SampleUnit_ROWS;
  static const SampleUnit PERCENT =
    ResolvedSampleScanEnums_SampleUnit_PERCENT;
  static inline bool SampleUnit_IsValid(int value) {
    return ResolvedSampleScanEnums_SampleUnit_IsValid(value);
  }
  static const SampleUnit SampleUnit_MIN =
    ResolvedSampleScanEnums_SampleUnit_SampleUnit_MIN;
  static const SampleUnit SampleUnit_MAX =
    ResolvedSampleScanEnums_SampleUnit_SampleUnit_MAX;
  static const int SampleUnit_ARRAYSIZE =
    ResolvedSampleScanEnums_SampleUnit_SampleUnit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SampleUnit_descriptor() {
    return ResolvedSampleScanEnums_SampleUnit_descriptor();
  }
  static inline const ::std::string& SampleUnit_Name(SampleUnit value) {
    return ResolvedSampleScanEnums_SampleUnit_Name(value);
  }
  static inline bool SampleUnit_Parse(const ::std::string& name,
      SampleUnit* value) {
    return ResolvedSampleScanEnums_SampleUnit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedSampleScanEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedOrderByItemEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedOrderByItemEnums) */ {
 public:
  ResolvedOrderByItemEnums();
  virtual ~ResolvedOrderByItemEnums();

  ResolvedOrderByItemEnums(const ResolvedOrderByItemEnums& from);

  inline ResolvedOrderByItemEnums& operator=(const ResolvedOrderByItemEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedOrderByItemEnums(ResolvedOrderByItemEnums&& from) noexcept
    : ResolvedOrderByItemEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedOrderByItemEnums& operator=(ResolvedOrderByItemEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedOrderByItemEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedOrderByItemEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedOrderByItemEnums*>(
               &_ResolvedOrderByItemEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ResolvedOrderByItemEnums* other);
  friend void swap(ResolvedOrderByItemEnums& a, ResolvedOrderByItemEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedOrderByItemEnums* New() const final {
    return CreateMaybeMessage<ResolvedOrderByItemEnums>(NULL);
  }

  ResolvedOrderByItemEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedOrderByItemEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedOrderByItemEnums& from);
  void MergeFrom(const ResolvedOrderByItemEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedOrderByItemEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedOrderByItemEnums_NullOrderMode NullOrderMode;
  static const NullOrderMode ORDER_UNSPECIFIED =
    ResolvedOrderByItemEnums_NullOrderMode_ORDER_UNSPECIFIED;
  static const NullOrderMode NULLS_FIRST =
    ResolvedOrderByItemEnums_NullOrderMode_NULLS_FIRST;
  static const NullOrderMode NULLS_LAST =
    ResolvedOrderByItemEnums_NullOrderMode_NULLS_LAST;
  static inline bool NullOrderMode_IsValid(int value) {
    return ResolvedOrderByItemEnums_NullOrderMode_IsValid(value);
  }
  static const NullOrderMode NullOrderMode_MIN =
    ResolvedOrderByItemEnums_NullOrderMode_NullOrderMode_MIN;
  static const NullOrderMode NullOrderMode_MAX =
    ResolvedOrderByItemEnums_NullOrderMode_NullOrderMode_MAX;
  static const int NullOrderMode_ARRAYSIZE =
    ResolvedOrderByItemEnums_NullOrderMode_NullOrderMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NullOrderMode_descriptor() {
    return ResolvedOrderByItemEnums_NullOrderMode_descriptor();
  }
  static inline const ::std::string& NullOrderMode_Name(NullOrderMode value) {
    return ResolvedOrderByItemEnums_NullOrderMode_Name(value);
  }
  static inline bool NullOrderMode_Parse(const ::std::string& name,
      NullOrderMode* value) {
    return ResolvedOrderByItemEnums_NullOrderMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedOrderByItemEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedCreateStatementEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedCreateStatementEnums) */ {
 public:
  ResolvedCreateStatementEnums();
  virtual ~ResolvedCreateStatementEnums();

  ResolvedCreateStatementEnums(const ResolvedCreateStatementEnums& from);

  inline ResolvedCreateStatementEnums& operator=(const ResolvedCreateStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedCreateStatementEnums(ResolvedCreateStatementEnums&& from) noexcept
    : ResolvedCreateStatementEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedCreateStatementEnums& operator=(ResolvedCreateStatementEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedCreateStatementEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedCreateStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedCreateStatementEnums*>(
               &_ResolvedCreateStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ResolvedCreateStatementEnums* other);
  friend void swap(ResolvedCreateStatementEnums& a, ResolvedCreateStatementEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedCreateStatementEnums* New() const final {
    return CreateMaybeMessage<ResolvedCreateStatementEnums>(NULL);
  }

  ResolvedCreateStatementEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedCreateStatementEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedCreateStatementEnums& from);
  void MergeFrom(const ResolvedCreateStatementEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedCreateStatementEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedCreateStatementEnums_CreateScope CreateScope;
  static const CreateScope CREATE_DEFAULT_SCOPE =
    ResolvedCreateStatementEnums_CreateScope_CREATE_DEFAULT_SCOPE;
  static const CreateScope CREATE_PRIVATE =
    ResolvedCreateStatementEnums_CreateScope_CREATE_PRIVATE;
  static const CreateScope CREATE_PUBLIC =
    ResolvedCreateStatementEnums_CreateScope_CREATE_PUBLIC;
  static const CreateScope CREATE_TEMP =
    ResolvedCreateStatementEnums_CreateScope_CREATE_TEMP;
  static inline bool CreateScope_IsValid(int value) {
    return ResolvedCreateStatementEnums_CreateScope_IsValid(value);
  }
  static const CreateScope CreateScope_MIN =
    ResolvedCreateStatementEnums_CreateScope_CreateScope_MIN;
  static const CreateScope CreateScope_MAX =
    ResolvedCreateStatementEnums_CreateScope_CreateScope_MAX;
  static const int CreateScope_ARRAYSIZE =
    ResolvedCreateStatementEnums_CreateScope_CreateScope_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CreateScope_descriptor() {
    return ResolvedCreateStatementEnums_CreateScope_descriptor();
  }
  static inline const ::std::string& CreateScope_Name(CreateScope value) {
    return ResolvedCreateStatementEnums_CreateScope_Name(value);
  }
  static inline bool CreateScope_Parse(const ::std::string& name,
      CreateScope* value) {
    return ResolvedCreateStatementEnums_CreateScope_Parse(name, value);
  }

  typedef ResolvedCreateStatementEnums_CreateMode CreateMode;
  static const CreateMode CREATE_DEFAULT =
    ResolvedCreateStatementEnums_CreateMode_CREATE_DEFAULT;
  static const CreateMode CREATE_OR_REPLACE =
    ResolvedCreateStatementEnums_CreateMode_CREATE_OR_REPLACE;
  static const CreateMode CREATE_IF_NOT_EXISTS =
    ResolvedCreateStatementEnums_CreateMode_CREATE_IF_NOT_EXISTS;
  static inline bool CreateMode_IsValid(int value) {
    return ResolvedCreateStatementEnums_CreateMode_IsValid(value);
  }
  static const CreateMode CreateMode_MIN =
    ResolvedCreateStatementEnums_CreateMode_CreateMode_MIN;
  static const CreateMode CreateMode_MAX =
    ResolvedCreateStatementEnums_CreateMode_CreateMode_MAX;
  static const int CreateMode_ARRAYSIZE =
    ResolvedCreateStatementEnums_CreateMode_CreateMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CreateMode_descriptor() {
    return ResolvedCreateStatementEnums_CreateMode_descriptor();
  }
  static inline const ::std::string& CreateMode_Name(CreateMode value) {
    return ResolvedCreateStatementEnums_CreateMode_Name(value);
  }
  static inline bool CreateMode_Parse(const ::std::string& name,
      CreateMode* value) {
    return ResolvedCreateStatementEnums_CreateMode_Parse(name, value);
  }

  typedef ResolvedCreateStatementEnums_SqlSecurity SqlSecurity;
  static const SqlSecurity SQL_SECURITY_UNSPECIFIED =
    ResolvedCreateStatementEnums_SqlSecurity_SQL_SECURITY_UNSPECIFIED;
  static const SqlSecurity SQL_SECURITY_DEFINER =
    ResolvedCreateStatementEnums_SqlSecurity_SQL_SECURITY_DEFINER;
  static const SqlSecurity SQL_SECURITY_INVOKER =
    ResolvedCreateStatementEnums_SqlSecurity_SQL_SECURITY_INVOKER;
  static inline bool SqlSecurity_IsValid(int value) {
    return ResolvedCreateStatementEnums_SqlSecurity_IsValid(value);
  }
  static const SqlSecurity SqlSecurity_MIN =
    ResolvedCreateStatementEnums_SqlSecurity_SqlSecurity_MIN;
  static const SqlSecurity SqlSecurity_MAX =
    ResolvedCreateStatementEnums_SqlSecurity_SqlSecurity_MAX;
  static const int SqlSecurity_ARRAYSIZE =
    ResolvedCreateStatementEnums_SqlSecurity_SqlSecurity_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SqlSecurity_descriptor() {
    return ResolvedCreateStatementEnums_SqlSecurity_descriptor();
  }
  static inline const ::std::string& SqlSecurity_Name(SqlSecurity value) {
    return ResolvedCreateStatementEnums_SqlSecurity_Name(value);
  }
  static inline bool SqlSecurity_Parse(const ::std::string& name,
      SqlSecurity* value) {
    return ResolvedCreateStatementEnums_SqlSecurity_Parse(name, value);
  }

  typedef ResolvedCreateStatementEnums_DeterminismLevel DeterminismLevel;
  static const DeterminismLevel DETERMINISM_UNSPECIFIED =
    ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_UNSPECIFIED;
  static const DeterminismLevel DETERMINISM_DETERMINISTIC =
    ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_DETERMINISTIC;
  static const DeterminismLevel DETERMINISM_NOT_DETERMINISTIC =
    ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_NOT_DETERMINISTIC;
  static const DeterminismLevel DETERMINISM_IMMUTABLE =
    ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_IMMUTABLE;
  static const DeterminismLevel DETERMINISM_STABLE =
    ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_STABLE;
  static const DeterminismLevel DETERMINISM_VOLATILE =
    ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_VOLATILE;
  static inline bool DeterminismLevel_IsValid(int value) {
    return ResolvedCreateStatementEnums_DeterminismLevel_IsValid(value);
  }
  static const DeterminismLevel DeterminismLevel_MIN =
    ResolvedCreateStatementEnums_DeterminismLevel_DeterminismLevel_MIN;
  static const DeterminismLevel DeterminismLevel_MAX =
    ResolvedCreateStatementEnums_DeterminismLevel_DeterminismLevel_MAX;
  static const int DeterminismLevel_ARRAYSIZE =
    ResolvedCreateStatementEnums_DeterminismLevel_DeterminismLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DeterminismLevel_descriptor() {
    return ResolvedCreateStatementEnums_DeterminismLevel_descriptor();
  }
  static inline const ::std::string& DeterminismLevel_Name(DeterminismLevel value) {
    return ResolvedCreateStatementEnums_DeterminismLevel_Name(value);
  }
  static inline bool DeterminismLevel_Parse(const ::std::string& name,
      DeterminismLevel* value) {
    return ResolvedCreateStatementEnums_DeterminismLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedCreateStatementEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedGeneratedColumnInfoEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedGeneratedColumnInfoEnums) */ {
 public:
  ResolvedGeneratedColumnInfoEnums();
  virtual ~ResolvedGeneratedColumnInfoEnums();

  ResolvedGeneratedColumnInfoEnums(const ResolvedGeneratedColumnInfoEnums& from);

  inline ResolvedGeneratedColumnInfoEnums& operator=(const ResolvedGeneratedColumnInfoEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedGeneratedColumnInfoEnums(ResolvedGeneratedColumnInfoEnums&& from) noexcept
    : ResolvedGeneratedColumnInfoEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedGeneratedColumnInfoEnums& operator=(ResolvedGeneratedColumnInfoEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedGeneratedColumnInfoEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedGeneratedColumnInfoEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedGeneratedColumnInfoEnums*>(
               &_ResolvedGeneratedColumnInfoEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ResolvedGeneratedColumnInfoEnums* other);
  friend void swap(ResolvedGeneratedColumnInfoEnums& a, ResolvedGeneratedColumnInfoEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedGeneratedColumnInfoEnums* New() const final {
    return CreateMaybeMessage<ResolvedGeneratedColumnInfoEnums>(NULL);
  }

  ResolvedGeneratedColumnInfoEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedGeneratedColumnInfoEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedGeneratedColumnInfoEnums& from);
  void MergeFrom(const ResolvedGeneratedColumnInfoEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedGeneratedColumnInfoEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedGeneratedColumnInfoEnums_StoredMode StoredMode;
  static const StoredMode NON_STORED =
    ResolvedGeneratedColumnInfoEnums_StoredMode_NON_STORED;
  static const StoredMode STORED =
    ResolvedGeneratedColumnInfoEnums_StoredMode_STORED;
  static const StoredMode STORED_VOLATILE =
    ResolvedGeneratedColumnInfoEnums_StoredMode_STORED_VOLATILE;
  static inline bool StoredMode_IsValid(int value) {
    return ResolvedGeneratedColumnInfoEnums_StoredMode_IsValid(value);
  }
  static const StoredMode StoredMode_MIN =
    ResolvedGeneratedColumnInfoEnums_StoredMode_StoredMode_MIN;
  static const StoredMode StoredMode_MAX =
    ResolvedGeneratedColumnInfoEnums_StoredMode_StoredMode_MAX;
  static const int StoredMode_ARRAYSIZE =
    ResolvedGeneratedColumnInfoEnums_StoredMode_StoredMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StoredMode_descriptor() {
    return ResolvedGeneratedColumnInfoEnums_StoredMode_descriptor();
  }
  static inline const ::std::string& StoredMode_Name(StoredMode value) {
    return ResolvedGeneratedColumnInfoEnums_StoredMode_Name(value);
  }
  static inline bool StoredMode_Parse(const ::std::string& name,
      StoredMode* value) {
    return ResolvedGeneratedColumnInfoEnums_StoredMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedGeneratedColumnInfoEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedDropStmtEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedDropStmtEnums) */ {
 public:
  ResolvedDropStmtEnums();
  virtual ~ResolvedDropStmtEnums();

  ResolvedDropStmtEnums(const ResolvedDropStmtEnums& from);

  inline ResolvedDropStmtEnums& operator=(const ResolvedDropStmtEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedDropStmtEnums(ResolvedDropStmtEnums&& from) noexcept
    : ResolvedDropStmtEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedDropStmtEnums& operator=(ResolvedDropStmtEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedDropStmtEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedDropStmtEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedDropStmtEnums*>(
               &_ResolvedDropStmtEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ResolvedDropStmtEnums* other);
  friend void swap(ResolvedDropStmtEnums& a, ResolvedDropStmtEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedDropStmtEnums* New() const final {
    return CreateMaybeMessage<ResolvedDropStmtEnums>(NULL);
  }

  ResolvedDropStmtEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedDropStmtEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedDropStmtEnums& from);
  void MergeFrom(const ResolvedDropStmtEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedDropStmtEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedDropStmtEnums_DropMode DropMode;
  static const DropMode DROP_MODE_UNSPECIFIED =
    ResolvedDropStmtEnums_DropMode_DROP_MODE_UNSPECIFIED;
  static const DropMode RESTRICT =
    ResolvedDropStmtEnums_DropMode_RESTRICT;
  static const DropMode CASCADE =
    ResolvedDropStmtEnums_DropMode_CASCADE;
  static inline bool DropMode_IsValid(int value) {
    return ResolvedDropStmtEnums_DropMode_IsValid(value);
  }
  static const DropMode DropMode_MIN =
    ResolvedDropStmtEnums_DropMode_DropMode_MIN;
  static const DropMode DropMode_MAX =
    ResolvedDropStmtEnums_DropMode_DropMode_MAX;
  static const int DropMode_ARRAYSIZE =
    ResolvedDropStmtEnums_DropMode_DropMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DropMode_descriptor() {
    return ResolvedDropStmtEnums_DropMode_descriptor();
  }
  static inline const ::std::string& DropMode_Name(DropMode value) {
    return ResolvedDropStmtEnums_DropMode_Name(value);
  }
  static inline bool DropMode_Parse(const ::std::string& name,
      DropMode* value) {
    return ResolvedDropStmtEnums_DropMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedDropStmtEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedBeginStmtEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedBeginStmtEnums) */ {
 public:
  ResolvedBeginStmtEnums();
  virtual ~ResolvedBeginStmtEnums();

  ResolvedBeginStmtEnums(const ResolvedBeginStmtEnums& from);

  inline ResolvedBeginStmtEnums& operator=(const ResolvedBeginStmtEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedBeginStmtEnums(ResolvedBeginStmtEnums&& from) noexcept
    : ResolvedBeginStmtEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedBeginStmtEnums& operator=(ResolvedBeginStmtEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedBeginStmtEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedBeginStmtEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedBeginStmtEnums*>(
               &_ResolvedBeginStmtEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ResolvedBeginStmtEnums* other);
  friend void swap(ResolvedBeginStmtEnums& a, ResolvedBeginStmtEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedBeginStmtEnums* New() const final {
    return CreateMaybeMessage<ResolvedBeginStmtEnums>(NULL);
  }

  ResolvedBeginStmtEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedBeginStmtEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedBeginStmtEnums& from);
  void MergeFrom(const ResolvedBeginStmtEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedBeginStmtEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedBeginStmtEnums_ReadWriteMode ReadWriteMode;
  static const ReadWriteMode MODE_UNSPECIFIED =
    ResolvedBeginStmtEnums_ReadWriteMode_MODE_UNSPECIFIED;
  static const ReadWriteMode MODE_READ_ONLY =
    ResolvedBeginStmtEnums_ReadWriteMode_MODE_READ_ONLY;
  static const ReadWriteMode MODE_READ_WRITE =
    ResolvedBeginStmtEnums_ReadWriteMode_MODE_READ_WRITE;
  static inline bool ReadWriteMode_IsValid(int value) {
    return ResolvedBeginStmtEnums_ReadWriteMode_IsValid(value);
  }
  static const ReadWriteMode ReadWriteMode_MIN =
    ResolvedBeginStmtEnums_ReadWriteMode_ReadWriteMode_MIN;
  static const ReadWriteMode ReadWriteMode_MAX =
    ResolvedBeginStmtEnums_ReadWriteMode_ReadWriteMode_MAX;
  static const int ReadWriteMode_ARRAYSIZE =
    ResolvedBeginStmtEnums_ReadWriteMode_ReadWriteMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ReadWriteMode_descriptor() {
    return ResolvedBeginStmtEnums_ReadWriteMode_descriptor();
  }
  static inline const ::std::string& ReadWriteMode_Name(ReadWriteMode value) {
    return ResolvedBeginStmtEnums_ReadWriteMode_Name(value);
  }
  static inline bool ReadWriteMode_Parse(const ::std::string& name,
      ReadWriteMode* value) {
    return ResolvedBeginStmtEnums_ReadWriteMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedBeginStmtEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedWindowFrameEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedWindowFrameEnums) */ {
 public:
  ResolvedWindowFrameEnums();
  virtual ~ResolvedWindowFrameEnums();

  ResolvedWindowFrameEnums(const ResolvedWindowFrameEnums& from);

  inline ResolvedWindowFrameEnums& operator=(const ResolvedWindowFrameEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedWindowFrameEnums(ResolvedWindowFrameEnums&& from) noexcept
    : ResolvedWindowFrameEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedWindowFrameEnums& operator=(ResolvedWindowFrameEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedWindowFrameEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedWindowFrameEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedWindowFrameEnums*>(
               &_ResolvedWindowFrameEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ResolvedWindowFrameEnums* other);
  friend void swap(ResolvedWindowFrameEnums& a, ResolvedWindowFrameEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedWindowFrameEnums* New() const final {
    return CreateMaybeMessage<ResolvedWindowFrameEnums>(NULL);
  }

  ResolvedWindowFrameEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedWindowFrameEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedWindowFrameEnums& from);
  void MergeFrom(const ResolvedWindowFrameEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedWindowFrameEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedWindowFrameEnums_FrameUnit FrameUnit;
  static const FrameUnit ROWS =
    ResolvedWindowFrameEnums_FrameUnit_ROWS;
  static const FrameUnit RANGE =
    ResolvedWindowFrameEnums_FrameUnit_RANGE;
  static inline bool FrameUnit_IsValid(int value) {
    return ResolvedWindowFrameEnums_FrameUnit_IsValid(value);
  }
  static const FrameUnit FrameUnit_MIN =
    ResolvedWindowFrameEnums_FrameUnit_FrameUnit_MIN;
  static const FrameUnit FrameUnit_MAX =
    ResolvedWindowFrameEnums_FrameUnit_FrameUnit_MAX;
  static const int FrameUnit_ARRAYSIZE =
    ResolvedWindowFrameEnums_FrameUnit_FrameUnit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FrameUnit_descriptor() {
    return ResolvedWindowFrameEnums_FrameUnit_descriptor();
  }
  static inline const ::std::string& FrameUnit_Name(FrameUnit value) {
    return ResolvedWindowFrameEnums_FrameUnit_Name(value);
  }
  static inline bool FrameUnit_Parse(const ::std::string& name,
      FrameUnit* value) {
    return ResolvedWindowFrameEnums_FrameUnit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedWindowFrameEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedWindowFrameExprEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedWindowFrameExprEnums) */ {
 public:
  ResolvedWindowFrameExprEnums();
  virtual ~ResolvedWindowFrameExprEnums();

  ResolvedWindowFrameExprEnums(const ResolvedWindowFrameExprEnums& from);

  inline ResolvedWindowFrameExprEnums& operator=(const ResolvedWindowFrameExprEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedWindowFrameExprEnums(ResolvedWindowFrameExprEnums&& from) noexcept
    : ResolvedWindowFrameExprEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedWindowFrameExprEnums& operator=(ResolvedWindowFrameExprEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedWindowFrameExprEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedWindowFrameExprEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedWindowFrameExprEnums*>(
               &_ResolvedWindowFrameExprEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ResolvedWindowFrameExprEnums* other);
  friend void swap(ResolvedWindowFrameExprEnums& a, ResolvedWindowFrameExprEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedWindowFrameExprEnums* New() const final {
    return CreateMaybeMessage<ResolvedWindowFrameExprEnums>(NULL);
  }

  ResolvedWindowFrameExprEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedWindowFrameExprEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedWindowFrameExprEnums& from);
  void MergeFrom(const ResolvedWindowFrameExprEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedWindowFrameExprEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedWindowFrameExprEnums_BoundaryType BoundaryType;
  static const BoundaryType UNBOUNDED_PRECEDING =
    ResolvedWindowFrameExprEnums_BoundaryType_UNBOUNDED_PRECEDING;
  static const BoundaryType OFFSET_PRECEDING =
    ResolvedWindowFrameExprEnums_BoundaryType_OFFSET_PRECEDING;
  static const BoundaryType CURRENT_ROW =
    ResolvedWindowFrameExprEnums_BoundaryType_CURRENT_ROW;
  static const BoundaryType OFFSET_FOLLOWING =
    ResolvedWindowFrameExprEnums_BoundaryType_OFFSET_FOLLOWING;
  static const BoundaryType UNBOUNDED_FOLLOWING =
    ResolvedWindowFrameExprEnums_BoundaryType_UNBOUNDED_FOLLOWING;
  static inline bool BoundaryType_IsValid(int value) {
    return ResolvedWindowFrameExprEnums_BoundaryType_IsValid(value);
  }
  static const BoundaryType BoundaryType_MIN =
    ResolvedWindowFrameExprEnums_BoundaryType_BoundaryType_MIN;
  static const BoundaryType BoundaryType_MAX =
    ResolvedWindowFrameExprEnums_BoundaryType_BoundaryType_MAX;
  static const int BoundaryType_ARRAYSIZE =
    ResolvedWindowFrameExprEnums_BoundaryType_BoundaryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BoundaryType_descriptor() {
    return ResolvedWindowFrameExprEnums_BoundaryType_descriptor();
  }
  static inline const ::std::string& BoundaryType_Name(BoundaryType value) {
    return ResolvedWindowFrameExprEnums_BoundaryType_Name(value);
  }
  static inline bool BoundaryType_Parse(const ::std::string& name,
      BoundaryType* value) {
    return ResolvedWindowFrameExprEnums_BoundaryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedWindowFrameExprEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedInsertStmtEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedInsertStmtEnums) */ {
 public:
  ResolvedInsertStmtEnums();
  virtual ~ResolvedInsertStmtEnums();

  ResolvedInsertStmtEnums(const ResolvedInsertStmtEnums& from);

  inline ResolvedInsertStmtEnums& operator=(const ResolvedInsertStmtEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedInsertStmtEnums(ResolvedInsertStmtEnums&& from) noexcept
    : ResolvedInsertStmtEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedInsertStmtEnums& operator=(ResolvedInsertStmtEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedInsertStmtEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedInsertStmtEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedInsertStmtEnums*>(
               &_ResolvedInsertStmtEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ResolvedInsertStmtEnums* other);
  friend void swap(ResolvedInsertStmtEnums& a, ResolvedInsertStmtEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedInsertStmtEnums* New() const final {
    return CreateMaybeMessage<ResolvedInsertStmtEnums>(NULL);
  }

  ResolvedInsertStmtEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedInsertStmtEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedInsertStmtEnums& from);
  void MergeFrom(const ResolvedInsertStmtEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedInsertStmtEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedInsertStmtEnums_InsertMode InsertMode;
  static const InsertMode OR_ERROR =
    ResolvedInsertStmtEnums_InsertMode_OR_ERROR;
  static const InsertMode OR_IGNORE =
    ResolvedInsertStmtEnums_InsertMode_OR_IGNORE;
  static const InsertMode OR_REPLACE =
    ResolvedInsertStmtEnums_InsertMode_OR_REPLACE;
  static const InsertMode OR_UPDATE =
    ResolvedInsertStmtEnums_InsertMode_OR_UPDATE;
  static inline bool InsertMode_IsValid(int value) {
    return ResolvedInsertStmtEnums_InsertMode_IsValid(value);
  }
  static const InsertMode InsertMode_MIN =
    ResolvedInsertStmtEnums_InsertMode_InsertMode_MIN;
  static const InsertMode InsertMode_MAX =
    ResolvedInsertStmtEnums_InsertMode_InsertMode_MAX;
  static const int InsertMode_ARRAYSIZE =
    ResolvedInsertStmtEnums_InsertMode_InsertMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InsertMode_descriptor() {
    return ResolvedInsertStmtEnums_InsertMode_descriptor();
  }
  static inline const ::std::string& InsertMode_Name(InsertMode value) {
    return ResolvedInsertStmtEnums_InsertMode_Name(value);
  }
  static inline bool InsertMode_Parse(const ::std::string& name,
      InsertMode* value) {
    return ResolvedInsertStmtEnums_InsertMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedInsertStmtEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedMergeWhenEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedMergeWhenEnums) */ {
 public:
  ResolvedMergeWhenEnums();
  virtual ~ResolvedMergeWhenEnums();

  ResolvedMergeWhenEnums(const ResolvedMergeWhenEnums& from);

  inline ResolvedMergeWhenEnums& operator=(const ResolvedMergeWhenEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedMergeWhenEnums(ResolvedMergeWhenEnums&& from) noexcept
    : ResolvedMergeWhenEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedMergeWhenEnums& operator=(ResolvedMergeWhenEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedMergeWhenEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedMergeWhenEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedMergeWhenEnums*>(
               &_ResolvedMergeWhenEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ResolvedMergeWhenEnums* other);
  friend void swap(ResolvedMergeWhenEnums& a, ResolvedMergeWhenEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedMergeWhenEnums* New() const final {
    return CreateMaybeMessage<ResolvedMergeWhenEnums>(NULL);
  }

  ResolvedMergeWhenEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedMergeWhenEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedMergeWhenEnums& from);
  void MergeFrom(const ResolvedMergeWhenEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedMergeWhenEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedMergeWhenEnums_MatchType MatchType;
  static const MatchType MATCHED =
    ResolvedMergeWhenEnums_MatchType_MATCHED;
  static const MatchType NOT_MATCHED_BY_SOURCE =
    ResolvedMergeWhenEnums_MatchType_NOT_MATCHED_BY_SOURCE;
  static const MatchType NOT_MATCHED_BY_TARGET =
    ResolvedMergeWhenEnums_MatchType_NOT_MATCHED_BY_TARGET;
  static inline bool MatchType_IsValid(int value) {
    return ResolvedMergeWhenEnums_MatchType_IsValid(value);
  }
  static const MatchType MatchType_MIN =
    ResolvedMergeWhenEnums_MatchType_MatchType_MIN;
  static const MatchType MatchType_MAX =
    ResolvedMergeWhenEnums_MatchType_MatchType_MAX;
  static const int MatchType_ARRAYSIZE =
    ResolvedMergeWhenEnums_MatchType_MatchType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MatchType_descriptor() {
    return ResolvedMergeWhenEnums_MatchType_descriptor();
  }
  static inline const ::std::string& MatchType_Name(MatchType value) {
    return ResolvedMergeWhenEnums_MatchType_Name(value);
  }
  static inline bool MatchType_Parse(const ::std::string& name,
      MatchType* value) {
    return ResolvedMergeWhenEnums_MatchType_Parse(name, value);
  }

  typedef ResolvedMergeWhenEnums_ActionType ActionType;
  static const ActionType INSERT =
    ResolvedMergeWhenEnums_ActionType_INSERT;
  static const ActionType UPDATE =
    ResolvedMergeWhenEnums_ActionType_UPDATE;
  static const ActionType DELETE =
    ResolvedMergeWhenEnums_ActionType_DELETE;
  static inline bool ActionType_IsValid(int value) {
    return ResolvedMergeWhenEnums_ActionType_IsValid(value);
  }
  static const ActionType ActionType_MIN =
    ResolvedMergeWhenEnums_ActionType_ActionType_MIN;
  static const ActionType ActionType_MAX =
    ResolvedMergeWhenEnums_ActionType_ActionType_MAX;
  static const int ActionType_ARRAYSIZE =
    ResolvedMergeWhenEnums_ActionType_ActionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionType_descriptor() {
    return ResolvedMergeWhenEnums_ActionType_descriptor();
  }
  static inline const ::std::string& ActionType_Name(ActionType value) {
    return ResolvedMergeWhenEnums_ActionType_Name(value);
  }
  static inline bool ActionType_Parse(const ::std::string& name,
      ActionType* value) {
    return ResolvedMergeWhenEnums_ActionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedMergeWhenEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedArgumentDefEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedArgumentDefEnums) */ {
 public:
  ResolvedArgumentDefEnums();
  virtual ~ResolvedArgumentDefEnums();

  ResolvedArgumentDefEnums(const ResolvedArgumentDefEnums& from);

  inline ResolvedArgumentDefEnums& operator=(const ResolvedArgumentDefEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedArgumentDefEnums(ResolvedArgumentDefEnums&& from) noexcept
    : ResolvedArgumentDefEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedArgumentDefEnums& operator=(ResolvedArgumentDefEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedArgumentDefEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedArgumentDefEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedArgumentDefEnums*>(
               &_ResolvedArgumentDefEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ResolvedArgumentDefEnums* other);
  friend void swap(ResolvedArgumentDefEnums& a, ResolvedArgumentDefEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedArgumentDefEnums* New() const final {
    return CreateMaybeMessage<ResolvedArgumentDefEnums>(NULL);
  }

  ResolvedArgumentDefEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedArgumentDefEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedArgumentDefEnums& from);
  void MergeFrom(const ResolvedArgumentDefEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedArgumentDefEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedArgumentDefEnums_ArgumentKind ArgumentKind;
  static const ArgumentKind SCALAR =
    ResolvedArgumentDefEnums_ArgumentKind_SCALAR;
  static const ArgumentKind AGGREGATE =
    ResolvedArgumentDefEnums_ArgumentKind_AGGREGATE;
  static const ArgumentKind NOT_AGGREGATE =
    ResolvedArgumentDefEnums_ArgumentKind_NOT_AGGREGATE;
  static inline bool ArgumentKind_IsValid(int value) {
    return ResolvedArgumentDefEnums_ArgumentKind_IsValid(value);
  }
  static const ArgumentKind ArgumentKind_MIN =
    ResolvedArgumentDefEnums_ArgumentKind_ArgumentKind_MIN;
  static const ArgumentKind ArgumentKind_MAX =
    ResolvedArgumentDefEnums_ArgumentKind_ArgumentKind_MAX;
  static const int ArgumentKind_ARRAYSIZE =
    ResolvedArgumentDefEnums_ArgumentKind_ArgumentKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ArgumentKind_descriptor() {
    return ResolvedArgumentDefEnums_ArgumentKind_descriptor();
  }
  static inline const ::std::string& ArgumentKind_Name(ArgumentKind value) {
    return ResolvedArgumentDefEnums_ArgumentKind_Name(value);
  }
  static inline bool ArgumentKind_Parse(const ::std::string& name,
      ArgumentKind* value) {
    return ResolvedArgumentDefEnums_ArgumentKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedArgumentDefEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedFunctionCallBaseEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedFunctionCallBaseEnums) */ {
 public:
  ResolvedFunctionCallBaseEnums();
  virtual ~ResolvedFunctionCallBaseEnums();

  ResolvedFunctionCallBaseEnums(const ResolvedFunctionCallBaseEnums& from);

  inline ResolvedFunctionCallBaseEnums& operator=(const ResolvedFunctionCallBaseEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedFunctionCallBaseEnums(ResolvedFunctionCallBaseEnums&& from) noexcept
    : ResolvedFunctionCallBaseEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedFunctionCallBaseEnums& operator=(ResolvedFunctionCallBaseEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedFunctionCallBaseEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedFunctionCallBaseEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedFunctionCallBaseEnums*>(
               &_ResolvedFunctionCallBaseEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ResolvedFunctionCallBaseEnums* other);
  friend void swap(ResolvedFunctionCallBaseEnums& a, ResolvedFunctionCallBaseEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedFunctionCallBaseEnums* New() const final {
    return CreateMaybeMessage<ResolvedFunctionCallBaseEnums>(NULL);
  }

  ResolvedFunctionCallBaseEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedFunctionCallBaseEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedFunctionCallBaseEnums& from);
  void MergeFrom(const ResolvedFunctionCallBaseEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedFunctionCallBaseEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedFunctionCallBaseEnums_ErrorMode ErrorMode;
  static const ErrorMode DEFAULT_ERROR_MODE =
    ResolvedFunctionCallBaseEnums_ErrorMode_DEFAULT_ERROR_MODE;
  static const ErrorMode SAFE_ERROR_MODE =
    ResolvedFunctionCallBaseEnums_ErrorMode_SAFE_ERROR_MODE;
  static inline bool ErrorMode_IsValid(int value) {
    return ResolvedFunctionCallBaseEnums_ErrorMode_IsValid(value);
  }
  static const ErrorMode ErrorMode_MIN =
    ResolvedFunctionCallBaseEnums_ErrorMode_ErrorMode_MIN;
  static const ErrorMode ErrorMode_MAX =
    ResolvedFunctionCallBaseEnums_ErrorMode_ErrorMode_MAX;
  static const int ErrorMode_ARRAYSIZE =
    ResolvedFunctionCallBaseEnums_ErrorMode_ErrorMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorMode_descriptor() {
    return ResolvedFunctionCallBaseEnums_ErrorMode_descriptor();
  }
  static inline const ::std::string& ErrorMode_Name(ErrorMode value) {
    return ResolvedFunctionCallBaseEnums_ErrorMode_Name(value);
  }
  static inline bool ErrorMode_Parse(const ::std::string& name,
      ErrorMode* value) {
    return ResolvedFunctionCallBaseEnums_ErrorMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedFunctionCallBaseEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedNonScalarFunctionCallBaseEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedNonScalarFunctionCallBaseEnums) */ {
 public:
  ResolvedNonScalarFunctionCallBaseEnums();
  virtual ~ResolvedNonScalarFunctionCallBaseEnums();

  ResolvedNonScalarFunctionCallBaseEnums(const ResolvedNonScalarFunctionCallBaseEnums& from);

  inline ResolvedNonScalarFunctionCallBaseEnums& operator=(const ResolvedNonScalarFunctionCallBaseEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedNonScalarFunctionCallBaseEnums(ResolvedNonScalarFunctionCallBaseEnums&& from) noexcept
    : ResolvedNonScalarFunctionCallBaseEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedNonScalarFunctionCallBaseEnums& operator=(ResolvedNonScalarFunctionCallBaseEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedNonScalarFunctionCallBaseEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedNonScalarFunctionCallBaseEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedNonScalarFunctionCallBaseEnums*>(
               &_ResolvedNonScalarFunctionCallBaseEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ResolvedNonScalarFunctionCallBaseEnums* other);
  friend void swap(ResolvedNonScalarFunctionCallBaseEnums& a, ResolvedNonScalarFunctionCallBaseEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedNonScalarFunctionCallBaseEnums* New() const final {
    return CreateMaybeMessage<ResolvedNonScalarFunctionCallBaseEnums>(NULL);
  }

  ResolvedNonScalarFunctionCallBaseEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedNonScalarFunctionCallBaseEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedNonScalarFunctionCallBaseEnums& from);
  void MergeFrom(const ResolvedNonScalarFunctionCallBaseEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedNonScalarFunctionCallBaseEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier NullHandlingModifier;
  static const NullHandlingModifier DEFAULT_NULL_HANDLING =
    ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_DEFAULT_NULL_HANDLING;
  static const NullHandlingModifier IGNORE_NULLS =
    ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_IGNORE_NULLS;
  static const NullHandlingModifier RESPECT_NULLS =
    ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_RESPECT_NULLS;
  static inline bool NullHandlingModifier_IsValid(int value) {
    return ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_IsValid(value);
  }
  static const NullHandlingModifier NullHandlingModifier_MIN =
    ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_NullHandlingModifier_MIN;
  static const NullHandlingModifier NullHandlingModifier_MAX =
    ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_NullHandlingModifier_MAX;
  static const int NullHandlingModifier_ARRAYSIZE =
    ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_NullHandlingModifier_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NullHandlingModifier_descriptor() {
    return ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_descriptor();
  }
  static inline const ::std::string& NullHandlingModifier_Name(NullHandlingModifier value) {
    return ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_Name(value);
  }
  static inline bool NullHandlingModifier_Parse(const ::std::string& name,
      NullHandlingModifier* value) {
    return ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedNonScalarFunctionCallBaseEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedAggregateHavingModifierEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedAggregateHavingModifierEnums) */ {
 public:
  ResolvedAggregateHavingModifierEnums();
  virtual ~ResolvedAggregateHavingModifierEnums();

  ResolvedAggregateHavingModifierEnums(const ResolvedAggregateHavingModifierEnums& from);

  inline ResolvedAggregateHavingModifierEnums& operator=(const ResolvedAggregateHavingModifierEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedAggregateHavingModifierEnums(ResolvedAggregateHavingModifierEnums&& from) noexcept
    : ResolvedAggregateHavingModifierEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedAggregateHavingModifierEnums& operator=(ResolvedAggregateHavingModifierEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedAggregateHavingModifierEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedAggregateHavingModifierEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedAggregateHavingModifierEnums*>(
               &_ResolvedAggregateHavingModifierEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ResolvedAggregateHavingModifierEnums* other);
  friend void swap(ResolvedAggregateHavingModifierEnums& a, ResolvedAggregateHavingModifierEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedAggregateHavingModifierEnums* New() const final {
    return CreateMaybeMessage<ResolvedAggregateHavingModifierEnums>(NULL);
  }

  ResolvedAggregateHavingModifierEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedAggregateHavingModifierEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedAggregateHavingModifierEnums& from);
  void MergeFrom(const ResolvedAggregateHavingModifierEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedAggregateHavingModifierEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedAggregateHavingModifierEnums_HavingModifierKind HavingModifierKind;
  static const HavingModifierKind INVALID =
    ResolvedAggregateHavingModifierEnums_HavingModifierKind_INVALID;
  static const HavingModifierKind MAX =
    ResolvedAggregateHavingModifierEnums_HavingModifierKind_MAX;
  static const HavingModifierKind MIN =
    ResolvedAggregateHavingModifierEnums_HavingModifierKind_MIN;
  static inline bool HavingModifierKind_IsValid(int value) {
    return ResolvedAggregateHavingModifierEnums_HavingModifierKind_IsValid(value);
  }
  static const HavingModifierKind HavingModifierKind_MIN =
    ResolvedAggregateHavingModifierEnums_HavingModifierKind_HavingModifierKind_MIN;
  static const HavingModifierKind HavingModifierKind_MAX =
    ResolvedAggregateHavingModifierEnums_HavingModifierKind_HavingModifierKind_MAX;
  static const int HavingModifierKind_ARRAYSIZE =
    ResolvedAggregateHavingModifierEnums_HavingModifierKind_HavingModifierKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HavingModifierKind_descriptor() {
    return ResolvedAggregateHavingModifierEnums_HavingModifierKind_descriptor();
  }
  static inline const ::std::string& HavingModifierKind_Name(HavingModifierKind value) {
    return ResolvedAggregateHavingModifierEnums_HavingModifierKind_Name(value);
  }
  static inline bool HavingModifierKind_Parse(const ::std::string& name,
      HavingModifierKind* value) {
    return ResolvedAggregateHavingModifierEnums_HavingModifierKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedAggregateHavingModifierEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedStatementEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedStatementEnums) */ {
 public:
  ResolvedStatementEnums();
  virtual ~ResolvedStatementEnums();

  ResolvedStatementEnums(const ResolvedStatementEnums& from);

  inline ResolvedStatementEnums& operator=(const ResolvedStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedStatementEnums(ResolvedStatementEnums&& from) noexcept
    : ResolvedStatementEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedStatementEnums& operator=(ResolvedStatementEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedStatementEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedStatementEnums*>(
               &_ResolvedStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(ResolvedStatementEnums* other);
  friend void swap(ResolvedStatementEnums& a, ResolvedStatementEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedStatementEnums* New() const final {
    return CreateMaybeMessage<ResolvedStatementEnums>(NULL);
  }

  ResolvedStatementEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedStatementEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedStatementEnums& from);
  void MergeFrom(const ResolvedStatementEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedStatementEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedStatementEnums_ObjectAccess ObjectAccess;
  static const ObjectAccess NONE =
    ResolvedStatementEnums_ObjectAccess_NONE;
  static const ObjectAccess READ =
    ResolvedStatementEnums_ObjectAccess_READ;
  static const ObjectAccess WRITE =
    ResolvedStatementEnums_ObjectAccess_WRITE;
  static const ObjectAccess READ_WRITE =
    ResolvedStatementEnums_ObjectAccess_READ_WRITE;
  static inline bool ObjectAccess_IsValid(int value) {
    return ResolvedStatementEnums_ObjectAccess_IsValid(value);
  }
  static const ObjectAccess ObjectAccess_MIN =
    ResolvedStatementEnums_ObjectAccess_ObjectAccess_MIN;
  static const ObjectAccess ObjectAccess_MAX =
    ResolvedStatementEnums_ObjectAccess_ObjectAccess_MAX;
  static const int ObjectAccess_ARRAYSIZE =
    ResolvedStatementEnums_ObjectAccess_ObjectAccess_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ObjectAccess_descriptor() {
    return ResolvedStatementEnums_ObjectAccess_descriptor();
  }
  static inline const ::std::string& ObjectAccess_Name(ObjectAccess value) {
    return ResolvedStatementEnums_ObjectAccess_Name(value);
  }
  static inline bool ObjectAccess_Parse(const ::std::string& name,
      ObjectAccess* value) {
    return ResolvedStatementEnums_ObjectAccess_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedStatementEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedImportStmtEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedImportStmtEnums) */ {
 public:
  ResolvedImportStmtEnums();
  virtual ~ResolvedImportStmtEnums();

  ResolvedImportStmtEnums(const ResolvedImportStmtEnums& from);

  inline ResolvedImportStmtEnums& operator=(const ResolvedImportStmtEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedImportStmtEnums(ResolvedImportStmtEnums&& from) noexcept
    : ResolvedImportStmtEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedImportStmtEnums& operator=(ResolvedImportStmtEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedImportStmtEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedImportStmtEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedImportStmtEnums*>(
               &_ResolvedImportStmtEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ResolvedImportStmtEnums* other);
  friend void swap(ResolvedImportStmtEnums& a, ResolvedImportStmtEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedImportStmtEnums* New() const final {
    return CreateMaybeMessage<ResolvedImportStmtEnums>(NULL);
  }

  ResolvedImportStmtEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedImportStmtEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedImportStmtEnums& from);
  void MergeFrom(const ResolvedImportStmtEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedImportStmtEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedImportStmtEnums_ImportKind ImportKind;
  static const ImportKind MODULE =
    ResolvedImportStmtEnums_ImportKind_MODULE;
  static const ImportKind PROTO =
    ResolvedImportStmtEnums_ImportKind_PROTO;
  static const ImportKind __ImportKind__switch_must_have_a_default__ =
    ResolvedImportStmtEnums_ImportKind___ImportKind__switch_must_have_a_default__;
  static inline bool ImportKind_IsValid(int value) {
    return ResolvedImportStmtEnums_ImportKind_IsValid(value);
  }
  static const ImportKind ImportKind_MIN =
    ResolvedImportStmtEnums_ImportKind_ImportKind_MIN;
  static const ImportKind ImportKind_MAX =
    ResolvedImportStmtEnums_ImportKind_ImportKind_MAX;
  static const int ImportKind_ARRAYSIZE =
    ResolvedImportStmtEnums_ImportKind_ImportKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ImportKind_descriptor() {
    return ResolvedImportStmtEnums_ImportKind_descriptor();
  }
  static inline const ::std::string& ImportKind_Name(ImportKind value) {
    return ResolvedImportStmtEnums_ImportKind_Name(value);
  }
  static inline bool ImportKind_Parse(const ::std::string& name,
      ImportKind* value) {
    return ResolvedImportStmtEnums_ImportKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedImportStmtEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedForeignKeyEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedForeignKeyEnums) */ {
 public:
  ResolvedForeignKeyEnums();
  virtual ~ResolvedForeignKeyEnums();

  ResolvedForeignKeyEnums(const ResolvedForeignKeyEnums& from);

  inline ResolvedForeignKeyEnums& operator=(const ResolvedForeignKeyEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedForeignKeyEnums(ResolvedForeignKeyEnums&& from) noexcept
    : ResolvedForeignKeyEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedForeignKeyEnums& operator=(ResolvedForeignKeyEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedForeignKeyEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedForeignKeyEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedForeignKeyEnums*>(
               &_ResolvedForeignKeyEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(ResolvedForeignKeyEnums* other);
  friend void swap(ResolvedForeignKeyEnums& a, ResolvedForeignKeyEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedForeignKeyEnums* New() const final {
    return CreateMaybeMessage<ResolvedForeignKeyEnums>(NULL);
  }

  ResolvedForeignKeyEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedForeignKeyEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedForeignKeyEnums& from);
  void MergeFrom(const ResolvedForeignKeyEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedForeignKeyEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedForeignKeyEnums_MatchMode MatchMode;
  static const MatchMode SIMPLE =
    ResolvedForeignKeyEnums_MatchMode_SIMPLE;
  static const MatchMode FULL =
    ResolvedForeignKeyEnums_MatchMode_FULL;
  static const MatchMode NOT_DISTINCT =
    ResolvedForeignKeyEnums_MatchMode_NOT_DISTINCT;
  static inline bool MatchMode_IsValid(int value) {
    return ResolvedForeignKeyEnums_MatchMode_IsValid(value);
  }
  static const MatchMode MatchMode_MIN =
    ResolvedForeignKeyEnums_MatchMode_MatchMode_MIN;
  static const MatchMode MatchMode_MAX =
    ResolvedForeignKeyEnums_MatchMode_MatchMode_MAX;
  static const int MatchMode_ARRAYSIZE =
    ResolvedForeignKeyEnums_MatchMode_MatchMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MatchMode_descriptor() {
    return ResolvedForeignKeyEnums_MatchMode_descriptor();
  }
  static inline const ::std::string& MatchMode_Name(MatchMode value) {
    return ResolvedForeignKeyEnums_MatchMode_Name(value);
  }
  static inline bool MatchMode_Parse(const ::std::string& name,
      MatchMode* value) {
    return ResolvedForeignKeyEnums_MatchMode_Parse(name, value);
  }

  typedef ResolvedForeignKeyEnums_ActionOperation ActionOperation;
  static const ActionOperation NO_ACTION =
    ResolvedForeignKeyEnums_ActionOperation_NO_ACTION;
  static const ActionOperation RESTRICT =
    ResolvedForeignKeyEnums_ActionOperation_RESTRICT;
  static const ActionOperation CASCADE =
    ResolvedForeignKeyEnums_ActionOperation_CASCADE;
  static const ActionOperation SET_NULL =
    ResolvedForeignKeyEnums_ActionOperation_SET_NULL;
  static inline bool ActionOperation_IsValid(int value) {
    return ResolvedForeignKeyEnums_ActionOperation_IsValid(value);
  }
  static const ActionOperation ActionOperation_MIN =
    ResolvedForeignKeyEnums_ActionOperation_ActionOperation_MIN;
  static const ActionOperation ActionOperation_MAX =
    ResolvedForeignKeyEnums_ActionOperation_ActionOperation_MAX;
  static const int ActionOperation_ARRAYSIZE =
    ResolvedForeignKeyEnums_ActionOperation_ActionOperation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionOperation_descriptor() {
    return ResolvedForeignKeyEnums_ActionOperation_descriptor();
  }
  static inline const ::std::string& ActionOperation_Name(ActionOperation value) {
    return ResolvedForeignKeyEnums_ActionOperation_Name(value);
  }
  static inline bool ActionOperation_Parse(const ::std::string& name,
      ActionOperation* value) {
    return ResolvedForeignKeyEnums_ActionOperation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedForeignKeyEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolvedAuxLoadDataStmtEnums : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedAuxLoadDataStmtEnums) */ {
 public:
  ResolvedAuxLoadDataStmtEnums();
  virtual ~ResolvedAuxLoadDataStmtEnums();

  ResolvedAuxLoadDataStmtEnums(const ResolvedAuxLoadDataStmtEnums& from);

  inline ResolvedAuxLoadDataStmtEnums& operator=(const ResolvedAuxLoadDataStmtEnums& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolvedAuxLoadDataStmtEnums(ResolvedAuxLoadDataStmtEnums&& from) noexcept
    : ResolvedAuxLoadDataStmtEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedAuxLoadDataStmtEnums& operator=(ResolvedAuxLoadDataStmtEnums&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolvedAuxLoadDataStmtEnums& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolvedAuxLoadDataStmtEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedAuxLoadDataStmtEnums*>(
               &_ResolvedAuxLoadDataStmtEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ResolvedAuxLoadDataStmtEnums* other);
  friend void swap(ResolvedAuxLoadDataStmtEnums& a, ResolvedAuxLoadDataStmtEnums& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolvedAuxLoadDataStmtEnums* New() const final {
    return CreateMaybeMessage<ResolvedAuxLoadDataStmtEnums>(NULL);
  }

  ResolvedAuxLoadDataStmtEnums* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolvedAuxLoadDataStmtEnums>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolvedAuxLoadDataStmtEnums& from);
  void MergeFrom(const ResolvedAuxLoadDataStmtEnums& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedAuxLoadDataStmtEnums* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedAuxLoadDataStmtEnums_InsertionMode InsertionMode;
  static const InsertionMode NONE =
    ResolvedAuxLoadDataStmtEnums_InsertionMode_NONE;
  static const InsertionMode APPEND =
    ResolvedAuxLoadDataStmtEnums_InsertionMode_APPEND;
  static const InsertionMode OVERWRITE =
    ResolvedAuxLoadDataStmtEnums_InsertionMode_OVERWRITE;
  static inline bool InsertionMode_IsValid(int value) {
    return ResolvedAuxLoadDataStmtEnums_InsertionMode_IsValid(value);
  }
  static const InsertionMode InsertionMode_MIN =
    ResolvedAuxLoadDataStmtEnums_InsertionMode_InsertionMode_MIN;
  static const InsertionMode InsertionMode_MAX =
    ResolvedAuxLoadDataStmtEnums_InsertionMode_InsertionMode_MAX;
  static const int InsertionMode_ARRAYSIZE =
    ResolvedAuxLoadDataStmtEnums_InsertionMode_InsertionMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InsertionMode_descriptor() {
    return ResolvedAuxLoadDataStmtEnums_InsertionMode_descriptor();
  }
  static inline const ::std::string& InsertionMode_Name(InsertionMode value) {
    return ResolvedAuxLoadDataStmtEnums_InsertionMode_Name(value);
  }
  static inline bool InsertionMode_Parse(const ::std::string& name,
      InsertionMode* value) {
    return ResolvedAuxLoadDataStmtEnums_InsertionMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedAuxLoadDataStmtEnums)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ResolvedSubqueryExprEnums

// -------------------------------------------------------------------

// ResolvedJoinScanEnums

// -------------------------------------------------------------------

// ResolvedSetOperationScanEnums

// -------------------------------------------------------------------

// ResolvedRecursiveScanEnums

// -------------------------------------------------------------------

// ResolvedSampleScanEnums

// -------------------------------------------------------------------

// ResolvedOrderByItemEnums

// -------------------------------------------------------------------

// ResolvedCreateStatementEnums

// -------------------------------------------------------------------

// ResolvedGeneratedColumnInfoEnums

// -------------------------------------------------------------------

// ResolvedDropStmtEnums

// -------------------------------------------------------------------

// ResolvedBeginStmtEnums

// -------------------------------------------------------------------

// ResolvedWindowFrameEnums

// -------------------------------------------------------------------

// ResolvedWindowFrameExprEnums

// -------------------------------------------------------------------

// ResolvedInsertStmtEnums

// -------------------------------------------------------------------

// ResolvedMergeWhenEnums

// -------------------------------------------------------------------

// ResolvedArgumentDefEnums

// -------------------------------------------------------------------

// ResolvedFunctionCallBaseEnums

// -------------------------------------------------------------------

// ResolvedNonScalarFunctionCallBaseEnums

// -------------------------------------------------------------------

// ResolvedAggregateHavingModifierEnums

// -------------------------------------------------------------------

// ResolvedStatementEnums

// -------------------------------------------------------------------

// ResolvedImportStmtEnums

// -------------------------------------------------------------------

// ResolvedForeignKeyEnums

// -------------------------------------------------------------------

// ResolvedAuxLoadDataStmtEnums

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace zetasql

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::zetasql::ResolvedSubqueryExprEnums_SubqueryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedSubqueryExprEnums_SubqueryType>() {
  return ::zetasql::ResolvedSubqueryExprEnums_SubqueryType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedJoinScanEnums_JoinType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedJoinScanEnums_JoinType>() {
  return ::zetasql::ResolvedJoinScanEnums_JoinType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedSetOperationScanEnums_SetOperationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedSetOperationScanEnums_SetOperationType>() {
  return ::zetasql::ResolvedSetOperationScanEnums_SetOperationType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedRecursiveScanEnums_RecursiveSetOperationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedRecursiveScanEnums_RecursiveSetOperationType>() {
  return ::zetasql::ResolvedRecursiveScanEnums_RecursiveSetOperationType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedSampleScanEnums_SampleUnit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedSampleScanEnums_SampleUnit>() {
  return ::zetasql::ResolvedSampleScanEnums_SampleUnit_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedOrderByItemEnums_NullOrderMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedOrderByItemEnums_NullOrderMode>() {
  return ::zetasql::ResolvedOrderByItemEnums_NullOrderMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedCreateStatementEnums_CreateScope> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedCreateStatementEnums_CreateScope>() {
  return ::zetasql::ResolvedCreateStatementEnums_CreateScope_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedCreateStatementEnums_CreateMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedCreateStatementEnums_CreateMode>() {
  return ::zetasql::ResolvedCreateStatementEnums_CreateMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedCreateStatementEnums_SqlSecurity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedCreateStatementEnums_SqlSecurity>() {
  return ::zetasql::ResolvedCreateStatementEnums_SqlSecurity_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedCreateStatementEnums_DeterminismLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedCreateStatementEnums_DeterminismLevel>() {
  return ::zetasql::ResolvedCreateStatementEnums_DeterminismLevel_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedGeneratedColumnInfoEnums_StoredMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedGeneratedColumnInfoEnums_StoredMode>() {
  return ::zetasql::ResolvedGeneratedColumnInfoEnums_StoredMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedDropStmtEnums_DropMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedDropStmtEnums_DropMode>() {
  return ::zetasql::ResolvedDropStmtEnums_DropMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedBeginStmtEnums_ReadWriteMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedBeginStmtEnums_ReadWriteMode>() {
  return ::zetasql::ResolvedBeginStmtEnums_ReadWriteMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedWindowFrameEnums_FrameUnit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedWindowFrameEnums_FrameUnit>() {
  return ::zetasql::ResolvedWindowFrameEnums_FrameUnit_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedWindowFrameExprEnums_BoundaryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedWindowFrameExprEnums_BoundaryType>() {
  return ::zetasql::ResolvedWindowFrameExprEnums_BoundaryType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedInsertStmtEnums_InsertMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedInsertStmtEnums_InsertMode>() {
  return ::zetasql::ResolvedInsertStmtEnums_InsertMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedMergeWhenEnums_MatchType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedMergeWhenEnums_MatchType>() {
  return ::zetasql::ResolvedMergeWhenEnums_MatchType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedMergeWhenEnums_ActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedMergeWhenEnums_ActionType>() {
  return ::zetasql::ResolvedMergeWhenEnums_ActionType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedArgumentDefEnums_ArgumentKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedArgumentDefEnums_ArgumentKind>() {
  return ::zetasql::ResolvedArgumentDefEnums_ArgumentKind_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedFunctionCallBaseEnums_ErrorMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedFunctionCallBaseEnums_ErrorMode>() {
  return ::zetasql::ResolvedFunctionCallBaseEnums_ErrorMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier>() {
  return ::zetasql::ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedAggregateHavingModifierEnums_HavingModifierKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedAggregateHavingModifierEnums_HavingModifierKind>() {
  return ::zetasql::ResolvedAggregateHavingModifierEnums_HavingModifierKind_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedStatementEnums_ObjectAccess> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedStatementEnums_ObjectAccess>() {
  return ::zetasql::ResolvedStatementEnums_ObjectAccess_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedImportStmtEnums_ImportKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedImportStmtEnums_ImportKind>() {
  return ::zetasql::ResolvedImportStmtEnums_ImportKind_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedForeignKeyEnums_MatchMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedForeignKeyEnums_MatchMode>() {
  return ::zetasql::ResolvedForeignKeyEnums_MatchMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedForeignKeyEnums_ActionOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedForeignKeyEnums_ActionOperation>() {
  return ::zetasql::ResolvedForeignKeyEnums_ActionOperation_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedAuxLoadDataStmtEnums_InsertionMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedAuxLoadDataStmtEnums_InsertionMode>() {
  return ::zetasql::ResolvedAuxLoadDataStmtEnums_InsertionMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto
